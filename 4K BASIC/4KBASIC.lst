0001   0000             ; ZX80 4K BASIC for Minstrel 4th
0002   0000             
0003   0000             ; Building:
0004   0000             ; TASM.EXE -t80 -fff -b 4KBASIC.asm 4KBASIC.bin 
0005   0000             
0006   0000             ; Original ZX80 4K BASIC ROM disassembly and comments by Geoff Wearmouth
0007   0000             
0008   0000             ; Mods Dave Curran 2023, updated 2025-05-17
0009   0000             
0010   0000             ; ZX80 4K BASIC for Minstrel 4th memory map:
0011   0000             ;
0012   0000             ; 0000 - 0DFF   Original BASIC ROM with minimal modifications
0013   0000             ; 0E00 - 0FFF   ZX80 font
0014   0000             ; 1000 - 1FFF   New display, load and save code
0015   0000             
0016   0000             ; 2000 - 23FF   1K Video RAM mirror
0017   0000             ; 2400 - 27FF   1K Video RAM 40x25 characters
0018   0000             
0019   0000             ; 2800 - 2BFF   1K Font RAM mirror (write only)
0020   0000             ; 2C00 - 2FFF   1K Font RAM 128 characters (write only)
0021   0000             
0022   0000             ; 3C00 - 3FFF   1K RAM (available, not used by BASIC)
0023   0000             ; 4000 - 7FFF   16K RAM
0024   0000             ; 8000 - FFFF   32K RAM (available, not used by BASIC)
0025   0000             
0026   0000             
0027   0000             ; TASM cross-assembler directives. 
0028   0000             
0029   0000             #define DEFB .BYTE      
0030   0000             #define DEFW .WORD
0031   0000             #define EQU  .EQU
0032   0000             
0033   0000             .ORG $0000
0034   0000             
0035   0000             ; -----------
0036   0000             ; THE 'START'
0037   0000             ; -----------
0038   0000             
0039   0000             ;; START
0040   0000 C3 00 10    L0000:  JP      INIT_4TH         ; Jump to 4TH init code, which will then go to RAM-FILL
0041   0003             
0042   0003 FF                  DEFB    $FF
0043   0004 FF                  DEFB    $FF
0044   0005 FF                  DEFB    $FF
0045   0006 FF                  DEFB    $FF
0046   0007 FF                  DEFB    $FF
0047   0008             
0048   0008             ; -------------------
0049   0008             ; THE 'ERROR' RESTART
0050   0008             ; -------------------
0051   0008             
0052   0008             ;; ERROR-1
0053   0008 E1          L0008:  POP     HL              ; drop the return address.
0054   0009 6E                  LD      L,(HL)          ; fetch the error code after RST 8.
0055   000A FD CB 00 7E         BIT     7,(IY+$00)      ; test ERR_NR for value $FF (OK)
0056   000E 18 03               JR      L0013           ; forward to continue at ERROR-2.
0057   0010             
0058   0010             ; -------------------------------
0059   0010             ; THE 'PRINT A CHARACTER' RESTART
0060   0010             ; -------------------------------
0061   0010             
0062   0010             
0063   0010             ;; PRINT-A
0064   0010 C3 60 05    L0010:  JP      L0560           ; jump forward immediately to PRINT-A-2
0065   0013             
0066   0013             ; ---
0067   0013             
0068   0013             ; A continuation of the previous Error restart.
0069   0013             
0070   0013             ;; ERROR-2
0071   0013 C8          L0013:  RET     Z               ; return if $FF - OK.
0072   0014             
0073   0014 FD 75 00            LD      (IY+$00),L      ; else set system variable ERR_NR
0074   0017 C9                  RET                     ; return.
0075   0018             
0076   0018             ; ---------------------------------------------
0077   0018             ; THE 'COLLECT NEXT CHARACTER OR SPACE' RESTART
0078   0018             ; ---------------------------------------------
0079   0018             ; This will collect any next character including space (zero).
0080   0018             
0081   0018             ;; NXT-CH-SP
0082   0018 18 38       L0018:  JR      L0052           ; forward to CH_ADD+1
0083   001A             
0084   001A             ; ---
0085   001A             
0086   001A             ; This subroutine will collect the character at the current character address
0087   001A             ; searching for the next non-space character should the fetched character be
0088   001A             ; a space.
0089   001A             
0090   001A             ;; get-char
0091   001A 2A 26 40    L001A:  LD      HL,($4026)      ; get pointer from CH_ADD
0092   001D 7E                  LD      A,(HL)          ; fetch addressed character.
0093   001E             
0094   001E             ; This subroutine tests the current character in the accumulator retrieving
0095   001E             ; the next non-space character should the accumulator contain a space
0096   001E             
0097   001E             ;; TEST-CHAR
0098   001E A7          L001E:  AND     A               ; test for space (zero).
0099   001F C0                  RET     NZ              ; return if not a space.
0100   0020             
0101   0020             ;-------------------------------------------
0102   0020             ; THE 'COLLECT NEXT VALID CHARACTER' RESTART
0103   0020             ;-------------------------------------------
0104   0020             
0105   0020             ;; NEXT-CHAR
0106   0020 CD 52 00    L0020:  CALL    L0052           ; routine CH_ADD+1
0107   0023 18 F9               JR      L001E           ; loop back to TEST-CHAR until valid
0108   0025             
0109   0025             ; ---
0110   0025             
0111   0025             ; This subroutine advances the character pointer and evaluates the following
0112   0025             ; expression.
0113   0025             ; It is called twice with CH_ADD addressing the '(' character
0114   0025             
0115   0025             
0116   0025             ;; EVAL-EXPR
0117   0025 CD 55 00    L0025:  CALL    L0055           ; routine CH_ADD_LP
0118   0028             
0119   0028             ; ---------------------------------
0120   0028             ; THE 'SCANNING-CALCULATOR' RESTART
0121   0028             ; ---------------------------------
0122   0028             
0123   0028             ;; SCAN-CALC
0124   0028 CD 1A 00    L0028:  CALL    L001A           ; routine get-char.
0125   002B 06 00               LD      B,$00           ; set B to zero as a starting
0126   002D                                             ; priority marker.
0127   002D C3 E1 09            JP      L09E1           ; jump forward to SCANNING
0128   0030             
0129   0030             ; ----------------------------
0130   0030             ; THE 'MAKE BC SPACES' RESTART
0131   0030             ; ----------------------------
0132   0030             
0133   0030             ;; BC-SPACES
0134   0030 CD 4F 09    L0030:  CALL    L094F           ; routine TEST-ROOM
0135   0033 D0                  RET     NC              ; return if not enough room.
0136   0034             
0137   0034 C5                  PUSH    BC              ; save number of bytes required.
0138   0035 C3 F3 0C            JP      L0CF3           ; jump forward to RESERVE
0139   0038             
0140   0038             ; --------------------------------
0141   0038             ; THE 'MASKABLE INTERRUPT' ROUTINE
0142   0038             ; --------------------------------
0143   0038             ; Called once every frame does nothing other than wake from halt
0144   0038             
0145   0038             ;; MASK-INT
0146   0038 C9          L0038:  RET
0147   0039             
0148   0039             ;; Continuation of CH_ADD relocated here to avoid blocking NMI
0149   0039             L0039:
0150   0039 22 04 40            LD      ($4004),HL      ; set P_PTR system variable
0151   003C FD CB 19 7E         BIT     7,(IY+$19)      ; test FLAGX - will be set if K-mode
0152   0040 28 13               JR      Z,L0055         ; back to CH_ADD_LP if not K-mode
0153   0042 FD CB 01 D6         SET     2,(IY+$01)      ; update FLAGS set K mode.
0154   0046 18 0D               JR      L0055           ; back to CH_ADD_LP
0155   0048             
0156   0048             ; SPACE HERE
0157   0048             
0158   0048             ; ----------------------------------------------
0159   0048             ; THE 'EVALUATE BRACKETED EXPRESSION' SUBROUTINE
0160   0048             ; ----------------------------------------------
0161   0048             ; This subroutine is used when an opening bracket is encountered to evaluate
0162   0048             ; the expression within. It is called from LOOK-VARS when an integral function
0163   0048             ; or array is encountered and recursively from within SCANNING when any 
0164   0048             ; bracketed argument or sub-expression is encountered.
0165   0048             
0166   0049             .ORG $0049
0167   0049             ;; BRACKET
0168   0049 CD 25 00    L0049:  CALL    L0025           ; routine EVAL-EXPR
0169   004C 7E                  LD      A,(HL)          ; fetch subsequent character
0170   004D FE D9               CP      $D9             ; is character a ')' ?
0171   004F C2 AE 08            JP      NZ,L08AE        ; jump to INS-ERR with other characters.
0172   0052             
0173   0052             ; else continue and get the character after the ')' ...
0174   0052             
0175   0052             ; ---------------------------------
0176   0052             ; THE 'INCREMENT CH_ADD' SUBROUTINE
0177   0052             ; ---------------------------------
0178   0052             
0179   0052             ;; CH_ADD+1
0180   0052 2A 26 40    L0052:  LD      HL,($4026)      ; fetch character address from CH_ADD
0181   0055             
0182   0055             ;; CH_ADD_LP
0183   0055 23          L0055:  INC     HL              ; increment the pointer.
0184   0056 22 26 40            LD      ($4026),HL      ; set system variable CH_ADD
0185   0059 7E                  LD      A,(HL)          ; fetch the addressed value.
0186   005A FE B0               CP      $B0             ; is character inverse 'K'
0187   005C CA 39 00            JP      Z,L0039         ; continue if it is
0188   005F C9                  RET                     ; return if not.                >>
0189   0060             
0190   0060             ; SPACE HERE
0191   0060             
0192   0066             .ORG $0066
0193   0066             
0194   0066             ; ------------------------------------
0195   0066             ; THE 'NON MASKABLE INTERRUPT' ROUTINE
0196   0066             ; ------------------------------------
0197   0066             ;; NMI
0198   0066 ED 45       L0066:  RETN                    ; no NMI on 4th 
0199   0068             
0200   0068             ; SPACE HERE
0201   0068             
0202   006C             .ORG $006C
0203   006C             ; ---------------
0204   006C             ; THE 'KEY' TABLE
0205   006C             ; ---------------
0206   006C             ; The Key Table is indexed with a key value 1-78.
0207   006C             
0208   006C             ; -----------------------
0209   006C             ; THE 39 'UNSHIFTED' KEYS
0210   006C             ; -----------------------
0211   006C             
0212   006C             ;; MAIN-KEYS
0213   006C 1B          L006C:  DEFB    $1B             ; .     ;# $3F             ; Z
0214   006D 3F                  DEFB    $3F             ; Z     ;# $3D             ; X
0215   006E 3D                  DEFB    $3D             ; X     ;# $28             ; C
0216   006F 28                  DEFB    $28             ; C     ;# $3B             ; V
0217   0070             
0218   0070 26                  DEFB    $26             ; A
0219   0071 38                  DEFB    $38             ; S
0220   0072 29                  DEFB    $29             ; D
0221   0073 2B                  DEFB    $2B             ; F
0222   0074 2C                  DEFB    $2C             ; G
0223   0075             
0224   0075 36                  DEFB    $36             ; Q
0225   0076 3C                  DEFB    $3C             ; W
0226   0077 2A                  DEFB    $2A             ; E
0227   0078 37                  DEFB    $37             ; R
0228   0079 39                  DEFB    $39             ; T
0229   007A             
0230   007A 1D                  DEFB    $1D             ; 1
0231   007B 1E                  DEFB    $1E             ; 2
0232   007C 1F                  DEFB    $1F             ; 3
0233   007D 20                  DEFB    $20             ; 4
0234   007E 21                  DEFB    $21             ; 5
0235   007F             
0236   007F 1C                  DEFB    $1C             ; 0
0237   0080 25                  DEFB    $25             ; 9
0238   0081 24                  DEFB    $24             ; 8
0239   0082 23                  DEFB    $23             ; 7
0240   0083 22                  DEFB    $22             ; 6
0241   0084             
0242   0084 35                  DEFB    $35             ; P
0243   0085 34                  DEFB    $34             ; O
0244   0086 2E                  DEFB    $2E             ; I
0245   0087 3A                  DEFB    $3A             ; U
0246   0088 3E                  DEFB    $3E             ; Y
0247   0089             
0248   0089 76                  DEFB    $76             ; NEWLINE       ED-ENTER
0249   008A 31                  DEFB    $31             ; L
0250   008B 30                  DEFB    $30             ; K
0251   008C 2F                  DEFB    $2F             ; J
0252   008D 2D                  DEFB    $2D             ; H
0253   008E             
0254   008E 00                  DEFB    $00             ; SPACE
0255   008F 32                  DEFB    $32             ; M     ;# $1B             ; .
0256   0090 33                  DEFB    $33             ; N     ;# $32             ; M
0257   0091 27                  DEFB    $27             ; B     ;# $33             ; N
0258   0092 3B                  DEFB    $3B             ; V     ;# $27             ; B
0259   0093             
0260   0093             ; ----------------------
0261   0093             ; THE 39 'SHIFTED' CODES
0262   0093             ; ----------------------
0263   0093             
0264   0093 D8                  DEFB    $D8             ; ','   ;# $0E             ; ':'
0265   0094 0E                  DEFB    $0E             ; ':'   ;# $D7             ; ';'
0266   0095 D7                  DEFB    $D7             ; ';'   ;# $0F             ; '?'
0267   0096 0F                  DEFB    $0F             ; '?'   ;# $DF             ; '/'
0268   0097             
0269   0097 09                  DEFB    $09             ; mosaic $09
0270   0098 08                  DEFB    $08             ; mosaic $08
0271   0099 06                  DEFB    $06             ; mosaic $06
0272   009A 07                  DEFB    $07             ; mosaic $07
0273   009B 0B                  DEFB    $0B             ; mosaic $0B
0274   009C             
0275   009C 02                  DEFB    $02             ; mosaic $02
0276   009D 03                  DEFB    $03             ; mosaic $03
0277   009E 04                  DEFB    $04             ; mosaic $0A
0278   009F 05                  DEFB    $05             ; mosaic $04
0279   00A0 0A                  DEFB    $0A             ; mosaic $05
0280   00A1             
0281   00A1 DB                  DEFB    $DB             ; 'NOT'
0282   00A2 E0                  DEFB    $E0             ; 'AND'
0283   00A3 D5                  DEFB    $D5             ; 'THEN'
0284   00A4 D6                  DEFB    $D6             ; 'TO'
0285   00A5 72                  DEFB    $72             ; cursor left
0286   00A6             
0287   00A6 77                  DEFB    $77             ; [ RUBOUT ]
0288   00A7 74                  DEFB    $74             ; [ HOME ]
0289   00A8 73                  DEFB    $73             ; cursor right
0290   00A9 70                  DEFB    $70             ; cursor up
0291   00AA 71                  DEFB    $71             ; cursor down
0292   00AB             
0293   00AB DE                  DEFB    $DE             ; '*'
0294   00AC D9                  DEFB    $D9             ; ')'
0295   00AD DA                  DEFB    $DA             ; '('
0296   00AE 0D                  DEFB    $0D             ; '$'
0297   00AF 01                  DEFB    $01             ; '"'
0298   00B0             
0299   00B0 75                  DEFB    $75             ; [ EDIT ]
0300   00B1 E3                  DEFB    $E3             ; '='
0301   00B2 DD                  DEFB    $DD             ; '+'
0302   00B3 DC                  DEFB    $DC             ; '-'
0303   00B4 E2                  DEFB    $E2             ; '**'
0304   00B5             
0305   00B5 0C                  DEFB    $0C             ; uk currency symbol
0306   00B6 E4                  DEFB    $E4             ; '>'   ;# $D8             ; ','
0307   00B7 E5                  DEFB    $E5             ; '<'   ;# $E4             ; '>'
0308   00B8 E1                  DEFB    $E1             ; 'OR'  ;# $E5             ; '<'
0309   00B9 DF                  DEFB    $DF             ; '/'   ;# $E1             ; 'OR'
0310   00BA             
0311   00BA             ; -----------------
0312   00BA             ; THE 'TOKEN' TABLE
0313   00BA             ; -----------------
0314   00BA             
0315   00BA             
0316   00BA             ;; TKN-TABLE
0317   00BA D4          L00BA:  DEFB    $D4                     ; chr$ 212 - the threshold character
0318   00BB                                                     ; tokens below this are printed using
0319   00BB                                                     ; the next character
0320   00BB 8F                  DEFB    $8F                     ; '?' + $80
0321   00BC 81                  DEFB    $81                     ; '"' + $80
0322   00BD             
0323   00BD 39 2D 2A B3         DEFB    $39,$2D,$2A,$B3         ; THEN
0324   00C1 39 B4               DEFB    $39,$B4                 ; TO
0325   00C3 99                  DEFB    $99                     ; ;
0326   00C4 9A                  DEFB    $9A                     ; ,
0327   00C5 91                  DEFB    $91                     ; (
0328   00C6 90                  DEFB    $90                     ; )
0329   00C7 33 34 B9            DEFB    $33,$34,$B9             ; NOT
0330   00CA 92                  DEFB    $92                     ; -
0331   00CB 93                  DEFB    $93                     ; +
0332   00CC 94                  DEFB    $94                     ; *
0333   00CD 95                  DEFB    $95                     ; /
0334   00CE 26 33 A9            DEFB    $26,$33,$A9             ; AND
0335   00D1 34 B7               DEFB    $34,$B7                 ; OR
0336   00D3 14 94               DEFB    $14,$14+$80             ; **
0337   00D5 96                  DEFB    $96                     ; =
0338   00D6 97                  DEFB    $97                     ; <
0339   00D7 98                  DEFB    $98                     ; >
0340   00D8 31 2E 38 B9         DEFB    $31,$2E,$38,$B9         ; LIST
0341   00DC 37 2A 39 3A         DEFB    $37,$2A,$39,$3A,$37,$B3 ; RETURN
0341   00E0 37 B3 
0342   00E2 28 31 B8            DEFB    $28,$31,$B8             ; CLS
0343   00E5 29 2E B2            DEFB    $29,$2E,$B2             ; DIM
0344   00E8 38 26 3B AA         DEFB    $38,$26,$3B,$AA         ; SAVE
0345   00EC 2B 34 B7            DEFB    $2B,$34,$B7             ; FOR
0346   00EF 2C 34 00 39         DEFB    $2C,$34,$00,$39,$B4     ; GO TO
0346   00F3 B4 
0347   00F4 35 34 30 AA         DEFB    $35,$34,$30,$AA         ; POKE
0348   00F8 2E 33 35 3A         DEFB    $2E,$33,$35,$3A,$B9     ; INPUT
0348   00FC B9 
0349   00FD 37 26 33 29         DEFB    $37,$26,$33,$29         ; ...
0350   0101 34 32 2E 38         DEFB    $34,$32,$2E,$38,$AA     ; RANDOMISE
0350   0105 AA 
0351   0106 31 2A B9            DEFB    $31,$2A,$B9             ; LET
0352   0109 8F                  DEFB    $8F                     ; '?' + $80
0353   010A 8F                  DEFB    $8F                     ; '?' + $80
0354   010B 33 2A 3D B9         DEFB    $33,$2A,$3D,$B9         ; NEXT
0355   010F 35 37 2E 33         DEFB    $35,$37,$2E,$33,$B9     ; PRINT
0355   0113 B9 
0356   0114 8F                  DEFB    $8F                     ; '?' + $80
0357   0115 33 2A BC            DEFB    $33,$2A,$BC             ; NEW
0358   0118 37 3A B3            DEFB    $37,$3A,$B3             ; RUN
0359   011B 38 39 34 B5         DEFB    $38,$39,$34,$B5         ; STOP
0360   011F 28 34 33 39         DEFB    $28,$34,$33,$39,$2E     ; ...
0360   0123 2E 
0361   0124 33 3A AA            DEFB    $33,$3A,$AA             ; CONTINUE
0362   0127 2E AB               DEFB    $2E,$AB                 ; IF
0363   0129 2C 34 00 38         DEFB    $2C,$34,$00,$38,$3A,$A7 ; GO SUB
0363   012D 3A A7 
0364   012F 31 34 26 A9         DEFB    $31,$34,$26,$A9         ; LOAD
0365   0133 28 31 2A 26         DEFB    $28,$31,$2A,$26,$B7     ; CLEAR
0365   0137 B7 
0366   0138 37 2A B2            DEFB    $37,$2A,$B2             ; REM
0367   013B 8F                  DEFB    $8F                     ; '?' + $80
0368   013C             
0369   013C             
0370   013C             ; ----------------------
0371   013C             ; THE 'DISPLAY' ROUTINES
0372   013C             ; ----------------------
0373   013C             
0374   013C             ; ->
0375   013C             
0376   013C             ;; DISP-1
0377   013C CD AD 01    L013C:  CALL    L01AD           ;; routine DISP-2
0378   013F                                             ;# this second call generated the bottom border
0379   013F                                             ;# (or in the case of the 4TH, waits for the VSync)
0380   013F             
0381   013F             ; The initial entry point 
0382   013F             
0383   013F             ;; KEYBOARD
0384   013F 06 08       L013F:  LD      B,$08           ; (7) set counter to 8
0385   0141             
0386   0141             ;; KB-1
0387   0141 10 FE       L0141:  DJNZ    L0141           ; (13,8) and loop back 7 times. (7*13+8)
0388   0143             
0389   0143                                             ;       "WASTE 99 T-STATES"
0390   0143             
0391   0143             ;; KB-2
0392   0143 2A 1E 40    L0143:  LD      HL,($401E)      ; (16) fetch two-byte FRAMES value.
0393   0146 23                  INC     HL              ; ( 6) increment
0394   0147 22 1E 40            LD      ($401E),HL      ; (16) and store in FRAMES again.
0395   014A             
0396   014A             ; now read the keyboard
0397   014A             
0398   014A 21 FF FF            LD      HL,$FFFF        ; (10) prepare a buffer
0399   014D 06 FE               LD      B,$FE           ; ( 7) set B to $FE 
0400   014F 48                  LD      C,B             ; ( 4) now BC is $FEFE - slightly slower than
0401   0150                                             ; the equally time-critical LD BC,$FEFE  (10)  
0402   0150                                             ; that is used in the ZX81 ROM.             
0403   0150 ED 78               IN      A,(C)           ; (12) now read port $FEFE the half-row with 
0404   0152                                             ; the shift key.
0405   0152             
0406   0152                                             ; "START FRAME SYNC"
0407   0152             ;   START COUNTING
0408   0152             
0409   0152 F6 01               OR      $01             ; (7) set the rightmost bit so as to ignore 
0410   0154                                             ; shift.
0411   0154             
0412   0154             
0413   0154             ;; EACH-LINE
0414   0154 F6 E0       L0154:  OR      $E0             ; [7] OR 11100000.
0415   0156 57                  LD      D,A             ; [4] transfer to D.
0416   0157 2F                  CPL                     ; [4] complement - only bits 4-0 meaningful now.
0417   0158 FE 01               CP      $01             ; [7] sets carry if A is zero.
0418   015A 9F                  SBC     A,A             ; [4] $FF if $00 else zero.
0419   015B B0                  OR      B               ; [4] $FF or port FE,FD,FB....
0420   015C A5                  AND     L               ; [4] unless more than one key, L will still 
0421   015D                                             ;     be $FF if more than one key pressed A 
0422   015D                                             ;     is now invalid
0423   015D 6F                  LD      L,A             ; [4] transfer to L.
0424   015E             
0425   015E             ; now consider the column identifier.
0426   015E             
0427   015E 7C                  LD      A,H             ; [4] will be $FF if no previous keys.
0428   015F A2                  AND     D               ; [4] 111xxxxx
0429   0160 67                  LD      H,A             ; [4] transfer A to H
0430   0161             
0431   0161             ; since only one key may be pressed, H will, if valid, be one of
0432   0161             ; 11111110, 11111101, 11111011, 11110111, 11101111
0433   0161             ; reading from the outer column, say Q, to the inner column, say T.
0434   0161             
0435   0161 CB 00               RLC     B               ; [8] rotate the 8-counter/port address.
0436   0163                                             ;     sets carry if more to do.
0437   0163 ED 78               IN      A,(C)           ; [12] read another half-row.
0438   0165                                             ;      all five bits this time.
0439   0165             
0440   0165 38 ED               JR      C,L0154         ; [12],(7) loop back, until done, to EACH-LINE
0441   0167             
0442   0167                                             ; (658 T-states). 
0443   0167             
0444   0167             ; the last row read is SHIFT,Z,X,C,V for the second time.
0445   0167             
0446   0167 1F                  RRA                     ; (4) test the shift key - carry reset if
0447   0168                                             ;     pressed.
0448   0168             
0449   0168             ;; KB-3
0450   0168 CB 14       L0168:  RL      H               ; (8) rotate H to the left picking up the carry.
0451   016A                                             ;     giving column values -
0452   016A                                             ;        $FD, $FB, $F7, $EF, $DF.
0453   016A                                             ;     or $FC, $FA, $F6, $EE, $DE if shifted.
0454   016A             
0455   016A             ; we now have H identifying the columns and L identifying the row of the
0456   016A             ; keyboard matrix.
0457   016A             
0458   016A             ; This is a good time to test if this is an American or British machine.
0459   016A             ; The US machine has an extra diode that causes bit 6 of a byte read from a
0460   016A             ; port to be reset.
0461   016A             
0462   016A             ;# Bits 6 and 7 of the port FE are not implemented on the 4TH
0463   016A             ;# The bus pullup resistors will make this read as a 1, UK 50Hz.
0464   016A             
0465   016A 17                  RLA                     ; (4) compensate for the shift test.
0466   016B 17                  RLA                     ; (4) rotate bit 7 out.
0467   016C 17                  RLA                     ; (4) test bit 6.
0468   016D 9F                  SBC     A,A             ; (4) $FF or $00 (USA)
0469   016E E6 18               AND     $18             ; (7) and 24
0470   0170 C6 20               ADD     A,$20           ; (7) add 32
0471   0172             
0472   0172             ; gives either 32 (USA) or 56 (UK) blank lines above the TV picture.
0473   0172             ; This value will be decremented for the lower border.
0474   0172             
0475   0172 32 23 40            LD      ($4023),A       ; (13) place margin in RESULT_hi.
0476   0175             
0477   0175             ; The next snippet tests that the same raw key is read twice in succession.
0478   0175             ; The first time through, the routine uses a character address value,
0479   0175             ; which is inappropriate to match against a key value, but the next time
0480   0175             ; through it matches the key value it placed there on the first pass.
0481   0175             ; Seems to be 713 T-states.
0482   0175             ;
0483   0175             ; "717 T-STATES SINCE START OF FRAME SYNC, 545 BEFORE END"
0484   0175             
0485   0175 ED 4B 26 40         LD      BC,($4026)      ; (20) fetch possible previous key value from 
0486   0179                                             ;      CH_ADD
0487   0179 22 26 40            LD      ($4026),HL      ; (16) put the fresh key value in CH_ADD.
0488   017C             
0489   017C 78                  LD      A,B             ; ( 4)  fetch high byte.
0490   017D C6 02               ADD     A,$02           ; ( 7)  test for $FF, no-key which will set 
0491   017F                                             ;      carry.
0492   017F             
0493   017F ED 42               SBC     HL,BC           ; (15) subtract the two raw keys.
0494   0181 EB                  EX      DE,HL           ; ( 4) result, possibly zero, to DE.
0495   0182             
0496   0182 21 22 40            LD      HL,$4022        ; (10) now address system variable RESULT.
0497   0185 7E                  LD      A,(HL)          ; ( 7) load A from RESULT_lo.
0498   0186 B2                  OR      D               ; ( 4) check the 
0499   0187 B3                  OR      E               ; ( 4) subtraction result.
0500   0188 C8                  RET     Z               ; ( 5,11) return if all three zero.       >>>
0501   0189                     
0502   0189             ; T-states = 96 so far
0503   0189             ; proceed to debounce. The 'no-key' value $FF must be returned five times
0504   0189             ; before a new key is accepted above.
0505   0189             ; Holding down a key causes the shift counter to be maintained at five.
0506   0189             ; The initial state of RESULT is unimportant.
0507   0189             
0508   0189 78                  LD      A,B             ; ( 4) fetch hi byte of PREVIOUS key code.
0509   018A FE FE               CP      $FE             ; ( 7) sets carry if valid - 
0510   018C                                             ;      $FD, $FB, $F7, $EF, $DF
0511   018C 9F                  SBC     A,A             ; ( 4) gives $FF if pressed or $00 if no-key.
0512   018D             
0513   018D 06 1F               LD      B,$1F           ; ( 7) prepare the shift counter 
0514   018F                                             ;      (and also the timed delay)
0515   018F             
0516   018F B6                  OR      (HL)            ; ( 7) OR with RESULT_lo
0517   0190 A0                  AND     B               ; ( 4) limit the count to five set bits.
0518   0191 1F                  RRA                     ; ( 4) 'shift' to right
0519   0192 77                  LD      (HL),A          ; ( 7) place result in RESULT_lo
0520   0193             
0521   0193 05                  DEC     B               ; ( 4) adjust the delay counter B to thirty.
0522   0194             
0523   0194             ; t states = 48 ( Total 96+48=144)
0524   0194             
0525   0194             ;; KB-4
0526   0194 10 FE       L0194:  DJNZ    L0194           ;; (13,8) wait a while looping to KB-4 
0527   0196                                             ;; equals 13*29+8 = 385
0528   0196             
0529   0196                                             ; "FRAME SYNC ENDS AT NEXT M1"
0530   0196             
0531   0196             
0532   0196                     ;# OUT     ($FF),A         ;; (11) stops the VSYNC pulse
0533   0196 00                  NOP
0534   0197 00                  NOP
0535   0198             
0536   0198             
0537   0198 3E EC               LD      A,$EC           ;; ( 7) the value for R register
0538   019A 06 19               LD      B,$19           ;; there are 25 HALTs including the initial
0539   019C                                             ;; one.
0540   019C 2A 0C 40            LD      HL,($400C)      ;; point HL to D-FILE the first HALT
0541   019F                                             ;; instruction.
0542   019F CB FC               SET     7,H             ;; now point to the DFILE echo in the 
0543   01A1                                             ;; top 32K of address space.
0544   01A1             
0545   01A1 CD AD 01            CALL    L01AD           ;; routine DISP-2 
0546   01A4                                             ;# this call will generate the top border
0547   01A4                                             ;# and visible screen
0548   01A4             
0549   01A4 3E F3               LD      A,$F3           ;; prepare to set the R refresh register to $F3.
0550   01A6 04                  INC     B               ;; increment the line count
0551   01A7 2B                  DEC     HL              ;; decrement screen address.
0552   01A8 FD 35 23            DEC     (IY+$23)        ;; decrement RESULT_hi the blank line counter.
0553   01AB 18 8F               JR      L013C           ;; back to display and read
0554   01AD             
0555   01AD             
0556   01AD             ; ---
0557   01AD             
0558   01AD             ;; DISP-2
0559   01AD FD 4E 23    L01AD:  LD      C,(IY+$23)      ;; load C the col count from RESULT_hi.
0560   01B0             
0561   01B0             ;# This is the entry point used by the flicker free games
0562   01B0             
0563   01B0 C3 5B 10    L01B0:  JP    DISPLAY_ROUTINE   ;# jump to the new routine
0564   01B3                   
0565   01B3             ;##############
0566   01B3             ; SPACE
0567   01B3             
0568   01B3 FF FF FF            DEFB    $FF, $FF, $FF   ;# three spare bytes
0569   01B6             
0570   01B6             ; --------------------------
0571   01B6             ; THE 'SAVE' COMMAND ROUTINE
0572   01B6             ; --------------------------
0573   01B6             ; There isn't a program name involved.
0574   01B6             ; The routine saves the System Variables, Program Area and BASIC Variables.
0575   01B6             ; One of the five System commands that cannot be used from within a program.
0576   01B6             
0577   01B6             ;; SAVE
0578   01B6 D1          L01B6:  POP     DE              ; discard return address.
0579   01B7 11 CB 12            LD      DE,$12CB        ; timing value of 5 seconds for leader.
0580   01BA             
0581   01BA             ;; SAVE-1
0582   01BA 3E 7F       L01BA:  LD      A,$7F           ; read port $7FFE.
0583   01BC DB FE               IN      A,($FE)         ; all 16 bits are placed on address bus.
0584   01BE 1F                  RRA                     ; test for the space key.
0585   01BF 30 42               JR      NC,L0203        ; forward, if pressed, indirectly to MAIN-EXEC.
0586   01C1             
0587   01C1             ;; SAVE-2
0588   01C1 10 FE       L01C1:  DJNZ    L01C1           ; delay self-looping to SAVE-2
0589   01C3             
0590   01C3 1B                  DEC     DE              ; decrement
0591   01C4 7A                  LD      A,D             ; and test
0592   01C5 B3                  OR      E               ; for zero.
0593   01C6 20 F2               JR      NZ,L01BA        ; back if not zero to outer delay loop SAVE-1.
0594   01C8             
0595   01C8 21 00 40            LD      HL,$4000        ; commence saving at start of RAM.
0596   01CB             
0597   01CB             ;; SAVE-3
0598   01CB 11 08 F8    L01CB:  LD      DE,$F808        ; register E counts the 8 bits.
0599   01CE                                             ; $F8 is first delay.
0600   01CE             
0601   01CE             ;; EACH-BIT
0602   01CE CB 06       L01CE:  RLC     (HL)            ; spin the actual program byte.
0603   01D0 9F                  SBC     A,A             ; $FF or $00.
0604   01D1 E6 05               AND     $05             ; $05 or $00.
0605   01D3 C6 04               ADD     A,$04           ; $09 or $04.
0606   01D5 4F                  LD      C,A             ; timer to C.
0607   01D6                                             ; a set bit has a pulse longer than
0608   01D6                                             ; an unset bit.
0609   01D6             
0610   01D6             ;; SAVE-4
0611   01D6 D3 FF       L01D6:  OUT     ($FF),A         ; pulses
0612   01D8             
0613   01D8 06 24               LD      B,$24           ; delay counter.
0614   01DA             
0615   01DA             ;; SAVE-5
0616   01DA 10 FE       L01DA:  DJNZ    L01DA           ; self loop for delay to SAVE-5
0617   01DC             
0618   01DC 3E 7F               LD      A,$7F           ; read the space row and hold for later.
0619   01DE DB FE               IN      A,($FE)         ; also ...
0620   01E0             
0621   01E0 06 23               LD      B,$23           ; another delay counter.
0622   01E2             
0623   01E2             ;; SAVE-6
0624   01E2 10 FE       L01E2:  DJNZ    L01E2           ; self loop for delay2 to SAVE-6
0625   01E4             
0626   01E4 0D                  DEC     C               ; decrement pulse counter
0627   01E5 20 EF               JR      NZ,L01D6        ; back while more to SAVE-4.
0628   01E7             
0629   01E7 42                  LD      B,D             ; a terminating delay - D is zero (256).
0630   01E8             
0631   01E8             ;; SAVE-7
0632   01E8 00          L01E8:  NOP                     ; 4 T-states.
0633   01E9 10 FD               DJNZ    L01E8           ; execute the NOP 256 times.
0634   01EB             
0635   01EB 16 FE               LD      D,$FE           ; subsequent timing value
0636   01ED 1D                  DEC     E               ; decrement the 8 counter.
0637   01EE 20 DE               JR      NZ,L01CE        ; back if more to EACH-BIT.
0638   01F0             
0639   01F0 1F                  RRA                     ; test for space key pressed at last test.
0640   01F1 30 10               JR      NC,L0203        ; forward, if so, indirectly to MAIN-EXEC.
0641   01F3             
0642   01F3 CD F8 01            CALL    L01F8           ; routine TEST-END does not return if at 
0643   01F6                                             ; the end.                                >>
0644   01F6             
0645   01F6 18 D3               JR      L01CB           ; else back to do another byte.
0646   01F8             
0647   01F8             ; ---
0648   01F8             
0649   01F8             ; This subroutine is used by both the SAVE and LOAD command routines 
0650   01F8             ; to check when the required area has been completed and to then make an exit 
0651   01F8             ; from the called loop.
0652   01F8             ; Note. that for the LOAD command the value of E_LINE is not that at the outset
0653   01F8             ; of the LOAD command but at the start of the command that saved the section.
0654   01F8             ; The first bytes to be loaded are the System Variables and E_LINE will be the
0655   01F8             ; eleventh and twelfth bytes to be loaded. The low byte is read in before the 
0656   01F8             ; high byte so after the low byte is read in, E_LINE is in an indeterminate
0657   01F8             ; state. Hence E_LINE_hi is incremented at the outset to avoid a premature
0658   01F8             ; end to loading. 
0659   01F8             
0660   01F8             ;; TEST-END
0661   01F8 23          L01F8:  INC     HL              ; increase pointer.
0662   01F9 EB                  EX      DE,HL           ;
0663   01FA 2A 0A 40            LD      HL,($400A)      ; load HL with E_LINE - the location following
0664   01FD                                             ; the variables end-marker.
0665   01FD 37                  SCF                     ; force a carry when equal.
0666   01FE ED 52               SBC     HL,DE           ; trial subtraction.
0667   0200 EB                  EX      DE,HL           ; restore pointer.
0668   0201 D0                  RET     NC              ; return if more bytes to do.
0669   0202             
0670   0202 E1                  POP     HL              ; else drop the return address.
0671   0203             
0672   0203             ;; JUMP-EXEC
0673   0203 C3 83 02    L0203:  JP      L0283           ; JUMP forward to MAIN-EXEC.
0674   0206             
0675   0206             ; Note. the above jump could be replaced by a relative jump saving one 
0676   0206             ; instruction byte.  A few other direct jumps to this destination could be 
0677   0206             ; replaced with a series of relative jumps as has been done elsewhere.
0678   0206             
0679   0206             ; --------------------------
0680   0206             ; THE 'LOAD' COMMAND ROUTINE
0681   0206             ; --------------------------
0682   0206             ; A System Command to load a program from tape.
0683   0206             
0684   0206             ;; LOAD
0685   0206 D1          L0206:  POP     DE              ; discard the return address.
0686   0207             
0687   0207             ;; LOAD-1
0688   0207 11 12 57    L0207:  LD      DE,$5712        ; set a timing constant.
0689   020A             
0690   020A             ;; LOAD-2
0691   020A 3E 7F       L020A:  LD      A,$7F           ; read from port $7FFE.
0692   020C DB FE               IN      A,($FE)         ; the keyboard row with space.
0693   020E 1F                  RRA                     ; test the outer key.
0694   020F 30 F2               JR      NC,L0203        ; back, if pressed, indirectly to MAIN-EXEC
0695   0211             
0696   0211 17                  RLA                     ; cancel the above RRA.
0697   0212 17                  RLA                     ; now do an RLA to read tape signal - bit 7.
0698   0213             
0699   0213 38 F2               JR      C,L0207         ; back without signal to outer loop LOAD-1.
0700   0215             
0701   0215 1B                  DEC     DE              ; decrement timer
0702   0216 7A                  LD      A,D             ; and test 
0703   0217 B3                  OR      E               ; for zero.
0704   0218 20 F0               JR      NZ,L020A        ; back if not to inner loop LOAD-2.
0705   021A             
0706   021A FD 34 0B            INC     (IY+$0B)        ; increment E_LINE_hi to prevent premature
0707   021D                                             ; end after loading E_LINE-lo.
0708   021D                                             ; see TEST-END.
0709   021D             
0710   021D 21 00 40            LD      HL,$4000        ; start of RAM - system variables to be 
0711   0220                                             ; overwritten.
0712   0220             
0713   0220             ;; LOAD-3
0714   0220 1E 08       L0220:  LD      E,$08           ; the bit counter for each byte.
0715   0222             
0716   0222             ;; LOAD-4
0717   0222 3E 7F       L0222:  LD      A,$7F           ; test the keyboard
0718   0224 DB FE               IN      A,($FE)         ; reading the 
0719   0226 1F                  RRA                     ; space key.
0720   0227 30 24               JR      NC,L024D        ; forward, if space pressed, to LD-ABORT.
0721   0229             
0722   0229 17                  RLA                     ; restore to original state.
0723   022A 17                  RLA                     ; now test the tape bit.
0724   022B 30 F5               JR      NC,L0222        ; back if ???? to LOAD-4
0725   022D             
0726   022D             ; start building up a byte.
0727   022D             
0728   022D 0E 94               LD      C,$94           ; set timing value. The exit value of this
0729   022F                                             ; register determines if a bit was set or unset.
0730   022F             
0731   022F             ;; LOAD-5
0732   022F 06 1A       L022F:  LD      B,$1A           ; inner timer
0733   0231             
0734   0231             ;; LOAD-6
0735   0231 0D          L0231:  DEC     C               ; decrement counter.
0736   0232 DB FE               IN      A,($FE)         ; read the tape port.
0737   0234 17                  RLA                     ; test the tape bit.
0738   0235             
0739   0235 CB 79               BIT     7,C             ; test if counter above 127. A set bit.
0740   0237 79                  LD      A,C             ; save in A.
0741   0238             
0742   0238 38 F5               JR      C,L022F         ; back while bit set to LOAD-5
0743   023A             
0744   023A 10 F5               DJNZ    L0231           ; decrement B counter and loop while not
0745   023C                                             ; zero to LOAD-6.
0746   023C                                             ; Note. this instruction has no effect on any 
0747   023C                                             ; flags.
0748   023C             
0749   023C 20 04               JR      NZ,L0242        ; forward if C was > $7F (with NC) to LOAD-7
0750   023E             
0751   023E FE 56               CP      $56             ; compare copy of counter to $56
0752   0240 30 E0               JR      NC,L0222        ; back if $56-$7F to LOAD-4
0753   0242             
0754   0242             ;; LOAD-7
0755   0242 3F          L0242:  CCF                     ; else clear if from above but set carry if 
0756   0243                                             ; branching to here.
0757   0243 CB 16               RL      (HL)            ; rotate the bit into position.
0758   0245             
0759   0245 1D                  DEC     E               ; decrement the eight counter
0760   0246 20 DA               JR      NZ,L0222        ; loop back for entire byte.
0761   0248             
0762   0248 CD F8 01            CALL    L01F8           ; routine TEST-END quits early at end.
0763   024B 18 D3               JR      L0220           ; and back to load another byte.
0764   024D             
0765   024D             ; ---------------------------
0766   024D             ; THE 'LOAD ABORT' EXIT ROUTE
0767   024D             ; ---------------------------
0768   024D             ; If the LOAD command has started to load data then a reset is performed.
0769   024D             ; If it's still waiting for the leader then rejoin the main execution loop
0770   024D             ; after restoring the location of the Edit Line to its correct value.
0771   024D             
0772   024D             ;; LD-ABORT
0773   024D 15          L024D:  DEC     D               ; ??
0774   024E F2 00 00            JP      P,L0000         ; a reset
0775   0251             
0776   0251 FD 35 0B            DEC     (IY+$0B)        ; restore E_LINE_hi to a valid state.
0777   0254 18 AD               JR      L0203           ; indirect jump to MAIN-EXEC.
0778   0256             
0779   0256             
0780   0256             ; --------------------------
0781   0256             ; THE 'LIST' COMMAND ROUTINE
0782   0256             ; --------------------------
0783   0256             ; Another System command that can't be used from within a program.
0784   0256             
0785   0256             ;; LIST
0786   0256 CB B8       L0256:  RES     7,B             ; start by making the high byte,
0787   0258                                             ; of an invalid, user-supplied,
0788   0258 CB B0               RES     6,B             ; line number within range $00-$3F.
0789   025A             
0790   025A             ; this invisible mending is inappropriate and it is preferable to tell the
0791   025A             ; user of any typos. e.g. LIST 40000 is silently changed to LIST 7232
0792   025A             ; when the user probably meant to type LIST 4000. However space is tight.
0793   025A             
0794   025A ED 43 06 40         LD      ($4006),BC      ; set E-PPC from line number.
0795   025E C1                  POP     BC              ; discard return address.
0796   025F 18 22               JR      L0283           ; forward to MAIN-EXEC which produces an
0797   0261                                             ; 'automatic listing'.
0798   0261             
0799   0261             ; ----------------------------
0800   0261             ; THE 'INITIALIZATION' ROUTINE
0801   0261             ; ----------------------------
0802   0261             ; A holds $3F, HL holds $7FFF.
0803   0261             
0804   0261             ;; RAM-FILL
0805   0261 36 01       L0261:  LD      (HL),$01        ; fill location with 1 (null).
0806   0263 2B                  DEC     HL              ; decrement address.
0807   0264 BC                  CP      H               ; compare address high byte to $3F.
0808   0265 20 FA               JR      NZ,L0261        ; back, while higher, to RAM-FILL.
0809   0267             
0810   0267             ;; RAM-READ
0811   0267 23          L0267:  INC     HL              ; address the next higher location.
0812   0268 35                  DEC     (HL)            ; decrement to zero.
0813   0269 28 FC               JR      Z,L0267         ; back, if successful to RAM-READ.
0814   026B             
0815   026B             ; else we have encountered first unpopulated RAM location.
0816   026B             
0817   026B F9                  LD      SP,HL           ; initialize stack pointer at end.
0818   026C F5                  PUSH    AF              ; place gosub end-marker $3F??
0819   026D             
0820   026D 3E 0E               LD      A,$0E           ; set the I register to $0E to tell
0821   026F ED 47               LD      I,A             ; the video hardware where to find
0822   0271                                             ; the character set ($0E00).
0823   0271             
0824   0271 ED 56               IM      1               ; select Interrupt Mode 1.
0825   0273             
0826   0273 FD 21 00 40         LD      IY,$4000        ; set IY to the start of the forty system
0827   0277                                             ; variables.
0828   0277             
0829   0277             ; -----------------------------------------------------------------------------
0830   0277             ;
0831   0277             ; ---------------------
0832   0277             ; THE 'ZX80 MEMORY MAP'
0833   0277             ; ---------------------
0834   0277             ;
0835   0277             ; There are forty ($28) system variables followed by Program area
0836   0277             ; These are located at the start of RAM.
0837   0277             ;
0838   0277             ; +---------+---------+-----------+---+-----------+-----------+-------+-------+
0839   0277             ; |         |         |           |   |           |           |       |       |
0840   0277             ; | SYSVARS | Program | Variables |80h| WKG Space | Disp File | Spare | Stack |
0841   0277             ; |         |         |           |   |           |           |       |       |
0842   0277             ; +---------+---------+-----------+---+-----------+-----------+-------+-------+
0843   0277             ;           ^         ^               ^           ^     ^     ^       ^
0844   0277             ;         $4024      VARS            E_LINE    D_FILE       DF_END   SP
0845   0277             ;                                                     DF_EA
0846   0277             ;
0847   0277             ; -----------------------------------------------------------------------------
0848   0277             
0849   0277 21 28 40            LD      HL,$4028        ; set to location after sysvars.
0850   027A 22 08 40            LD      ($4008),HL      ; set the system variable VARS.
0851   027D 36 80               LD      (HL),$80        ; and insert variables end-marker.
0852   027F             
0853   027F 23                  INC     HL              ; address the next location.
0854   0280                     ;LD      ($400A),HL      ; set the system variable E_LINE.
0855   0280                                             ; and continue...
0856   0280 C3 38 10            JP      INIT_BANNER
0857   0283             
0858   0283             ; -------------------------
0859   0283             ; THE 'MAIN EXECUTION' LOOP
0860   0283             ; -------------------------
0861   0283             ; This is the MAIN EXECUTION LOOP that handles the creation and interpretation
0862   0283             ; of user input. The various 'subroutines'  from this main loop including those
0863   0283             ; launched from the Editing Keys Table are really just branches which all
0864   0283             ; ultimately jump back to here. Although service routines make use of the
0865   0283             ; machine stack, the stack is generally empty and only has one return address
0866   0283             ; on it during command execution.
0867   0283             
0868   0283             ;; MAIN-EXEC
0869   0283 2A 0A 40    L0283:  LD      HL,($400A)      ; fetch E-LINE
0870   0286 36 B0               LD      (HL),$B0        ; insert the character inverse 'K'.
0871   0288             
0872   0288 23                  INC     HL              ; address the next location.
0873   0289 36 76               LD      (HL),$76        ; insert a newline.
0874   028B             
0875   028B 23                  INC     HL              ; address the next location.
0876   028C 22 0C 40            LD      ($400C),HL      ; set D-FILE to start of dynamic display file.
0877   028F FD 36 12 02         LD      (IY+$12),$02    ; set DF-SZ to 2 lines.
0878   0293             
0879   0293             ; ->
0880   0293             
0881   0293             ;; AUTO-LIST
0882   0293 CD 47 07    L0293:  CALL    L0747           ; routine CLS sets a minimal display and
0883   0296                                             ; initializes screen values in registers.
0884   0296                                              
0885   0296 EB          L0296:  EX      DE,HL           ;
0886   0297 78                  LD      A,B             ; load line value, 23, to A.
0887   0298 FD 96 12            SUB     (IY+$12)        ; subtract DF-SZ of lower screen.
0888   029B 38 5A               JR      C,L02F7         ; forward if the lower screen is 24 lines 
0889   029D                                             ; to ED-COPY.
0890   029D             
0891   029D 3C                  INC     A               ; allow for a blank line.
0892   029E 47                  LD      B,A             ; place in B line
0893   029F             
0894   029F D9                  EXX                     ; switch to preserve line/column values.
0895   02A0             
0896   02A0 2A 06 40            LD      HL,($4006)      ; fetch E_PPC the current line number.
0897   02A3 ED 5B 13 40         LD      DE,($4013)      ; fetch the top line on screen from S_TOP.
0898   02A7 ED 52               SBC     HL,DE           ; subtract the two BASIC line numbers
0899   02A9 EB                  EX      DE,HL           ; and bring S_TOP to HL.
0900   02AA 30 04               JR      NC,L02B0        ; forward if current line >= top line to LIST-1.
0901   02AC             
0902   02AC 19                  ADD     HL,DE           ; else reform the E_PPC value 
0903   02AD 22 13 40            LD      ($4013),HL      ; and make S_TOP the same.
0904   02B0             
0905   02B0             ;; LIST-1
0906   02B0 CD 0A 06    L02B0:  CALL    L060A           ; routine LINE-ADDR gets the address of the
0907   02B3                                             ; BASIC line in HL.
0908   02B3 1E 00               LD      E,$00           ; signal current line yet to be printed
0909   02B5             
0910   02B5             ;; LIST-ALL
0911   02B5 CD F7 04    L02B5:  CALL    L04F7           ; routine OUT-LINE
0912   02B8             
0913   02B8 38 FB               JR      C,L02B5         ; loop until upper screen is full to LIST-ALL.
0914   02BA             
0915   02BA 1D                  DEC     E               ; test if current line has appeared.
0916   02BB 20 33               JR      NZ,L02F0        ; forward to LIST-DONE if current line
0917   02BD                                             ; has appeared.
0918   02BD             
0919   02BD             ; else the current line has yet to appear.
0920   02BD             
0921   02BD E5                  PUSH    HL              ; else save HL ( )
0922   02BE 2A 06 40            LD      HL,($4006)      ; fetch E_PPC - the current line.
0923   02C1 CD 0A 06            CALL    L060A           ; routine LINE-ADDR in DE
0924   02C4 E1                  POP     HL              ; restore HL
0925   02C5             
0926   02C5 A7                  AND     A               ; prepare to subtract.
0927   02C6 ED 52               SBC     HL,DE           ; subtract setting carry.
0928   02C8             
0929   02C8 21 13 40            LD      HL,$4013        ; address system variable S_TOP
0930   02CB 30 0B               JR      NC,L02D8        ; forward if E_PPC precedes to LN-FETCH
0931   02CD             
0932   02CD EB                  EX      DE,HL           ; else swap pointers.
0933   02CE             
0934   02CE 7E                  LD      A,(HL)          ; pick up high byte.
0935   02CF 23                  INC     HL              ; address low byte.
0936   02D0 ED A0               LDI                     ; copy low byte to S_TOP_lo.
0937   02D2 12                  LD      (DE),A          ; insert the high byte.
0938   02D3             
0939   02D3             ;; AUTO-L-J
0940   02D3 18 BE       L02D3:  JR      L0293           ; back to AUTO-LIST.
0941   02D5             
0942   02D5             ; ------------------------------------
0943   02D5             ; THE 'CURSOR DOWN EDITING' SUBROUTINE
0944   02D5             ; ------------------------------------
0945   02D5             
0946   02D5             
0947   02D5             ;; ED-DOWN
0948   02D5 21 06 40    L02D5:  LD      HL,$4006        ; address system variable E_PPC
0949   02D8                                             ; and continue...
0950   02D8             
0951   02D8             ; ----------------------
0952   02D8             ; THE 'LN-FETCH' SECTION
0953   02D8             ; ----------------------
0954   02D8             
0955   02D8             ;; LN-FETCH
0956   02D8 5E          L02D8:  LD      E,(HL)          ;
0957   02D9 23                  INC     HL              ;
0958   02DA 56                  LD      D,(HL)          ;
0959   02DB E5                  PUSH    HL              ;
0960   02DC EB                  EX      DE,HL           ;
0961   02DD 23                  INC     HL              ; increment as starting point
0962   02DE CD 0A 06            CALL    L060A           ; routine LINE-ADDR
0963   02E1 CD C2 03            CALL    L03C2           ; LINE-NO
0964   02E4 E1                  POP     HL              ; restore hi pointer.
0965   02E5             
0966   02E5             ; ----------------------
0967   02E5             ; THE 'LN-STORE' SECTION
0968   02E5             ; ----------------------
0969   02E5             ; On entry, HL holds E_PPC_hi.
0970   02E5             
0971   02E5             ;; LN-STORE
0972   02E5 FD CB 19 6E L02E5:  BIT     5,(IY+$19)      ; test FLAGX.
0973   02E9 20 0C               JR      NZ,L02F7        ; forward if INPUT to ED-COPY.
0974   02EB             
0975   02EB 72                  LD      (HL),D          ; insert high byte
0976   02EC 2B                  DEC     HL              ; DECrement
0977   02ED 73                  LD      (HL),E          ; insert low byte
0978   02EE             
0979   02EE             ;
0980   02EE             
0981   02EE 18 A3               JR      L0293           ; back to AUTO-LIST
0982   02F0             
0983   02F0             ; --------------------------
0984   02F0             ; THE 'LIST-DONE' SUBROUTINE
0985   02F0             ; --------------------------
0986   02F0             ; When the listing is complete then the rest of the upper display is blanked,
0987   02F0             ; to erase what may have been printed during the interim, the display file
0988   02F0             ; cursor is updated and the current line is printed in the lower screen.
0989   02F0             
0990   02F0             ;; LIST-DONE
0991   02F0 CD C2 05    L02F0:  CALL    L05C2           ; CL-EOD clear to end of upper display.
0992   02F3             
0993   02F3 ED 53 0E 40        LD      ($400E),DE       ; set lower screen position DF_EA
0994   02F7                                             ; to end
0995   02F7                                             ; and continue...
0996   02F7             
0997   02F7             ; -------------------------------------
0998   02F7             ; THE 'LOWER SCREEN COPYING' SUBROUTINE
0999   02F7             ; -------------------------------------
1000   02F7             ; This is called.
1001   02F7             ; When the line in the editing area is to be printed in the lower screen.
1002   02F7             ; It is by repeatedly printing the line when any key is pressed that the
1003   02F7             ; cursor for instance appears to move.
1004   02F7             ; It is called in a similar fashion to animate the input line.
1005   02F7             
1006   02F7             ;; ED-COPY
1007   02F7 FD 36 01 01 L02F7:  LD      (IY+$01),$01    ; set FLAGS leading space allowed
1008   02FB 2A 0A 40            LD      HL,($400A)      ; E_LINE
1009   02FE             
1010   02FE CD BE 07            CALL    L07BE           ; routine MAIN-G checks syntax of line.
1011   0301             
1012   0301 ED 5B 0E 40         LD      DE,($400E)      ; fetch start of lower screen from DF_EA
1013   0305 FD 46 12            LD      B,(IY+$12)      ; fetch lines in lower screen from DF_SZ
1014   0308 0E 01               LD      C,$01           ; set column to 1
1015   030A                                             ; to print an initial newline for gap?
1016   030A D9                  EXX                     ;
1017   030B             
1018   030B 2A 0A 40            LD      HL,($400A)      ; fetch start of edit line from E_LINE
1019   030E             
1020   030E CD 12 05            CALL    L0512           ; routine OUT-LINE-2 prints characters starting
1021   0311                                             ; with the individual digits of line number.
1022   0311             
1023   0311 38 0A               JR      C,L031D         ; forward with success to LINE-DONE
1024   0313             
1025   0313             ; else there wasn't enough room in lower screen for line.
1026   0313             
1027   0313 21 12 40            LD      HL,$4012        ; address DF_SZ the Display Size for
1028   0316                                             ; the lower screen.
1029   0316 34                  INC     (HL)            ; increment it.
1030   0317 3E 18               LD      A,$18           ; load A with 24 decimal.
1031   0319 BE                  CP      (HL)            ; compare to DF-SZ
1032   031A             
1033   031A 30 B7               JR      NC,L02D3        ; indirect jump back to AUTO-LIST
1034   031C                                             ; if no greater than 24 lines.
1035   031C             
1036   031C 77                  LD      (HL),A          ; else limit to 24 lines.
1037   031D             
1038   031D             ;; LINE-DONE
1039   031D CD C2 05    L031D:  CALL    L05C2           ; routine CL-EOD clears to the end of lower
1040   0320                                             ; screen
1041   0320             
1042   0320 CD 3F 01            CALL    L013F           ; routine KEYBOARD gets key values in BC.
1043   0323             
1044   0323             ; now decode the value
1045   0323             
1046   0323 CB 28               SRA     B               ; sets carry if unshifted (bit 7 remains set)
1047   0325 9F                  SBC     A,A             ; $FF unshifted, else $00
1048   0326 F6 26               OR      $26             ; $FF unshifted, else $26
1049   0328 2E 05               LD      L,$05           ; there are five keys in each row.
1050   032A 95                  SUB     L               ; set the starting point
1051   032B             
1052   032B             ;; KEY-LINE
1053   032B 85          L032B:  ADD     A,L             ; add value 5 (or 1)
1054   032C 37                  SCF                     ; carry will go to bit 7
1055   032D CB 19               RR      C               ; test C (which has 1 unset bit identifying row)
1056   032F 38 FA               JR      C,L032B         ; back if carry to KEY-LINE
1057   0331             
1058   0331             ; if only one key pressed C should now be $FF.
1059   0331             
1060   0331 0C                  INC     C               ; test for $FF
1061   0332 20 C3               JR      NZ,L02F7        ; back if multiple keys to ED-COPY
1062   0334             
1063   0334             ; the high byte of the key value identifies the column - again only one bit is
1064   0334             ; now reset.
1065   0334             
1066   0334 48                  LD      C,B             ; transfer to B
1067   0335 2D                  DEC     L               ; test if this is first time through
1068   0336 2E 01               LD      L,$01           ; reduce increment from five to one.
1069   0338 20 F1               JR      NZ,L032B        ; back if L was five to KEY-LINE
1070   033A             
1071   033A             ; The accumulator now holds a key value 1-78 decimal.
1072   033A             
1073   033A 21 6B 00            LD      HL,L006C - 1    ; location before the MAIN-KEYS table ($006B)
1074   033D                                             ; the index value is 1 - 78.
1075   033D             
1076   033D 5F                  LD      E,A             ; code to E  (D is zero from keyboard)
1077   033E 19                  ADD     HL,DE           ; index into the table.
1078   033F 7E                  LD      A,(HL)          ; pick up the letter/number/.
1079   0340             
1080   0340 FD CB 01 56         BIT     2,(IY+$01)      ; test FLAGS K-MODE ?
1081   0344 28 07               JR      Z,L034D         ; skip forward if not
1082   0346             
1083   0346 C6 C0               ADD     A,$C0           ; add 192 decimal
1084   0348                                             ; e.g. 'A' 38d + 192 = 230 (LIST)
1085   0348             
1086   0348 FE E6               CP      $E6             ; compare to 'LIST'
1087   034A 30 01               JR      NC,L034D        ; skip forward if command tokens to EDC-2.
1088   034C             
1089   034C 7E                  LD      A,(HL)          ; else load A from HL again
1090   034D                                             ; (numbers and symbols)
1091   034D             
1092   034D             ;; EDC-2
1093   034D FE C0       L034D:  CP      $C0             ; set the overflow flag for editing key $70-$77
1094   034F             
1095   034F EA 5E 03            JP      PE,L035E        ; forward with range $40 - $7F to ED-KEYS
1096   0352             
1097   0352 2A 04 40            LD      HL,($4004)      ; else fetch keyboard cursor from P_PTR
1098   0355 01 01 00            LD      BC,$0001        ; one space required.
1099   0358 CD D5 05            CALL    L05D5           ; routine MAKE-ROOM makes room at cursor.
1100   035B                                             ; note HL - first, DE - LAST
1101   035B             
1102   035B 12                  LD      (DE),A          ; and insert the keyboard character.
1103   035C             
1104   035C             ;; EDC-JR
1105   035C 18 99       L035C:  JR      L02F7           ; loop back to ED-COPY
1106   035E             
1107   035E             ; -----------------------------
1108   035E             ; THE 'EDITING KEYS' SUBROUTINE
1109   035E             ; -----------------------------
1110   035E             
1111   035E             ;; ED-KEYS
1112   035E 5F          L035E:  LD      E,A             ; transfer code to E.
1113   035F                                             ; (D holds zero from 'keyboard')
1114   035F             
1115   035F 21 92 02            LD      HL,L0372-$70-$70; theoretical base of ED-K-TAB  $0292
1116   0362             
1117   0362 19                  ADD     HL,DE           ; index twice
1118   0363 19                  ADD     HL,DE           ; as a two-byte address is required.
1119   0364             
1120   0364 4E                  LD      C,(HL)          ; low byte of routine.
1121   0365 23                  INC     HL
1122   0366 46                  LD      B,(HL)          ; high byte of routine.
1123   0367 C5                  PUSH    BC              ; push routine address to stack.
1124   0368 2A 04 40            LD      HL,($4004)      ; set HL to cursor from P_PTR
1125   036B C9                  RET                     ; jump to routine.
1126   036C             
1127   036C                                             ; Note the stack is empty.
1128   036C             
1129   036C             ; ---------------------------------------------
1130   036C             ; THE EDITING 'DELETE ONE CHARACTER' SUBROUTINE
1131   036C             ; ---------------------------------------------
1132   036C             
1133   036C             ;; ED-DEL-1
1134   036C 01 01 00    L036C:  LD      BC,$0001        ; one character
1135   036F C3 66 06            JP      L0666           ; routine RECLAIM-2
1136   0372             
1137   0372             ; ------------------------
1138   0372             ; THE 'EDITING KEYS' TABLE
1139   0372             ; ------------------------
1140   0372             
1141   0372             ;; ED-K-TAB
1142   0372 A9 03       L0372:  DEFW    L03A9           ; ED-UP                 $70
1143   0374 D5 02               DEFW    L02D5           ; ED-DOWN               $71
1144   0376 82 03               DEFW    L0382           ; ED-LEFT               $72
1145   0378 87 03               DEFW    L0387           ; ED-RIGHT              $73
1146   037A B9 03               DEFW    L03B9           ; ED-HOME               $74
1147   037C CB 03               DEFW    L03CB           ; ED-EDIT               $75
1148   037E 08 04               DEFW    L0408           ; ED-ENTER              $76
1149   0380 95 03               DEFW    L0395           ; ED-DELETE             $77
1150   0382             
1151   0382             ; ------------------------------------
1152   0382             ; THE 'CURSOR LEFT EDITING' SUBROUTINE
1153   0382             ; ------------------------------------
1154   0382             
1155   0382             ;; ED-LEFT
1156   0382 CD 9E 03    L0382:  CALL    L039E           ; routine ED-EDGE checks that cursor
1157   0385                                             ; not at start without disturbing HL.
1158   0385                                             ; quits early if not possible.   >>
1159   0385             
1160   0385 2B                  DEC     HL              ; move left.
1161   0386 2B                  DEC     HL              ; and again for luck.
1162   0387                                             ; ...
1163   0387             
1164   0387             ; -------------------------------------
1165   0387             ; THE 'CURSOR RIGHT EDITING' SUBROUTINE
1166   0387             ; -------------------------------------
1167   0387             
1168   0387             ;; ED-RIGHT
1169   0387 23          L0387:  INC     HL              ; move right
1170   0388             
1171   0388 7E                  LD      A,(HL)          ; pick up the character.
1172   0389 FE 76               CP      $76             ; is it newline ?
1173   038B             
1174   038B 28 1A               JR      Z,L03A7         ; triple jump back to ED-COPY if so.
1175   038D             
1176   038D 36 B0               LD      (HL),$B0        ; else place inverse cursor there.
1177   038F 2A 04 40            LD      HL,($4004)      ; fetch P_PTR
1178   0392 77                  LD      (HL),A          ; and put character there
1179   0393 18 C7               JR      L035C           ; double jump back to ED-COPY
1180   0395             
1181   0395             ; -------------------------------
1182   0395             ; THE 'DELETE EDITING' SUBROUTINE
1183   0395             ; -------------------------------
1184   0395             
1185   0395             ;; ED-DELETE
1186   0395 CD 9E 03    L0395:  CALL    L039E           ; routine ED-EDGE will loop back to
1187   0398                                             ; ED-COPY if no deletion possible >>
1188   0398             
1189   0398 2B                  DEC     HL              ; decrement position
1190   0399 CD 6C 03            CALL    L036C           ; routine ED-DEL-1
1191   039C 18 BE               JR      L035C           ; back to ED-COPY
1192   039E             
1193   039E             ; ------------------------
1194   039E             ; THE 'ED-EDGE' SUBROUTINE
1195   039E             ; ------------------------
1196   039E             
1197   039E             ;; ED-EDGE
1198   039E ED 5B 0A 40 L039E:  LD      DE,($400A)      ; fetch E_LINE - start of edit line.
1199   03A2 1A                  LD      A,(DE)          ; pick up first character.
1200   03A3 FE B0               CP      $B0             ; test for inverse 'K'
1201   03A5 C0                  RET     NZ              ; return if cursor not at start.
1202   03A6             
1203   03A6 D1                  POP     DE              ; else drop the return address.
1204   03A7             
1205   03A7             ;; EDC-JR2
1206   03A7 18 B3       L03A7:  JR      L035C           ; and back to ED-COPY
1207   03A9             
1208   03A9             ; ----------------------------------
1209   03A9             ; THE 'CURSOR UP EDITING' SUBROUTINE
1210   03A9             ; ----------------------------------
1211   03A9             
1212   03A9             ;; ED-UP
1213   03A9 2A 06 40    L03A9:  LD      HL,($4006)      ; E_PPC
1214   03AC CD 0A 06            CALL    L060A           ; routine LINE-ADDR
1215   03AF EB                  EX      DE,HL
1216   03B0 CD C2 03            CALL    L03C2           ; LINE-NO
1217   03B3             
1218   03B3             ;; ED-LINE
1219   03B3 21 07 40    L03B3:  LD      HL,$4007        ; E_PPC_hi
1220   03B6 C3 E5 02            JP      L02E5           ; to LN-STORE to store new line
1221   03B9                                             ; and produce an automatic listing.
1222   03B9             
1223   03B9             ; ------------------------
1224   03B9             ; THE 'ED-HOME' SUBROUTINE
1225   03B9             ; ------------------------
1226   03B9             ; ED-HOME (SHIFT 9) starts the listing at the first line.
1227   03B9             ; dropped in later ZX computers.
1228   03B9             
1229   03B9             ;; ED-HOME
1230   03B9 11 00 00    L03B9:  LD      DE,$0000        ; start at 'line zero'
1231   03BC 18 F5               JR      L03B3           ; back to ED-LINE above.
1232   03BE             
1233   03BE             ; --------------------------------------
1234   03BE             ; THE 'COLLECT A LINE NUMBER' SUBROUTINE
1235   03BE             ; --------------------------------------
1236   03BE             
1237   03BE             ;; LINE-NO-A
1238   03BE EB          L03BE:  EX      DE,HL           ; bring previous line to HL
1239   03BF                                             ; and set DE in case we loop back a second time.
1240   03BF 11 BA 03            LD      DE,L03B9 + 1    ; address of $00 $00 within the subroutine
1241   03C2                                             ; above.
1242   03C2             
1243   03C2             ; -> The Entry Point.
1244   03C2             
1245   03C2             ;; LINE-NO
1246   03C2 7E          L03C2:  LD      A,(HL)          ; fetch hi byte of line number
1247   03C3 E6 C0               AND     $C0             ; test against $3F
1248   03C5 20 F7               JR      NZ,L03BE        ; back to LINE-NO-A if at end.
1249   03C7             
1250   03C7 56                  LD      D,(HL)          ; else high byte to D
1251   03C8 23                  INC     HL              ; increase pointer
1252   03C9 5E                  LD      E,(HL)          ; low byte in E.
1253   03CA C9                  RET                     ; return.
1254   03CB                                             ; with next line number in DE
1255   03CB             
1256   03CB             ; -------------------------
1257   03CB             ; THE 'EDIT KEY' SUBROUTINE
1258   03CB             ; -------------------------
1259   03CB             ; Pressing the EDIT key causes the current line to be copied to the
1260   03CB             ; edit line. The two-byte line number is converted into 4 characters
1261   03CB             ; using leading spaces if the line is less than 1000. Next the 'K'
1262   03CB             ; cursor is inserted and the rest of the characters are copied verbatim
1263   03CB             ; into the edit buffer, keywords remaining as single character tokens.
1264   03CB             
1265   03CB             ;; ED-EDIT
1266   03CB 0E 00       L03CB:  LD      C,$00           ; set column to zero to inhibit a line feed
1267   03CD                                             ; while 'sprinting' to the edit line.
1268   03CD                                             ; see PRINT-A-2.
1269   03CD ED 5B 0A 40         LD      DE,($400A)      ; set DE (print destination) to E_LINE
1270   03D1 D9                  EXX                     ; switch.
1271   03D2             
1272   03D2 2A 06 40            LD      HL,($4006)      ; E_PPC current line.
1273   03D5 CD 0A 06            CALL    L060A           ; routine LINE-ADDR
1274   03D8 CD C2 03            CALL    L03C2           ; routine LINE-NO
1275   03DB 7A                  LD      A,D
1276   03DC B3                  OR      E
1277   03DD CA 83 02            JP      Z,L0283         ; back if zero to MAIN-EXEC
1278   03E0                                             ; no program.
1279   03E0             
1280   03E0 2B                  DEC     HL              ; point to location before
1281   03E1 CD BF 06            CALL    L06BF           ; routine OUT-NUM-2 prints line number
1282   03E4                                             ; to the edit line (unseen).
1283   03E4             
1284   03E4 2B                  DEC     HL              ; point to line number again
1285   03E5 CD 24 06            CALL    L0624           ; routine NEXT-ONE gets length in
1286   03E8                                             ; BC register.
1287   03E8 23                  INC     HL              ; point to the
1288   03E9 23                  INC     HL              ; first token.
1289   03EA 0B                  DEC     BC              ; decrease the length
1290   03EB 0B                  DEC     BC              ; by the same.
1291   03EC             
1292   03EC D9                  EXX
1293   03ED D5                  PUSH    DE              ; pick up the print position in the
1294   03EE D9                  EXX                     ; edit line.
1295   03EF             
1296   03EF D1                  POP     DE              ; and pop it to this set of registers
1297   03F0 3E B0               LD      A,$B0           ; the inverse 'K' cursor
1298   03F2 12                  LD      (DE),A          ; is inserted after line number.
1299   03F3 13                  INC     DE              ; address next 'print' location.
1300   03F4             
1301   03F4 E5                  PUSH    HL              ; push position within program.
1302   03F5             
1303   03F5 21 22 00            LD      HL,$0022        ; an overhead of 34d bytes.
1304   03F8 19                  ADD     HL,DE           ; add to edit line position
1305   03F9 09                  ADD     HL,BC           ; add in length of line.
1306   03FA ED 72               SBC     HL,SP           ; subtract the stack pointer.
1307   03FC 30 A9               JR      NC,L03A7        ; back to ED-COPY if not enough
1308   03FE                                             ; room to fill edit line.
1309   03FE             
1310   03FE E1                  POP     HL              ; restore program position.
1311   03FF ED B0               LDIR                    ; and copy it to edit line.
1312   0401 ED 53 0C 40         LD      ($400C),DE      ; update D_FILE
1313   0405             
1314   0405 C3 93 02            JP      L0293           ; jump back to AUTO-LIST
1315   0408             
1316   0408             ; ------------------------------
1317   0408             ; THE 'ENTER EDITING' SUBROUTINE
1318   0408             ; ------------------------------
1319   0408             ; This causes the line to be parsed.
1320   0408             ; The subroutine then loops back to MAIN-EXEC.
1321   0408             
1322   0408             ;; ED-ENTER
1323   0408 2A 15 40    L0408:  LD      HL,($4015)      ; fetch X_PTR the error pointer.
1324   040B 7C                  LD      A,H             ; check that it is
1325   040C B5                  OR      L               ; zero - no error.
1326   040D 20 98               JR      NZ,L03A7        ; double jump back to ED-COPY
1327   040F                                             ; if an error has occurred during
1328   040F                                             ; syntax checking.
1329   040F             
1330   040F 2A 04 40            LD      HL,($4004)      ; P_PTR
1331   0412             
1332   0412 CD 6C 03            CALL    L036C           ; ED-DEL-1 gets rid of cursor.
1333   0415             
1334   0415 2A 0A 40            LD      HL,($400A)      ; E_LINE
1335   0418             
1336   0418 22 26 40            LD      ($4026),HL      ; CH_ADD
1337   041B CD 1A 00            CALL    L001A           ; get-char
1338   041E FD CB 19 6E         BIT     5,(IY+$19)      ; FLAGX              input 1/edit 0
1339   0422 20 18               JR      NZ,L043C        ; forward to MAIN-1 if in input mode.
1340   0424             
1341   0424             ; else the edit line is to be run.
1342   0424             
1343   0424 CD 79 06            CALL    L0679           ; INT-TO-HL line number to HL'
1344   0427 D9                  EXX                     ; switch in set with the line number.
1345   0428 7C                  LD      A,H             ; and test
1346   0429 B5                  OR      L               ; for zero.
1347   042A C2 BA 04            JP      NZ,L04BA        ; jump forward with a number to MAIN-ADD
1348   042D                                             ; to add a new BASIC line or replacement.
1349   042D             
1350   042D             ; else must be a direct command.
1351   042D             
1352   042D 2B                  DEC     HL              ; make the line number
1353   042E 2B                  DEC     HL              ; the value minus two.
1354   042F             
1355   042F 22 02 40            LD      ($4002),HL      ; and set PPC
1356   0432             
1357   0432 CD 47 07            CALL    L0747           ; routine CLS
1358   0435             
1359   0435 D9                  EXX                     ;
1360   0436 7E                  LD      A,(HL)          ; fetch first character.
1361   0437 FE 76               CP      $76             ; is it just a newline ?
1362   0439 CA 83 02            JP      Z,L0283         ; jump back with newline to MAIN-EXEC
1363   043C                                             ; to produce an automatic listing.
1364   043C             
1365   043C             ; else check syntax and enter
1366   043C             
1367   043C             ;; MAIN-1
1368   043C FD 36 00 FF L043C:  LD      (IY+$00),$FF    ; set ERR_NR to no error
1369   0440 FD 36 01 88         LD      (IY+$01),$88    ; update FLAGS
1370   0444                                             ; set bit 7 - syntax checking off
1371   0444                                             ; set bit 3 - 'K' mode
1372   0444             
1373   0444             ;; M-2
1374   0444 CD BE 07    L0444:  CALL    L07BE           ; routine MAIN-G parses and executes the line.
1375   0447             
1376   0447                                             ; Note. this causes the value L0447 to be placed
1377   0447                                             ; on the machine stack as a return address.
1378   0447             
1379   0447             ;; M-3
1380   0447 CD 0A 0D    L0447:  CALL    L0D0A           ; REC-EDIT reclaims the edit line
1381   044A             
1382   044A ED 5B 02 40         LD      DE,($4002)      ; fetch current line number from PPC
1383   044E 21 19 40            LD      HL,$4019        ; address FLAGX
1384   0451             
1385   0451 CB 6E               BIT     5,(HL)          ; test FLAGX - input???
1386   0453 28 03               JR      Z,L0458         ; skip if editing to ->
1387   0455             
1388   0455 CB AE               RES     5,(HL)          ; update FLAGX - signal editing.
1389   0457 13                  INC     DE              ; increase line number so cursor doesn't show.
1390   0458             
1391   0458             ;; M-4
1392   0458 FD CB 00 7E L0458:  BIT     7,(IY+$00)      ; check ERR_NR.
1393   045C 28 2A               JR      Z,L0488         ; forward if an error has occurred.
1394   045E             
1395   045E 21 01 40            LD      HL,$4001        ; address FLAGS system variable
1396   0461             
1397   0461 CB 5E               BIT     3,(HL)          ; test FLAGS - K mode ?
1398   0463 CB 9E               RES     3,(HL)          ; update FLAGS - set L mode for future anyway.
1399   0465             
1400   0465 2A 26 40            LD      HL,($4026)      ; fetch character address CH_ADD
1401   0468 23                  INC     HL              ;
1402   0469 28 09               JR      Z,L0474         ; forward if not K mode.
1403   046B             
1404   046B EB                  EX      DE,HL           ; current line to HL, next char to DE.
1405   046C             
1406   046C 7C                  LD      A,H             ; fetch high byte of line number.
1407   046D E6 C0               AND     $C0             ; test for -2, -1 - direct command.
1408   046F 20 17               JR      NZ,L0488        ; forward to MAIN-ERR if so
1409   0471             
1410   0471 CD 0A 06            CALL    L060A           ; routine LINE-ADDR gets address of this line.
1411   0474             
1412   0474             ;; M-5
1413   0474 7E          L0474:  LD      A,(HL)          ; fetch
1414   0475 E6 C0               AND     $C0             ;
1415   0477 20 0F               JR      NZ,L0488        ; at program end
1416   0479             
1417   0479             ; else pick up the next line number
1418   0479             
1419   0479 56                  LD      D,(HL)          ;
1420   047A 23                  INC     HL              ;
1421   047B 5E                  LD      E,(HL)          ;
1422   047C ED 53 02 40         LD      ($4002),DE      ; place in PPC system variable
1423   0480 23                  INC     HL              ; point to first character
1424   0481                                             ; (space or command)
1425   0481             
1426   0481 3E 7F               LD      A,$7F           ; test for
1427   0483 DB FE               IN      A,($FE)         ; space key pressed.
1428   0485 1F                  RRA                     ; the space bit.
1429   0486 38 BC               JR      C,L0444         ; back if BREAK
1430   0488                                             ; else continue...
1431   0488             
1432   0488             ;; MAIN-ERR
1433   0488 CD E0 06    L0488:  CALL    L06E0           ; UNSTACK-Z quits if checking syntax >>>
1434   048B             
1435   048B CD C2 05            CALL    L05C2           ; routine CL-EOD clears to the end of upper
1436   048E                                             ; display area.
1437   048E 01 20 01            LD      BC,$0120        ; set line 1, column 32 for lower screen.
1438   0491 D9                  EXX                     ;
1439   0492             
1440   0492 3A 00 40            LD      A,($4000)       ; fetch the error number from ERR_NR
1441   0495 ED 4B 02 40         LD      BC,($4002)      ; fetch the current line from PPC
1442   0499 3C                  INC     A               ; test if error still $FF
1443   049A 28 0C               JR      Z,L04A8         ; forward if so to MAIN-5.
1444   049C             
1445   049C FE 09               CP      $09             ; is the error the STOP statement ?
1446   049E 20 01               JR      NZ,L04A1        ; forward if not STOP to SET-CONT to make the
1447   04A0                                             ; continuing line the same as current.
1448   04A0             
1449   04A0 03                  INC     BC              ; else increment line number for STOP.
1450   04A1             
1451   04A1             ;; SET-CONT
1452   04A1 ED 43 17 40 L04A1:  LD      ($4017),BC      ; store line number in OLDPPC
1453   04A5 20 01               JR      NZ,L04A8        ; forward if not STOP as line number is current
1454   04A7             
1455   04A7 0B                  DEC     BC              ; else decrement line number again.
1456   04A8             
1457   04A8             ; Now print the report line e.g. 100/0   (terminated OK at line 100)
1458   04A8             
1459   04A8             ;; MAIN-5
1460   04A8 CD 56 05    L04A8:  CALL    L0556           ; routine OUT-CODE prints line number
1461   04AB             
1462   04AB 3E 15               LD      A,$15           ; prepare character '/'
1463   04AD D7                  RST     10H             ; print the separator
1464   04AE             
1465   04AE CD A1 06            CALL    L06A1           ; OUT-NUM-1 to print error-code in A.
1466   04B1             
1467   04B1 CD C2 05            CALL    L05C2           ; routine CL-EOD
1468   04B4             
1469   04B4 CD 3F 01            CALL    L013F           ; routine KEYBOARD
1470   04B7             
1471   04B7 C3 83 02            JP      L0283           ; jump back to MAIN-EXEC
1472   04BA             
1473   04BA             ; ---------------------
1474   04BA             ; THE 'MAIN-ADD' BRANCH
1475   04BA             ; ---------------------
1476   04BA             ; This section allows a new BASIC line to be added to the Program.
1477   04BA             
1478   04BA             ;; MAIN-ADD
1479   04BA 22 06 40    L04BA:  LD      ($4006),HL      ; make E_PPC the new line number.
1480   04BD             
1481   04BD D9                  EXX                     ;
1482   04BE EB                  EX      DE,HL           ;
1483   04BF CD 47 07            CALL    L0747           ; routine CLS
1484   04C2 ED 52               SBC     HL,DE           ;
1485   04C4 D9                  EXX                     ;
1486   04C5             
1487   04C5 CD 0A 06            CALL    L060A           ; routine LINE-ADDR
1488   04C8 E5                  PUSH    HL              ;
1489   04C9 20 06               JR      NZ,L04D1        ; forward if line doesn't exist to MAIN-ADD1.
1490   04CB             
1491   04CB CD 24 06            CALL    L0624           ; routine NEXT-ONE gets length of old line
1492   04CE CD 66 06            CALL    L0666           ; routine RECLAIM-2
1493   04D1             
1494   04D1             ;; MAIN-ADD1
1495   04D1 D9          L04D1:  EXX                     ;
1496   04D2 23                  INC     HL              ;
1497   04D3 44                  LD      B,H             ;
1498   04D4 4D                  LD      C,L             ;
1499   04D5 7D                  LD      A,L             ;
1500   04D6 D6 03               SUB     $03             ;
1501   04D8 B4                  OR      H               ;
1502   04D9 C4 4F 09            CALL    NZ,L094F        ; routine TEST-ROOM
1503   04DC             
1504   04DC E1                  POP     HL              ;
1505   04DD 30 15               JR      NC,L04F4        ; double jump back to MAIN-EXEC
1506   04DF                                             ; not possible.
1507   04DF             
1508   04DF C5                  PUSH    BC              ;
1509   04E0 2B                  DEC     HL              ;
1510   04E1 CD D5 05            CALL    L05D5           ; routine MAKE-ROOM
1511   04E4 13                  INC     DE              ;
1512   04E5 2A 0C 40            LD      HL,($400C)      ; set HL from D_FILE
1513   04E8 2B                  DEC     HL              ; now points to end of edit line.
1514   04E9 C1                  POP     BC              ; restore length
1515   04EA             
1516   04EA 0B                  DEC     BC              ;
1517   04EB ED B8               LDDR                    ; copy line from edit line to prog.
1518   04ED 2A 06 40            LD      HL,($4006)      ; E_PPC - line number
1519   04F0 EB                  EX      DE,HL           ; swap
1520   04F1 72                  LD      (HL),D          ; insert high byte
1521   04F2 23                  INC     HL              ;
1522   04F3 73                  LD      (HL),E          ; insert low byte
1523   04F4             
1524   04F4             ;; MAIN-JR
1525   04F4 C3 83 02    L04F4:  JP      L0283           ; jump back to MAIN-EXEC
1526   04F7             
1527   04F7             ; -----------------------------------------
1528   04F7             ; THE 'PRINT A WHOLE BASIC LINE' SUBROUTINE
1529   04F7             ; -----------------------------------------
1530   04F7             
1531   04F7             ;; OUT-LINE
1532   04F7 ED 4B 06 40 L04F7:  LD      BC,($4006)      ; fetch E_PPC
1533   04FB CD 1C 06            CALL    L061C           ; routine CP-LINES
1534   04FE 16 97               LD      D,$97           ; prepare character '>'
1535   0500 28 05               JR      Z,L0507         ; forward with line cursor if line is the
1536   0502                                             ; current edit line to OUT-LINE-1
1537   0502             
1538   0502 11 00 00            LD      DE,$0000        ; else replace line cursor with a
1539   0505                                             ; space in D, and zero to E.
1540   0505 CB 13               RL      E               ; pick up any carry from CP-LINES
1541   0507                                             ; should the line precede the
1542   0507                                             ; current edit line.
1543   0507             
1544   0507             ;; OUT-LINE-1
1545   0507 7E          L0507:  LD      A,(HL)          ; fetch the high byte of line number.
1546   0508 FE 40               CP      $40             ; compare with end marker
1547   050A DC BF 06            CALL    C,L06BF         ; routine OUT-NUM-2 if a valid line number.
1548   050D D0                  RET     NC              ; return if out of screen                >>>
1549   050E             
1550   050E 23                  INC     HL              ; address the first command character.
1551   050F 7A                  LD      A,D             ; fetch the space/cursor
1552   0510 D7                  RST     10H             ; print it.
1553   0511 D0                  RET     NC              ; return if out of screen.
1554   0512             
1555   0512             ;; OUT-LINE-2
1556   0512 FD CB 01 C6 L0512:  SET     0,(IY+$01)      ; update FLAGS - suppress a leading space
1557   0516             
1558   0516             ;; OUT-LINE-3
1559   0516 ED 4B 15 40 L0516:  LD      BC,($4015)      ; fetch error pointer - X_PTR
1560   051A A7                  AND     A               ; prepare to subtract.
1561   051B ED 42               SBC     HL,BC           ; subtract the current address.
1562   051D 20 04               JR      NZ,L0523        ; forward to OUT-LINE-4 if not an
1563   051F                                             ; exact match.
1564   051F 3E B8               LD      A,$B8           ; prepare inverse 'S' to show syntax error.
1565   0521 D7                  RST     10H             ; print it.
1566   0522 C8                  RET     Z               ; return if at end
1567   0523             
1568   0523             ;; OUT-LINE-4
1569   0523 09          L0523:  ADD     HL,BC           ; restore pointer.
1570   0524 7E                  LD      A,(HL)          ; fetch character.
1571   0525 23                  INC     HL              ; address next character.
1572   0526             
1573   0526 FE B0               CP      $B0             ; is character inverse 'K' ?
1574   0528 28 12               JR      Z,L053C         ; forward if so to OUT-CURS.
1575   052A             
1576   052A             ; then cleverly split the characters into 4 streams.
1577   052A             
1578   052A FE C0               CP      $C0             ; compare character to 192 ?
1579   052C             
1580   052C EA 59 05            JP      PE,L0559        ; jump forward with 64-127 to OUT-SP-CH
1581   052F                                             ; thereby exiting the routine
1582   052F                                             ; as it must be the 118, NEWLINE character.
1583   052F             
1584   052F 38 05               JR      C,L0536         ; forward with 0-63, 128-191 to OUT-LINE-5
1585   0531                                             ; to print simple characters and their inverse
1586   0531                                             ; forms.
1587   0531             
1588   0531             ; that leaves tokens $C0 - $FF
1589   0531             
1590   0531 CD 84 05            CALL    L0584           ; routine PO-TOKEN
1591   0534             
1592   0534 18 03               JR      L0539           ; forward to OUT-LINE-6
1593   0536             
1594   0536             ; ---
1595   0536             
1596   0536             ;; OUT-LINE-5
1597   0536 CD 59 05    L0536:  CALL    L0559           ; routine OUT-SP-CH
1598   0539             
1599   0539             ;; OUT-LINE-6
1600   0539 D0          L0539:  RET     NC              ; return if out of screen.            >>
1601   053A 18 DA               JR      L0516           ; else back to OUT-LINE-3 for more.
1602   053C             
1603   053C             ; ---------------------------------------------------------------------------
1604   053C             ; Z80 PARITY/OVERFLOW FLAG:
1605   053C             ; ------------------------
1606   053C             ; The use of this flag is two-fold depending on the type of operation.
1607   053C             ; It indicates the parity of the result of a LOGICAL operation such as an AND,
1608   053C             ; OR, XOR by being set PE if there are an even number of set bits and reset
1609   053C             ; PO if there are an odd number of set bits.
1610   053C             ; so 10101010 is parity even, 00000001 is parity odd.
1611   053C             ; JP PE, LABEL
1612   053C             ; JP PO, LABEL are obvious.
1613   053C             ; For MATHEMATICAL operations, (ADD, SUB, CP etc.) the P/V bit indicates a
1614   053C             ; carry out of bit position 6 of the accumulator if signed values are being
1615   053C             ; used.
1616   053C             ; This indicates an overflow of a result greater than 127, which carries
1617   053C             ; into bit 7, the sign bit.
1618   053C             ; So as CP is just a SUB with the result thrown away.
1619   053C             ; $C0 SUB $CO gives result $00   (PO - no overflow from 6 to 7)
1620   053C             ; $8O SUB $C0 gives result $C0   (PO - no overflow from 6 to 7)
1621   053C             ; $00 SUB $C0 gives result $40   (PO - no overflow from 6 to 7)
1622   053C             ; $40 SUB $CO gives result $80   (PE - overflow from 6 to 7)
1623   053C             ; The overflow flag is similarly set following 16-bit addition and subtraction
1624   053C             ; routines.
1625   053C             ; ---------------------------------------------------------------------------
1626   053C             
1627   053C             
1628   053C             ; -----------------------------
1629   053C             ; THE 'PRINT THE CURSOR' BRANCH
1630   053C             ; -----------------------------
1631   053C             
1632   053C             ;; OUT-CURS
1633   053C FD CB 01 56 L053C:  BIT     2,(IY+$01)      ; test FLAGS - K-mode ?
1634   0540 20 01               JR      NZ,L0543        ; skip to OUT-K if 'K' mode.
1635   0542             
1636   0542 3C                  INC     A               ; change from 'K' to 'L' cursor.
1637   0543             
1638   0543             ;; OUT-K
1639   0543 D7          L0543:  RST     10H             ; print the cursor.
1640   0544 18 F3               JR      L0539           ; back to OUT-LINE-6 above.
1641   0546             
1642   0546             ; -----------------------------------------------------
1643   0546             ; THE 'PRINTING CHARACTERS IN A BASIC LINE' SUBROUTINES
1644   0546             ; -----------------------------------------------------
1645   0546             
1646   0546             ;; OUT-SP-2
1647   0546 7B          L0546:  LD      A,E             ; transfer E to A
1648   0547                                             ; register E will be
1649   0547                                             ; $FF - no leading space.
1650   0547                                             ; $01 - the leading space itself.
1651   0547                                             ; $1C - '0' from a previous non-space print.
1652   0547 07                  RLCA                    ; test for the
1653   0548 0F                  RRCA                    ; value $FF.
1654   0549 D8                  RET     C               ; return if no leading space
1655   054A             
1656   054A 18 10               JR      L055C           ; forward to OUT-LD-SP
1657   054C             
1658   054C             ; ---
1659   054C             
1660   054C             ; --> The Entry Point.
1661   054C             
1662   054C             ;; OUT-SP-NO
1663   054C AF          L054C:  XOR     A               ; set accumulator to zero.
1664   054D             
1665   054D             ;; OUT-SP-1
1666   054D 09          L054D:  ADD     HL,BC           ; addition of negative number.
1667   054E 3C                  INC     A               ; increment the digit.
1668   054F 38 FC               JR      C,L054D         ; back while overflow exists to OUT-SP-1
1669   0551             
1670   0551 ED 42               SBC     HL,BC           ; else reverse the last addition.
1671   0553 3D                  DEC     A               ; and decrement the digit.
1672   0554             
1673   0554 28 F0               JR      Z,L0546         ; back to OUT-SP-2 if digit is zero again.
1674   0556             
1675   0556             ; else continue to print the final digit using OUT-CODE.
1676   0556             
1677   0556             ;; OUT-CODE
1678   0556 1E 1C       L0556:  LD      E,$1C           ; load E with '0'
1679   0558                                             ; Note. that E will remain as such for all
1680   0558                                             ; further calls. The leading space is no more.
1681   0558 83                  ADD     A,E             ; add the digit 1-9 to give '1' to '9'
1682   0559             
1683   0559             ;; OUT-SP-CH
1684   0559 A7          L0559:  AND     A               ; test value for space.
1685   055A 28 04               JR      Z,L0560         ; skip if zero to PRINT-A-2
1686   055C             
1687   055C             ;; OUT-LD-SP
1688   055C FD CB 01 86 L055C:  RES     0,(IY+$01)      ; signal allow leading space to FLAGS
1689   0560                                             ; and continue...
1690   0560             
1691   0560             ; ------------------------------
1692   0560             ; THE 'MAIN PRINTING' SUBROUTINE
1693   0560             ; ------------------------------
1694   0560             ; This is a continuation of the PRINT restart.
1695   0560             ; It is used primarily to print to the dynamic screen checking free memory
1696   0560             ; before every character is printed.
1697   0560             ; However it can also be used as an invisible process to 'sprint' the line
1698   0560             ; number of a BASIC line to the Edit Line by ED-EDIT setting DE from E_LINE.
1699   0560             ;
1700   0560             ; As lines are unexpanded, then when the column count is reduced from 32 to 0 a
1701   0560             ; newline is inserted before the character and the column count is reset.
1702   0560             
1703   0560             ;; PRINT-A-2
1704   0560 D9          L0560:  EXX                     ; switch sets.
1705   0561             
1706   0561 67                  LD      H,A             ; preserve character in H.
1707   0562                                             ; Note. this is restored by TEST-RM-2
1708   0562 17                  RLA                     ; rotate character twice to
1709   0563 17                  RLA                     ; test bit 6 - sets carry for NEWLINE.
1710   0564             
1711   0564 0D                  DEC     C               ; decrease column count - affects zero / sign.
1712   0565             
1713   0565 30 02               JR      NC,L0569        ; forward if 0-63 or inverse to NO-NL
1714   0567             
1715   0567             ; else the incoming character is a NEWLINE $76
1716   0567             
1717   0567 0E 00               LD      C,$00           ; set column to zero without disturbing flags.
1718   0569                                             ; if this is a received NEWLINE.
1719   0569                                             ; this will be set to 32 if a subsequent
1720   0569                                             ; character is printed
1721   0569             
1722   0569             ;; NO-NL
1723   0569 FA 74 05    L0569:  JP      M,L0574         ; jump to PR-SPR if column was originally 0
1724   056C             
1725   056C 38 0E               JR      C,L057C         ; forward to PRI-CHAR with a received NEWLINE.
1726   056E             
1727   056E 20 0C               JR      NZ,L057C        ; forward if column not yet reduced to zero
1728   0570                                             ; to PRI-CHAR
1729   0570             
1730   0570             ; else an automatic newline is required before the received character as
1731   0570             ; we are at end of line.
1732   0570             
1733   0570 3E 76               LD      A,$76           ; prepare the newline
1734   0572 12                  LD      (DE),A          ; insert at screen position
1735   0573 13                  INC     DE              ; increase the address pointer.
1736   0574             
1737   0574             ;; PR-SPR
1738   0574 38 02       L0574:  JR      C,L0578         ; skip if a received newline to PRI-SKIP
1739   0576             
1740   0576 0E 20               LD      C,$20           ; reset column to 32 decimal.
1741   0578             
1742   0578             ;; PRI-SKIP
1743   0578 A7          L0578:  AND     A               ; clear carry now to signal failure should the
1744   0579                                             ; next test fail.
1745   0579 05                  DEC     B               ; decrease line.
1746   057A 28 06               JR      Z,L0582         ; forward with out of screen to PR-END.
1747   057C             
1748   057C             ;; PRI-CH
1749   057C 68          L057C:  LD      L,B             ; transfer line number, B to L for next routine.
1750   057D             
1751   057D CD 58 09            CALL    L0958           ; routine TEST-RM-2 tests room.
1752   0580                                             ; (character is in H returned in A)
1753   0580                                             ; carry set if there is room.
1754   0580             
1755   0580 12                  LD      (DE),A          ; insert chr at screen (or edit line).
1756   0581 13                  INC     DE              ; increase destination address.
1757   0582             
1758   0582             ;; PR-END
1759   0582 D9          L0582:  EXX                     ; switch to protect registers.
1760   0583 C9                  RET                     ; return
1761   0584             
1762   0584             ; -------------------------------
1763   0584             ; THE 'TOKEN PRINTING' SUBROUTINE
1764   0584             ; -------------------------------
1765   0584             
1766   0584             ;; PO-TOKEN
1767   0584 CD A8 05    L0584:  CALL    L05A8           ; routine PO-SEARCH locates token
1768   0587 30 09               JR      NC,L0592        ; forward to PO-LOOP if first character is
1769   0589                                             ; not alphanumeric. e.g. '**'
1770   0589             
1771   0589             ; else consider a leading space.
1772   0589             
1773   0589 FD CB 01 46         BIT     0,(IY+$01)      ; test FLAGS - leading space allowed ?
1774   058D 20 03               JR      NZ,L0592        ; forward to PO-LOOP if not.
1775   058F             
1776   058F             ; else print a leading space.
1777   058F             
1778   058F AF                  XOR     A               ; prepare a space
1779   0590 D7                  RST     10H             ; print it
1780   0591 D0                  RET     NC              ; return if out of screen.
1781   0592             
1782   0592             ; now enter a loop to print each character and then consider a trailing space.
1783   0592             
1784   0592             ;; PO-LOOP
1785   0592 0A          L0592:  LD      A,(BC)          ; fetch character from token table.
1786   0593 E6 3F               AND     $3F             ; mask to give range ' ' to 'Z'
1787   0595             
1788   0595 CD 59 05            CALL    L0559           ; routine OUT-SP-CH
1789   0598             
1790   0598 D0                  RET     NC              ; return if out of screen.
1791   0599             
1792   0599 0A                  LD      A,(BC)          ; reload the character
1793   059A 03                  INC     BC              ; point to next.
1794   059B 87                  ADD     A,A             ; test for the inverted bit.
1795   059C 30 F4               JR      NC,L0592        ; loop back if not inverted to PO-LOOP
1796   059E             
1797   059E             ;
1798   059E             
1799   059E FE 38               CP      $38             ; compare with what was '0' before doubling.
1800   05A0 D8                  RET     C               ; return if less. i.e. not a command.     >>
1801   05A1             
1802   05A1 AF                  XOR     A               ; else prepare a space
1803   05A2 FD CB 01 C6         SET     0,(IY+$01)      ; update FLAGS - use no leading space
1804   05A6 18 B8               JR      L0560           ; back to PRINT-A-2 for trailing space.   >>
1805   05A8             
1806   05A8             ; -----------------------------
1807   05A8             ; THE 'TABLE SEARCH' SUBROUTINE
1808   05A8             ; -----------------------------
1809   05A8             
1810   05A8             ;; PO-SEARCH
1811   05A8 E5          L05A8:  PUSH    HL              ; * preserve character pointer
1812   05A9             
1813   05A9 21 BA 00            LD      HL,$00BA        ; point to start of the table
1814   05AC 96                  SUB     (HL)            ; test against the threshold character 212
1815   05AD 23                  INC     HL              ; address next in table.   ('?' + $80 )
1816   05AE 38 09               JR      C,L05B9         ; forward to PO-FOUND if less than 212
1817   05B0                                             ; to print a question mark.
1818   05B0             
1819   05B0 3C                  INC     A               ; make range start at 1 for chr 212.
1820   05B1                                             ; note - should the required token be 212
1821   05B1                                             ; the printable quote character then the
1822   05B1                                             ; pointer currently addresses '"' + $80.
1823   05B1 47                  LD      B,A             ; save reduced token in B as a counter.
1824   05B2             
1825   05B2             ;; PO-STEP
1826   05B2 CB 7E       L05B2:  BIT     7,(HL)          ; test for inverted bit
1827   05B4 23                  INC     HL              ; increase address
1828   05B5 28 FB               JR      Z,L05B2         ; back to PO-STEP for inverted bit
1829   05B7             
1830   05B7 10 F9               DJNZ    L05B2           ; decrement counter and loop back to PO-STEP
1831   05B9                                             ; until at required token.
1832   05B9             
1833   05B9             ;; PO-FOUND
1834   05B9 44          L05B9:  LD      B,H             ; transfer the address
1835   05BA 4D                  LD      C,L             ; to BC.
1836   05BB             
1837   05BB E1                  POP     HL              ; * restore string address
1838   05BC 0A                  LD      A,(BC)          ; fetch first character from token.
1839   05BD E6 3F               AND     $3F             ; mask off range 0-63d, SPACE to Z
1840   05BF C6 E4               ADD     A,$E4           ; add value 228
1841   05C1 C9                  RET                     ; return with carry set if alphanumeric and a
1842   05C2                                             ; leading space is required.
1843   05C2             
1844   05C2             ; -------------------------------------
1845   05C2             ; THE 'CLEAR TO END OF DISPLAY' ROUTINE
1846   05C2             ; -------------------------------------
1847   05C2             
1848   05C2             ;; CL-EOD
1849   05C2 D9          L05C2:  EXX                     ; switch in the set with screen values.
1850   05C3             
1851   05C3 AF                  XOR     A               ; clear accumulator.
1852   05C4 B8                  CP      B               ; compare with line counter - 0 to 23.
1853   05C5 28 09               JR      Z,L05D0         ; forward if clear to SET-EOD.
1854   05C7             
1855   05C7 B9                  CP      C               ; compare to column count - 0 to 32.
1856   05C8 3E 76               LD      A,$76           ; prepare a NEWLINE.
1857   05CA 28 02               JR      Z,L05CE         ; forward, if zero, to CL-EOL.
1858   05CC             
1859   05CC             ;; INS-CR
1860   05CC 12          L05CC:  LD      (DE),A          ; insert a newline/carriage return.
1861   05CD 13                  INC     DE              ; address next position.
1862   05CE             
1863   05CE             ;; CL-EOL
1864   05CE 10 FC       L05CE:  DJNZ    L05CC           ; reduce line counter and loop back to INS-CR.
1865   05D0             
1866   05D0             ;; SET-EOD
1867   05D0 ED 53 10 40 L05D0:  LD      ($4010),DE      ; update DF_END - display file end.
1868   05D4 C9                  RET                     ; return.
1869   05D5             
1870   05D5             ; --------------------------
1871   05D5             ; THE 'MAKE-ROOM' SUBROUTINE
1872   05D5             ; --------------------------
1873   05D5             
1874   05D5             ;; MAKE-ROOM
1875   05D5 CD DF 05    L05D5:  CALL    L05DF           ; routine POINTERS also sets BC
1876   05D8 2A 10 40            LD      HL,($4010)      ; fetch new display file end DF_END
1877   05DB EB                  EX      DE,HL           ; switch source/destination.
1878   05DC ED B8               LDDR                    ; now make the room.
1879   05DE C9                  RET                     ; return.
1880   05DF                                             ; with HL pointing at first new location.
1881   05DF             
1882   05DF             ; -------------------------
1883   05DF             ; THE 'POINTERS' SUBROUTINE
1884   05DF             ; -------------------------
1885   05DF             
1886   05DF             ;; POINTERS
1887   05DF F5          L05DF:  PUSH    AF              ;
1888   05E0 E5                  PUSH    HL              ;
1889   05E1 21 08 40            LD      HL,$4008        ; VARS
1890   05E4 3E 05               LD      A,$05           ;
1891   05E6             
1892   05E6             ;; PTR-NEXT
1893   05E6 5E          L05E6:  LD      E,(HL)          ;
1894   05E7 23                  INC     HL              ;
1895   05E8 56                  LD      D,(HL)          ;
1896   05E9 E3                  EX      (SP),HL         ;
1897   05EA A7                  AND     A               ;
1898   05EB ED 52               SBC     HL,DE           ;
1899   05ED 19                  ADD     HL,DE           ;
1900   05EE E3                  EX      (SP),HL         ;
1901   05EF 30 09               JR      NC,L05FA        ; forward to PTR-DONE
1902   05F1             
1903   05F1 D5                  PUSH    DE              ;
1904   05F2 EB                  EX      DE,HL           ;
1905   05F3 09                  ADD     HL,BC           ;
1906   05F4 EB                  EX      DE,HL           ;
1907   05F5 72                  LD      (HL),D          ;
1908   05F6 2B                  DEC     HL              ;
1909   05F7 73                  LD      (HL),E          ;
1910   05F8 23                  INC     HL              ;
1911   05F9 D1                  POP     DE              ;
1912   05FA             
1913   05FA             ;; PTR-DONE
1914   05FA 23          L05FA:  INC     HL              ;
1915   05FB 3D                  DEC     A               ;
1916   05FC 20 E8               JR      NZ,L05E6        ; back to PTR-NEXT for all five
1917   05FE                                             ; dynamic variables.
1918   05FE             
1919   05FE             ; now find the size of the block to be moved.
1920   05FE             
1921   05FE EB                  EX      DE,HL           ;
1922   05FF D1                  POP     DE              ;
1923   0600 F1                  POP     AF              ;
1924   0601 A7                  AND     A               ;
1925   0602 ED 52               SBC     HL,DE           ;
1926   0604 44                  LD      B,H             ;
1927   0605 4D                  LD      C,L             ;
1928   0606 03                  INC     BC              ;
1929   0607 19                  ADD     HL,DE           ;
1930   0608 EB                  EX      DE,HL           ;
1931   0609 C9                  RET                     ; return  ->
1932   060A             
1933   060A             ; --------------------------
1934   060A             ; THE 'LINE-ADDR' SUBROUTINE
1935   060A             ; --------------------------
1936   060A             
1937   060A             ;; LINE-ADDR
1938   060A E5          L060A:  PUSH    HL              ; save the given line number.
1939   060B 21 28 40            LD      HL,$4028        ; start of PROG
1940   060E 54                  LD      D,H             ; transfer the address
1941   060F 5D                  LD      E,L             ; to the DE register pair.
1942   0610             
1943   0610             ;; LINE-AD-1
1944   0610 C1          L0610:  POP     BC              ; the given line number.
1945   0611 EB                  EX      DE,HL           ;
1946   0612             
1947   0612 CD 1C 06            CALL    L061C           ; routine CP-LINES
1948   0615             
1949   0615 D0                  RET     NC              ; return if carry set                   >>
1950   0616             
1951   0616 C5                  PUSH    BC              ; otherwise save given line number
1952   0617             
1953   0617 CD 24 06            CALL    L0624           ; routine NEXT-ONE
1954   061A             
1955   061A 18 F4               JR      L0610           ; back to LINE-AD-1 to consider the next
1956   061C                                             ; line of the program.
1957   061C             
1958   061C             ; -------------------------------------
1959   061C             ; THE 'COMPARE LINE NUMBERS' SUBROUTINE
1960   061C             ; -------------------------------------
1961   061C             
1962   061C             ;; CP-LINES
1963   061C 7E          L061C:  LD      A,(HL)          ; fetch the high byte of the addressed line
1964   061D B8                  CP      B               ; number and compare it.
1965   061E C0                  RET     NZ              ; return if they do not match.
1966   061F             
1967   061F 23                  INC     HL              ; next compare the low bytes.
1968   0620 7E                  LD      A,(HL)          ;
1969   0621 2B                  DEC     HL              ;
1970   0622 B9                  CP      C               ;
1971   0623 C9                  RET                     ; return with carry flag set if the addressed
1972   0624                                             ; line number has yet to reach the
1973   0624                                             ; given line number.
1974   0624             
1975   0624             ;------------------------------------------------------------------------
1976   0624             ; Storage of variables. For full details - see Page 107
1977   0624             ; ZX80 BASIC Programming by Hugo Davenport 1980.
1978   0624             ; It is bits 7-5 of the first character of a variable that allow
1979   0624             ; the five types to be distinguished. Bits 4-0 are the reduced letter.
1980   0624             ; So any variable name is higher that $3F and can be distinguished
1981   0624             ; also from the variables area end-marker $80.
1982   0624             ;
1983   0624             ; 76543210 meaning                       brief outline of format after letter.
1984   0624             ; -------- ------------------------      -----------------------
1985   0624             ; 011      simple integer variable.      2 bytes. (after letter)
1986   0624             ; 010      long-named integer variable   2 bytes. (after inverted name)
1987   0624             ; 100      string                        letter + contents + $01.
1988   0624             ; 101      array of integers             letter + max subs byte + subs * 2.
1989   0624             ; 111      for-next loop variable.       7 bytes - letter, value, limit, line.
1990   0624             ; 10000000 the variables end-marker.
1991   0624             ;
1992   0624             ; Note. any of the above six will serve as a program end-marker.
1993   0624             ;
1994   0624             ; -----------------------------------------------------------------------
1995   0624             
1996   0624             ; -------------------------
1997   0624             ; THE 'NEXT-ONE' SUBROUTINE
1998   0624             ; -------------------------
1999   0624             
2000   0624             ;; NEXT-ONE
2001   0624 E5          L0624:  PUSH    HL              ; save address of current line or variable.
2002   0625             
2003   0625 7E                  LD      A,(HL)          ; fetch the first byte.
2004   0626 87                  ADD     A,A             ; test bits 7 and 6
2005   0627 FA 35 06            JP      M,L0635         ; jump forward if simple, long-named or for-next
2006   062A                                             ; control variable to NO-SLNFM
2007   062A             
2008   062A 38 17               JR      C,L0643         ; forward if string or arrays to NO-STR-AR
2009   062C             
2010   062C             ; that leaves program line numbers.
2011   062C             
2012   062C 23                  INC     HL              ; step past high byte
2013   062D 3E 76               LD      A,$76           ; the search is for newline
2014   062F             
2015   062F             ;; NO-SEARCH
2016   062F 23          L062F:  INC     HL              ; skip to next address past low byte.
2017   0630 47                  LD      B,A             ; save search byte in B to create
2018   0631                                             ; a large value in BC so that search is
2019   0631                                             ; not curtailed.
2020   0631 ED B1               CPIR                    ; and locate the known character.
2021   0633 18 1D               JR      L0652           ; forward to ??? with HL addressing
2022   0635                                             ; the following character.
2023   0635             
2024   0635             ; ---
2025   0635             
2026   0635             ; the branch was here with simple, long-named and for-next variables
2027   0635             
2028   0635             ;; NO-SLNFN
2029   0635 01 02 00    L0635:  LD      BC,$0002        ; presume a for-next variable (1+2 cells)
2030   0638 38 01               JR      C,L063B         ; skip forward if for-next variable.
2031   063A             
2032   063A 48                  LD      C,B             ; set C to zero - just one cell for simple
2033   063B                                             ; and long-named.
2034   063B             
2035   063B             ;; NO-FNXT
2036   063B 17          L063B:  RLA                     ; original bit 5 is now bit 7.
2037   063C             
2038   063C             ;; NO-LNLP
2039   063C 17          L063C:  RLA                     ; test original bit 5 of letter.
2040   063D             
2041   063D 23                  INC     HL              ; advance address.
2042   063E 7E                  LD      A,(HL)          ; pick up next byte - possibly a letter
2043   063F 30 FB               JR      NC,L063C        ; back if originally long-named or if
2044   0641                                             ; on subsequent loops character is not inverted
2045   0641             
2046   0641             ; whatever the route we are now pointing at the first cell with the number
2047   0641             ; of cells less one in register C.
2048   0641             
2049   0641 18 0C               JR      L064F           ; forward to NO-CELLS to calculate space to the
2050   0643                                             ; end of variable.
2051   0643             
2052   0643             ; ---
2053   0643             
2054   0643             ; the branch was here with either single strings or numeric array variables
2055   0643             
2056   0643             ;; NO-STR_AR
2057   0643 E6 40       L0643:  AND     $40             ; test shifted bit 6 - will be set for arrays
2058   0645 3E 01               LD      A,$01           ; set search for null terminator
2059   0647 28 E6               JR      Z,L062F         ; back if not an array to NO-SEARCH to
2060   0649                                             ; search for the end of string.
2061   0649             
2062   0649             ; the object is a NUMERIC ARRAY
2063   0649             
2064   0649 23                  INC     HL              ; point to maximum subscription
2065   064A 7E                  LD      A,(HL)          ; and fetch
2066   064B 23                  INC     HL              ; point to first cell.
2067   064C 06 00               LD      B,$00           ; prepare to index
2068   064E 4F                  LD      C,A             ; max subscription to C
2069   064F                                             ; and continue to find following byte.
2070   064F             
2071   064F             ;; NXT-O-6
2072   064F 03          L064F:  INC     BC              ; bump the range
2073   0650 09                  ADD     HL,BC           ; add to start
2074   0651 09                  ADD     HL,BC           ; add again as each cell is two bytes.
2075   0652             
2076   0652             ;; NXT-O-7
2077   0652 D1          L0652:  POP     DE              ; restore previous address to DE and
2078   0653                                             ; continue into the difference routine...
2079   0653             
2080   0653             ; ---------------------------
2081   0653             ; THE 'DIFFERENCE' SUBROUTINE
2082   0653             ; ---------------------------
2083   0653             
2084   0653             ;; DIFFER
2085   0653 A7          L0653:  AND     A               ; prepare to subtract.
2086   0654 ED 52               SBC     HL,DE           ; calculate the length of the line/var
2087   0656             
2088   0656 44                  LD      B,H             ; transfer the length
2089   0657 4D                  LD      C,L             ; to the BC register pair.
2090   0658             
2091   0658 19                  ADD     HL,DE           ; reform the address of next one in HL.
2092   0659 EB                  EX      DE,HL           ; swap pointers
2093   065A C9                  RET                     ; return.
2094   065B             
2095   065B             ; ------------------------------
2096   065B             ; THE 'CLEAR' COMMAND SUBROUTINE
2097   065B             ; ------------------------------
2098   065B             ; The CLEAR command removes all BASIC variables.
2099   065B             
2100   065B             ;; CLEAR
2101   065B 2A 0A 40    L065B:  LD      HL,($400A)      ; set HL to E_LINE.
2102   065E 2B                  DEC     HL              ; decrement to point to the $80 end-marker.
2103   065F ED 5B 08 40         LD      DE,($4008)      ; set start from VARS system variable.
2104   0663             
2105   0663             ; ----------------------------
2106   0663             ; THE 'RECLAIMING' SUBROUTINES
2107   0663             ; ----------------------------
2108   0663             
2109   0663             ;; RECLAIM-1
2110   0663 CD 53 06    L0663:  CALL    L0653           ; routine DIFFER
2111   0666             
2112   0666             ;; RECLAIM-2
2113   0666 C5          L0666:  PUSH    BC              ;
2114   0667             
2115   0667 78                  LD      A,B             ;
2116   0668 2F                  CPL                     ;
2117   0669 47                  LD      B,A             ;
2118   066A             
2119   066A 79                  LD      A,C             ;
2120   066B 2F                  CPL                     ;
2121   066C 4F                  LD      C,A             ;
2122   066D             
2123   066D 03                  INC     BC              ;
2124   066E             
2125   066E CD DF 05            CALL    L05DF           ; routine POINTERS
2126   0671             
2127   0671 EB                  EX      DE,HL           ;
2128   0672 E1                  POP     HL              ;
2129   0673 19                  ADD     HL,DE           ;
2130   0674 D5                  PUSH    DE              ;
2131   0675 ED B0               LDIR                    ;
2132   0677 E1                  POP     HL              ;
2133   0678 C9                  RET                     ; return.
2134   0679             
2135   0679             ; ----------------------------------------
2136   0679             ; THE 'INTEGER TO ALTERNATE HL' SUBROUTINE
2137   0679             ; ----------------------------------------
2138   0679             
2139   0679             ;; INT-TO-HL
2140   0679 7E          L0679:  LD      A,(HL)          ; fetch first digit
2141   067A D9                  EXX                     ; switch
2142   067B 21 00 00            LD      HL,$0000        ; initialize result register to zero.
2143   067E 44                  LD      B,H             ; make B zero also.
2144   067F             
2145   067F             ;; DEC-LP
2146   067F D6 1C       L067F:  SUB     $1C             ; subtract chr '0'
2147   0681 38 17               JR      C,L069A         ; forward to STOR-RSLT if less.            >>
2148   0683             
2149   0683 FE 0A               CP      $0A             ; compare with 'ten'
2150   0685 30 13               JR      NC,L069A        ; forward to STOR-RSLT if higher than '9'. >>
2151   0687             
2152   0687 4F                  LD      C,A             ; save unit in C.
2153   0688             
2154   0688             ; now test that the result is not about to enter the 32768 - 65535 region.
2155   0688             
2156   0688 3E 0D               LD      A,$0D           ; value 13 to A
2157   068A BC                  CP      H               ; compare to result_hi
2158   068B 30 01               JR      NC,L068E        ; forward if less to NO-OVERFLW
2159   068D             
2160   068D 67                  LD      H,A             ; else maintain the overflow condition.
2161   068E             
2162   068E             ;; NO-OVRFLW
2163   068E 54          L068E:  LD      D,H             ; copy HL.
2164   068F 5D                  LD      E,L             ; to DE.
2165   0690 29                  ADD     HL,HL           ; double result
2166   0691 29                  ADD     HL,HL           ; and again.
2167   0692 19                  ADD     HL,DE           ; now * 5
2168   0693 29                  ADD     HL,HL           ; now *10
2169   0694 09                  ADD     HL,BC           ; add in new digit.
2170   0695             
2171   0695 D9                  EXX                     ; switch
2172   0696 DF                  RST     18H             ; NXT-CH-SP
2173   0697 D9                  EXX                     ; switch
2174   0698             
2175   0698 18 E5               JR      L067F           ; loop back to DEC-LP for more digits.
2176   069A             
2177   069A             ; -------------------------------------
2178   069A             ; THE 'STORE INTEGER RESULT' SUBROUTINE
2179   069A             ; -------------------------------------
2180   069A             
2181   069A             ;; STOR-RSLT
2182   069A 7C          L069A:  LD      A,H             ; transfer high byte to A.
2183   069B 22 22 40            LD      ($4022),HL      ; set value of expression RESULT
2184   069E D9                  EXX                     ; switch
2185   069F 17                  RLA                     ; sets carry if higher than 32767
2186   06A0 C9                  RET                     ; return.
2187   06A1             
2188   06A1             ; ------------------------------------------------
2189   06A1             ; THE 'REPORT AND LINE NUMBER PRINTING' SUBROUTINE
2190   06A1             ; ------------------------------------------------
2191   06A1             ; Actually the first entry point prints any number in the
2192   06A1             ; range -32768 to 32767.
2193   06A1             
2194   06A1             ; --> This entry point prints a number in BC.
2195   06A1             
2196   06A1             ;; OUT-NUM-1
2197   06A1 D5          L06A1:  PUSH    DE              ; preserve registers
2198   06A2 E5                  PUSH    HL              ; throughout
2199   06A3             
2200   06A3 60                  LD      H,B             ; transfer number
2201   06A4 69                  LD      L,C             ; to be printed to HL.
2202   06A5             
2203   06A5 CB 78               BIT     7,B             ; test the sign bit
2204   06A7 28 0C               JR      Z,L06B5         ; forward if positive to OUT-NUM-P
2205   06A9             
2206   06A9 3E 12               LD      A,$12           ; prepare character '-'
2207   06AB CD 59 05            CALL    L0559           ; routine OUT-SP-CH
2208   06AE             
2209   06AE 30 2D               JR      NC,L06DD        ; forward if out of screen to OUT-NUM-4
2210   06B0             
2211   06B0 21 01 00            LD      HL,$0001        ; else make the negative number
2212   06B3 ED 42               SBC     HL,BC           ; positive.
2213   06B5             
2214   06B5             ; at this stage the number is positive
2215   06B5             
2216   06B5             ;; OUT-NUM-P
2217   06B5 1E FF       L06B5:  LD      E,$FF           ; signal no leading space.
2218   06B7             
2219   06B7 01 F0 D8            LD      BC,$D8F0        ; prepare the value -10000
2220   06BA             
2221   06BA CD 4C 05            CALL    L054C           ; routine OUT-SP-NO will print the first digit
2222   06BD                                             ; of a 5-digit number but nothing if smaller.
2223   06BD             
2224   06BD 18 09               JR      L06C8           ; forward to OUT-NUM-3
2225   06BF                                             ; to consider other four digits in turn.
2226   06BF                                             ; (with carry set from a successful print)
2227   06BF             
2228   06BF             ; ---
2229   06BF             
2230   06BF             ; --> This entry point prints a BASIC line number addressed by HL.
2231   06BF             
2232   06BF             ;; OUT-NUM-2
2233   06BF D5          L06BF:  PUSH    DE              ; save DE throughout
2234   06C0 56                  LD      D,(HL)          ; fetch high byte of number to D
2235   06C1 23                  INC     HL
2236   06C2 5E                  LD      E,(HL)          ; fetch low byte of number to E
2237   06C3             
2238   06C3 E5                  PUSH    HL              ; save HL now till the end.
2239   06C4 EB                  EX      DE,HL           ; number to HL.
2240   06C5             
2241   06C5 1E 00               LD      E,$00           ; prepare a leading space
2242   06C7 37                  SCF                     ; set carry flag for subtractions.
2243   06C8             
2244   06C8             ; both paths converge here.
2245   06C8             
2246   06C8             ;; OUT-NUM-3
2247   06C8 01 18 FC    L06C8:  LD      BC,$FC18        ; the value -1000
2248   06CB DC 4C 05            CALL    C,L054C         ; routine OUT-SP-NO
2249   06CE             
2250   06CE 01 9C FF            LD      BC,$FF9C        ; the value -100
2251   06D1 DC 4C 05            CALL    C,L054C         ; routine OUT-SP-NO
2252   06D4             
2253   06D4 0E F6               LD      C,$F6           ; the value -10
2254   06D6 DC 4C 05            CALL    C,L054C         ; routine OUT-SP-NO
2255   06D9             
2256   06D9 7D                  LD      A,L             ; the remainder.
2257   06DA DC 56 05            CALL    C,L0556         ; routine OUT-CODE
2258   06DD             
2259   06DD             ;; OUT-NUM-4
2260   06DD E1          L06DD:  POP     HL              ; restore original
2261   06DE D1                  POP     DE              ; registers.
2262   06DF C9                  RET                     ; return.
2263   06E0             
2264   06E0             ; --------------------------
2265   06E0             ; THE 'UNSTACK-Z' SUBROUTINE
2266   06E0             ; --------------------------
2267   06E0             
2268   06E0             ;; UNSTACK-Z
2269   06E0 FD CB 01 7E L06E0:  BIT     7,(IY+$01)      ; test FLAGS - Checking Syntax ?
2270   06E4 E1                  POP     HL              ; drop the return address
2271   06E5 C8                  RET     Z               ; return if so.
2272   06E6             
2273   06E6             ; else fetch screen coordinates alternate registers for the run-time situation.
2274   06E6             
2275   06E6 D9                  EXX
2276   06E7 ED 5B 0E 40         LD      DE,($400E)      ; fetch display print position DF_EA
2277   06EB ED 4B 24 40         LD      BC,($4024)      ; fetch line and column from SPOSN
2278   06EF D9                  EXX                     ; exchange and continue...
2279   06F0             
2280   06F0             ; and jump back to the calling routine...
2281   06F0             
2282   06F0             ; ------------------
2283   06F0             ; THE 'USR' FUNCTION
2284   06F0             ; ------------------
2285   06F0             
2286   06F0             ;; USR
2287   06F0 E9          L06F0:  JP      (HL)            ; that appears to be it.
2288   06F1             
2289   06F1             ; ---------------------------
2290   06F1             ; THE 'PRINT ITEM' SUBROUTINE
2291   06F1             ; ---------------------------
2292   06F1             
2293   06F1             ;; PR-ITEM
2294   06F1 FD CB 00 7E L06F1:  BIT     7,(IY+$00)      ; ERR_NR
2295   06F5 C8                  RET     Z               ; return if an error has already been
2296   06F6                                             ; encountered.
2297   06F6             
2298   06F6 CD E0 06            CALL    L06E0           ; UNSTACK-Z quits if checking syntax
2299   06F9             
2300   06F9 2A 22 40            LD      HL,($4022)      ; fetch result of SCANNING from RESULT
2301   06FC FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS for result type.
2302   0700 28 0A               JR      Z,L070C         ; forward to PR-STRING if type string.
2303   0702             
2304   0702 44                  LD      B,H             ; transfer result
2305   0703 4D                  LD      C,L             ; to BC register pair.
2306   0704             
2307   0704 CD A1 06            CALL    L06A1           ; routine OUT-NUM-1
2308   0707 18 1A               JR      L0723           ; forward to PO-CHECK to check for
2309   0709                                             ; success and store position
2310   0709             
2311   0709             ; -----------------------------
2312   0709             ; THE 'PRINT STRING' SUBROUTINE
2313   0709             ; -----------------------------
2314   0709             
2315   0709             ;; PO-CHAR
2316   0709 D7          L0709:  RST     10H             ; PRINT-A
2317   070A             
2318   070A             ;; PO-LOOP
2319   070A 30 19       L070A:  JR      NC,L0725        ; forward to ERROR-05 with carry
2320   070C                                             ; Out of screen.
2321   070C             ; --> Entry Point.
2322   070C             
2323   070C             ;; PR-STRING
2324   070C 7E          L070C:  LD      A,(HL)          ; fetch a character.
2325   070D 23                  INC     HL              ; increment pointer.
2326   070E FE 01               CP      $01             ; is it null-terminator.
2327   0710 28 28               JR      Z,L073A         ; forward to PO-STORE if so.
2328   0712             
2329   0712 CB 77               BIT     6,A             ; test if simple character or inverse
2330   0714 28 F3               JR      Z,L0709         ; back to PO-CHAR if so
2331   0716             
2332   0716 CD 84 05            CALL    L0584           ; routine PO-TOKEN to print
2333   0719                                             ; ranges $40 - $7f, $0C - $FF
2334   0719 18 EF               JR      L070A           ; loop back to PO-LOOP
2335   071B             
2336   071B             ; --------------------------------
2337   071B             ; THE 'CARRIAGE RETURN' SUBROUTINE
2338   071B             ; --------------------------------
2339   071B             
2340   071B             ;; PRINT-CR
2341   071B CD E0 06    L071B:  CALL    L06E0           ; UNSTACK-Z quits if checking syntax
2342   071E             
2343   071E 3E 76               LD      A,$76           ; prepare a NEWLINE character
2344   0720 CD 59 05            CALL    L0559           ; routine OUT-SP-CH prints it
2345   0723                                             ; returning with carry reset if there
2346   0723                                             ; was no room on the screen.
2347   0723             
2348   0723             ;; PO-CHECK
2349   0723 38 15       L0723:  JR      C,L073A         ; forward to PO-STORE if OK
2350   0725             
2351   0725             ;; ERROR-05
2352   0725 CF          L0725:  RST     08H             ; ERROR restart
2353   0726 04                  DEFB    $04             ; No more room on screen.
2354   0727             
2355   0727             ; ------------------------
2356   0727             ; THE 'PO-FILL' SUBROUTINE
2357   0727             ; ------------------------
2358   0727             
2359   0727             ;; PO-FILL
2360   0727 CD E0 06    L0727:  CALL    L06E0           ; UNSTACK-Z return if checking syntax.
2361   072A             
2362   072A FD CB 01 C6         SET     0,(IY+$01)      ; signal no leading space.
2363   072E             
2364   072E             ;; PO-SPACE
2365   072E AF          L072E:  XOR     A               ; prepare a space
2366   072F D7                  RST     10H             ; PRINT-A outputs the character.
2367   0730 30 F3               JR      NC,L0725        ; back to ERROR-05 if out of screen
2368   0732             
2369   0732 D9                  EXX                     ;
2370   0733 79                  LD      A,C             ; get updated column
2371   0734 D9                  EXX                     ;
2372   0735             
2373   0735 3D                  DEC     A               ; decrement it.
2374   0736 E6 07               AND     $07             ; isolate values 0 - 7
2375   0738 20 F4               JR      NZ,L072E        ; back to PO-SPACE for more.
2376   073A             
2377   073A             ; -------------------------------
2378   073A             ; THE 'POSITION STORE' SUBROUTINE
2379   073A             ; -------------------------------
2380   073A             
2381   073A             ;; PO-STORE
2382   073A D9          L073A:  EXX                     ; switch in the set that maintains the print
2383   073B                                             ; positions in the registers.
2384   073B EB                  EX      DE,HL           ; switch print position to HL for easier coding.
2385   073C             
2386   073C             ;; PO-STOR-2
2387   073C ED 43 24 40 L073C:  LD      ($4024),BC      ; set SPOSN to line/column
2388   0740 22 0E 40            LD      ($400E),HL      ; set DF_EA to output address
2389   0743 22 10 40            LD      ($4010),HL      ; set DF_END output address
2390   0746 C9                  RET                     ; return.
2391   0747             
2392   0747             ; ----------------------------
2393   0747             ; THE 'CLS' COMMAND SUBROUTINE
2394   0747             ; ----------------------------
2395   0747             
2396   0747             ;; CLS
2397   0747 2A 0C 40    L0747:  LD      HL,($400C)      ; fetch start of display from D_FILE
2398   074A             
2399   074A 36 76               LD      (HL),$76        ; insert a single newline.
2400   074C 23                  INC     HL              ; advance address.
2401   074D             
2402   074D 01 21 17    L074D:  LD      BC,$1721        ; set line to 23 and column to 33.
2403   0750 18 EA               JR      L073C           ; back to PO-STOR-2 above
2404   0752             
2405   0752             ; -------------------
2406   0752             ; THE 'SYNTAX TABLES'
2407   0752             ; -------------------
2408   0752             
2409   0752             ;; i. The offset table
2410   0752             
2411   0752             
2412   0752 4F          L0752:  DEFB    L07A1 - $       ; $4F offset to $07A1 P-LIST
2413   0753 2C                  DEFB    L077F - $       ; $2C offset to $077F P-RETURN
2414   0754 64                  DEFB    L07B8 - $       ; $64 offset to $07B8 P-CLS
2415   0755 3F                  DEFB    L0794 - $       ; $3F offset to $0794 P-DIM
2416   0756 59                  DEFB    L07AF - $       ; $59 offset to $07AF P-SAVE
2417   0757 2B                  DEFB    L0782 - $       ; $2B offset to $0782 P-FOR
2418   0758 17                  DEFB    L076F - $       ; $17 offset to $076F P-GO-TO
2419   0759 4B                  DEFB    L07A4 - $       ; $4B offset to $07A4 P-POKE
2420   075A 36                  DEFB    L0790 - $       ; $36 offset to $0790 P-INPUT
2421   075B 4E                  DEFB    L07A9 - $       ; $4E offset to $07A9 P-RANDOMISE
2422   075C 10                  DEFB    L076C - $       ; $10 offset to $076C P-LET
2423   075D 5E                  DEFB    L07BB - $       ; $5E offset to $07BB P-CH-END
2424   075E 5D                  DEFB    L07BB - $       ; $5D offset to $07BB P-CH-END
2425   075F 2A                  DEFB    L0789 - $       ; $2A offset to $0789 P-NEXT
2426   0760 2D                  DEFB    L078D - $       ; $2D offset to $078D P-PRINT
2427   0761 5A                  DEFB    L07BB - $       ; $5A offset to $07BB P-CH-END
2428   0762 61                  DEFB    L07C2 + 1 - $   ; $61 offset to $07C3 P-NEW
2429   0763 3B                  DEFB    L079E - $       ; $3B offset to $079E P-RUN
2430   0764 18                  DEFB    L077C - $       ; $18 offset to $077C P-STOP
2431   0765 4D                  DEFB    L07B2 - $       ; $4D offset to $07B2 P-CONTINUE
2432   0766 0D                  DEFB    L0773 - $       ; $0D offset to $0773 P-IF
2433   0767 11                  DEFB    L0778 - $       ; $11 offset to $0778 P-GOSUB
2434   0768 44                  DEFB    L07AC - $       ; $44 offset to $07AC P-LOAD
2435   0769 4C                  DEFB    L07B5 - $       ; $4C offset to $07B5 P-CLEAR
2436   076A 31                  DEFB    L079B - $       ; $31 offset to $079B P-REM
2437   076B 50                  DEFB    L07BB - $       ; $50 offset to $07BB P-CH-END
2438   076C             
2439   076C             
2440   076C             ;; ii. The parameter table.
2441   076C             
2442   076C             ;; P-LET
2443   076C 01          L076C:  DEFB    $01             ; Class-01 - a variable is required.
2444   076D E3                  DEFB    $E3             ; separator '='
2445   076E 02                  DEFB    $02             ; Class-02 - an expression, of type integer or
2446   076F                                             ; string must follow.
2447   076F             
2448   076F             ;; P-GO-TO
2449   076F 06          L076F:  DEFB    $06             ; Class-06 - a numeric expression must follow.
2450   0770 00                  DEFB    $00             ; Class-00 - no further operands.
2451   0771 34 09               DEFW    L0934           ; address: $0934
2452   0773             
2453   0773             ;; P-IF
2454   0773 06          L0773:  DEFB    $06             ; Class-06 - a numeric expression must follow.
2455   0774 D5                  DEFB    $D5             ; separator 'THEN'
2456   0775 05                  DEFB    $05             ; Class-05 - variable syntax checked entirely
2457   0776                                             ; by routine.
2458   0776 B9 08               DEFW    L08B9           ; address: $08B9
2459   0778             
2460   0778             ;; P-GOSUB
2461   0778 06          L0778:  DEFB    $06             ; Class-06 - a numeric expression must follow.
2462   0779 00                  DEFB    $00             ; Class-00 - no further operands.
2463   077A 43 09               DEFW    L0943           ; address: $0943
2464   077C             
2465   077C             ;; P-STOP
2466   077C 00          L077C:  DEFB    $00             ; Class-00 - no further operands.
2467   077D 2E 09               DEFW    L092E           ; address: $092E
2468   077F             
2469   077F             ;; P-RETURN
2470   077F 00          L077F:  DEFB    $00             ; Class-00 - no further operands.
2471   0780 65 09               DEFW    L0965           ; address: $0965
2472   0782             
2473   0782             ;; P-FOR
2474   0782 04          L0782:  DEFB    $04             ; Class-04 - a single-character variable must
2475   0783                                             ; follow.
2476   0783 E3                  DEFB    $E3             ; separator '='
2477   0784 06                  DEFB    $06             ; Class-06 - a numeric expression must follow.
2478   0785 D6                  DEFB    $D6             ; separator 'TO'
2479   0786 05                  DEFB    $05             ; Class-05 - variable syntax checked entirely
2480   0787                                             ; by routine.
2481   0787 C4 08               DEFW    L08C4           ; address: $08C4
2482   0789             
2483   0789             ;; P-NEXT
2484   0789 04          L0789:  DEFB    $04             ; Class-04 - a single-character variable must
2485   078A                                             ; follow.
2486   078A 00                  DEFB    $00             ; Class-00 - no further operands.
2487   078B F9 08               DEFW    L08F9           ; address: $08F9
2488   078D             
2489   078D             ;; P-PRINT
2490   078D 05          L078D:  DEFB    $05             ; Class-05 - variable syntax checked entirely
2491   078E                                             ; by routine.
2492   078E 72 09               DEFW    L0972           ; address: $0972
2493   0790             
2494   0790             ;; P-INPUT
2495   0790 01          L0790:  DEFB    $01             ; Class-01 - a variable is required.
2496   0791 00                  DEFB    $00             ; Class-00 - no further operands.
2497   0792 9A 09               DEFW    L099A           ; address: $099A
2498   0794             
2499   0794             ;; P-DIM
2500   0794 04          L0794:  DEFB    $04             ; Class-04 - a single-character variable must
2501   0795                                             ; follow.
2502   0795 DA                  DEFB    $DA             ; separator '('
2503   0796 06                  DEFB    $06             ; Class-06 - a numeric expression must follow.
2504   0797 D9                  DEFB    $D9             ; separator ')'
2505   0798 00                  DEFB    $00             ; Class-00 - no further operands.
2506   0799 D3 0C               DEFW    L0CD3           ; address: $0CD3
2507   079B             
2508   079B             ;; P-REM
2509   079B 05          L079B:  DEFB    $05             ; Class-05 - variable syntax checked entirely
2510   079C                                             ; by routine.
2511   079C 4A 08               DEFW    L084A           ; address: $084A
2512   079E             
2513   079E             ;; P-RUN
2514   079E 03          L079E:  DEFB    $03             ; Class-03 - a numeric expression may follow
2515   079F                                             ; otherwise zero will be used.
2516   079F 3D 09               DEFW    L093D           ; address: $093D
2517   07A1             
2518   07A1             
2519   07A1             ;; P-LIST
2520   07A1 03          L07A1:  DEFB    $03             ; Class-03 - a numeric expression may follow
2521   07A2                                             ; else default to zero.
2522   07A2 56 02               DEFW    L0256           ; Address: $0256
2523   07A4             
2524   07A4             ;; P-POKE
2525   07A4 06          L07A4:  DEFB    $06             ; Class-06 - a numeric expression must follow.
2526   07A5 D8                  DEFB    $D8             ; separator ','
2527   07A6 05                  DEFB    $05             ; Class-05 - variable syntax checked entirely
2528   07A7                                             ; by routine.
2529   07A7 D1 09               DEFW    L09D1           ; address: $09D1
2530   07A9             
2531   07A9             ;; P-RANDOMISE
2532   07A9 03          L07A9:  DEFB    $03             ; Class-03 - a numeric expression may follow
2533   07AA                                             ; otherwise zero will be used.
2534   07AA 23 09               DEFW    L0923           ; address: $0923
2535   07AC             
2536   07AC             ;; P-LOAD
2537   07AC 00          L07AC:  DEFB    $00             ; Class-00 - no further operands.
2538   07AD                     ;DEFW    L0206           ; address: $0206
2539   07AD DC 10               DEFW    NEW_LOAD        ; address of new LOAD function
2540   07AF             
2541   07AF             ;; P-SAVE
2542   07AF 00          L07AF:  DEFB    $00             ; Class-00 - no further operands.
2543   07B0                     ;DEFW    L01B6           ; address: $01B6
2544   07B0 73 11               DEFW    NEW_SAVE        ; new save function
2545   07B2             
2546   07B2             ;; P-CONTINUE
2547   07B2 00          L07B2:  DEFB    $00             ; Class-00 - no further operands.
2548   07B3 30 09               DEFW    L0930           ; address: $0930
2549   07B5             
2550   07B5             ;; P-CLEAR
2551   07B5 00          L07B5:  DEFB    $00             ; Class-00 - no further operands.
2552   07B6 5B 06               DEFW    L065B           ; address: $065B
2553   07B8             
2554   07B8             
2555   07B8             ;; P-CLS
2556   07B8 00          L07B8:  DEFB    $00             ; Class-00 - no further operands.
2557   07B9 47 07               DEFW    L0747           ; Address: $0747
2558   07BB             
2559   07BB             ;; P-CH-END
2560   07BB 05          L07BB:  DEFB    $05             ; Class-05 - variable syntax checked entirely
2561   07BC                                             ; by routine.
2562   07BC 44 08               DEFW    L0844           ; address: $0844
2563   07BE             
2564   07BE             ; Note. one would expect the entry for the P-NEW parameters to be here.
2565   07BE             ; It should consist of a class 0, followed by the address word zero as,
2566   07BE             ; without any protected RAM, the NEW command is no more sophisticated than 
2567   07BE             ; a reset.
2568   07BE             ; However, there just isn't room. All 4096 bytes of the ROM have been
2569   07BE             ; put to good use so the required entry, three zero bytes, is embedded
2570   07BE             ; in the next routine, adding a harmless NOP to make up the three zero bytes.
2571   07BE             
2572   07BE             ; Aye, and you try telling young people of today that. And they won't
2573   07BE             ; believe you.
2574   07BE             
2575   07BE             ; ------------------------------
2576   07BE             
2577   07BE             ;; MAIN-G
2578   07BE 2B          L07BE:  DEC     HL
2579   07BF 22 26 40            LD      ($4026),HL      ; CH_ADD
2580   07C2             
2581   07C2             ;; P-NEW-1
2582   07C2 21 00 00    L07C2:  LD      HL,$0000        ; prepare to clear error pointer.
2583   07C5             
2584   07C5 00                  NOP                     ; Note. See comment above.
2585   07C6             
2586   07C6 22 15 40            LD      ($4015),HL      ; clear X_PTR
2587   07C9             
2588   07C9 21 19 40            LD      HL,$4019        ; address FLAGX
2589   07CC CB 6E               BIT     5,(HL)          ; is INPUT mode set ?
2590   07CE             
2591   07CE 28 07               JR      Z,L07D7         ; forward if not to E-LINE-NO
2592   07D0             
2593   07D0             ; else runtime input.
2594   07D0             
2595   07D0 CB BE               RES     7,(HL)          ; signal L mode.
2596   07D2             
2597   07D2 46                  LD      B,(HL)          ; FLAGX to B for class routine.
2598   07D3 DF                  RST     18H             ; NXT-CH-SP advances.
2599   07D4             
2600   07D4 C3 89 08            JP      L0889           ; jump forward to VAL-FETCH.
2601   07D7             
2602   07D7             ; -----------------------
2603   07D7             ; THE 'E-LINE-NO' SECTION
2604   07D7             ; -----------------------
2605   07D7             
2606   07D7             ;; E-LINE-NO
2607   07D7 CB FE       L07D7:  SET     7,(HL)          ; update FLAGX - signal K mode
2608   07D9             
2609   07D9 E7                  RST     20H             ; NEXT-CHAR
2610   07DA CD 79 06            CALL    L0679           ; routine INT-TO-HL puts the BASIC Line Number
2611   07DD                                             ; into HL'
2612   07DD             
2613   07DD 38 06               JR      C,L07E5         ; forward if a negative to insert error.
2614   07DF             
2615   07DF             ; else test against upper limit.
2616   07DF             
2617   07DF D9                  EXX                     ;
2618   07E0 11 F0 D8            LD      DE,$D8F0        ; value -9999
2619   07E3 19                  ADD     HL,DE           ;
2620   07E4 D9                  EXX                     ;
2621   07E5             
2622   07E5             ;; E-L-ERR
2623   07E5 DC AE 08    L07E5:  CALL    C,L08AE         ; routine INS-ERR if greater than 9999
2624   07E8             
2625   07E8             ; -----------------------
2626   07E8             ; THE 'LINE-SCAN' SECTION
2627   07E8             ; -----------------------
2628   07E8             
2629   07E8             ;; LINE-SCAN
2630   07E8 CD 1A 00    L07E8:  CALL    L001A           ; get the COMMAND CHARACTER.
2631   07EB             
2632   07EB FD CB 19 BE         RES     7,(IY+$19)      ; update FLAGX signal not K mode anymore.
2633   07EF             
2634   07EF 01 00 00            LD      BC,$0000        ; this also sets B to zero for later.
2635   07F2             
2636   07F2 ED 43 22 40         LD      ($4022),BC      ; default RESULT to ZERO
2637   07F6                                             ; for, say, RUN without an operand.
2638   07F6             
2639   07F6 FE 76               CP      $76             ; compare to just newline
2640   07F8 C8                  RET     Z               ; return if so.
2641   07F9                                             ; for example with a space for formatting.
2642   07F9             
2643   07F9 4F                  LD      C,A             ; transfer the character to C
2644   07FA E7                  RST     20H             ; NEXT_CHAR advances pointer
2645   07FB 79                  LD      A,C             ; fetch back character to A.
2646   07FC             
2647   07FC D6 E6               SUB     $E6             ; subtract lowest command 'LIST'
2648   07FE             
2649   07FE 38 E5               JR      C,L07E5         ; back if not a command to E-L-ERR
2650   0800                                             ; the loop will eventually find the newline
2651   0800                                             ; and the original error point will not be
2652   0800                                             ; altered.
2653   0800             
2654   0800 4F                  LD      C,A             ; place reduced character in C.
2655   0801             
2656   0801 21 52 07            LD      HL,L0752        ; set HL to offset table
2657   0804 09                  ADD     HL,BC           ; add the one-byte offset
2658   0805             
2659   0805 4E                  LD      C,(HL)          ; fetch the offset from table
2660   0806 09                  ADD     HL,BC           ; add to form address of parameters.
2661   0807 18 03               JR      L080C           ; forward to GET-PARAM
2662   0809             
2663   0809             ; ------------------------
2664   0809             ; THE 'MAIN SCANNING LOOP'
2665   0809             ; ------------------------
2666   0809             ; entered at GET-PARAM after first instruction.
2667   0809             
2668   0809             ;; SCAN-LOOP
2669   0809 2A 1A 40    L0809:  LD      HL,($401A)      ; T_ADDR
2670   080C             
2671   080C             ; -->  Entry Point.
2672   080C             
2673   080C             ;; GET-PARAM
2674   080C 7E          L080C:  LD      A,(HL)          ; get parameter from syntax table.
2675   080D 23                  INC     HL              ; point to next one.
2676   080E 22 1A 40            LD      ($401A),HL      ; initialize or update T_ADDR
2677   0811             
2678   0811 01 09 08            LD      BC,$0809        ; pre-load the machine stack with the
2679   0814 C5                  PUSH    BC              ; return address SCAN-LOOP above.
2680   0815             
2681   0815 4F                  LD      C,A             ; copy parameter entry to C for later.
2682   0816 17                  RLA                     ; test bit 7
2683   0817 38 0D               JR      C,L0826         ; forward to SEPARATOR if inverted.
2684   0819             
2685   0819 21 36 08            LD      HL,L0836        ; base address of command class table.
2686   081C 06 00               LD      B,$00           ; prepare to index.
2687   081E             
2688   081E 09                  ADD     HL,BC           ; add the command class 0 - 6
2689   081F 4E                  LD      C,(HL)          ; fetch the addressed byte to C
2690   0820             
2691   0820 09                  ADD     HL,BC           ; compute starting address of routine.
2692   0821             
2693   0821 E5                  PUSH    HL              ; push the address on the machine stack.
2694   0822             
2695   0822 CD 1A 00            CALL    L001A           ; routine GET-CHAR advances character position
2696   0825                                             ; and resets the zero flag - see later.
2697   0825             
2698   0825 C9                  RET                     ; >> an indirect jump to the COMMAND CLASS
2699   0826                                             ; routine.
2700   0826             
2701   0826                                             ; Note. HL addresses the next non-space
2702   0826                                             ; character e.g. the variable in LET I = 1
2703   0826                                             ; the non-space character is in A
2704   0826             
2705   0826             ; ----------------------
2706   0826             ; THE 'SEPARATOR' BRANCH
2707   0826             ; ----------------------
2708   0826             ; branch to here if the parameter has bit seven set.
2709   0826             
2710   0826             ;; SEPARATOR
2711   0826 CD 1A 00    L0826:  CALL    L001A           ; get character in A
2712   0829 FE D5               CP      $D5             ; compare to the token 'THEN'
2713   082B 20 04               JR      NZ,L0831        ; forward if another character to SEP-1.
2714   082D             
2715   082D FD CB 19 FE         SET     7,(IY+$19)      ; else update FLAGX back to K mode
2716   0831             
2717   0831             ;; SEP-1
2718   0831 B9          L0831:  CP      C               ; compare with expected token/character
2719   0832 20 7A               JR      NZ,L08AE        ; forward if no match to set X-PTR
2720   0834                                             ; using INS-ERR
2721   0834             
2722   0834 E7                  RST     20H             ; else step past a correct character.
2723   0835 C9                  RET                     ; return                >>
2724   0836                                             ; (to SCAN-LOOP)
2725   0836             
2726   0836             ; -------------------------
2727   0836             ; THE 'COMMAND CLASS' TABLE
2728   0836             ; -------------------------
2729   0836             
2730   0836             ;; TAB-CLASS
2731   0836 1F          L0836:  DEFB    L0855 - $       ; $1F offset to class-0 $0855
2732   0837 33                  DEFB    L086A - $       ; $33 offset to class-1 $086A
2733   0838 4D                  DEFB    L0885 - $       ; $4D offset to class-2 $0885
2734   0839 17                  DEFB    L0850 - $       ; $17 offset to class-3 $0850
2735   083A 64                  DEFB    L089E - $       ; $64 offset to class-4 $089E
2736   083B 1B                  DEFB    L0856 - $       ; $1B offset to class-5 $0856
2737   083C 6C                  DEFB    L08A8 - $       ; $6C offset to class-6 $08A8
2738   083D             
2739   083D             ; --------------------------
2740   083D             ; THE 'CHECK END' SUBROUTINE
2741   083D             ; --------------------------
2742   083D             
2743   083D             ;; CHECK-END
2744   083D FD CB 01 7E L083D:  BIT     7,(IY+$01)      ; check FLAGS - checking syntax ?
2745   0841 C0                  RET     NZ              ; return if running program.
2746   0842             
2747   0842 C1                  POP     BC              ; else drop the return address.
2748   0843             
2749   0843             ;; CH-END-2
2750   0843 7E          L0843:  LD      A,(HL)          ; fetch character from CH_ADD address
2751   0844             
2752   0844             ;; CH-END-3
2753   0844 FE 76       L0844:  CP      $76             ; compare to carriage return.
2754   0846             
2755   0846 C4 AE 08            CALL    NZ,L08AE        ; routine INS-ERR if not disturbing the 
2756   0849                                             ; accumulator.
2757   0849             
2758   0849             ;; SEE-BELOW
2759   0849 7E          L0849:  LD      A,(HL)          ; reload character again.
2760   084A                                             ; and continue...
2761   084A             
2762   084A             ; -------------------------
2763   084A             ; THE 'REM' COMMAND ROUTINE
2764   084A             ; -------------------------
2765   084A             ; The REM command compares each character until a newline is encountered.
2766   084A             ; However this is a class 5 routine so the initial accumulator value will
2767   084A             ; be zero (from the BC test) and not the character following REM.
2768   084A             ; A line consisting of a single REM will have the newline skipped and if no
2769   084A             ; $76 is encountered in the binary line number then the following line will
2770   084A             ; be skipped also as in
2771   084A             ; 10 REM
2772   084A             ; 20 PRINT "THIS IS NOT HERE"
2773   084A             ; The command address should be that of the previous instruction L0849 as the 
2774   084A             ; accumulator has been disturbed.
2775   084A             
2776   084A             ;; REM
2777   084A FE 76       L084A:  CP      $76             ; compare with newline.
2778   084C C8                  RET     Z               ; return with newline.
2779   084D             
2780   084D E7                  RST     20H             ; NEXT-CHAR
2781   084E 18 FA               JR      L084A           ; loop back to REM until newline found.
2782   0850             
2783   0850             ; -----------------------------------
2784   0850             ; THE 'COMMAND CLASSES - 00, 03 & 05'
2785   0850             ; -----------------------------------
2786   0850             ; these three commands always terminate a sequence of parameters and
2787   0850             ; are followed by the address of a routine.
2788   0850             
2789   0850             ;; CLASS-03
2790   0850 FE 76       L0850:  CP      $76             ; check for carriage return
2791   0852 C4 A8 08            CALL    NZ,L08A8        ; else look for optional number using CLASS-06
2792   0855                                             ; e.g. RUN & RUN 100
2793   0855                                             ; return and continue through other two classes.
2794   0855             
2795   0855             ;; CLASS-00
2796   0855 BF          L0855:  CP      A               ; set the zero flag to invoke CHECK-END later.
2797   0856                                             ; this class has no operands e.g. CONTINUE.
2798   0856             
2799   0856             ;; CLASS-05
2800   0856 C1          L0856:  POP     BC              ; drop the looping address - last in sequence.
2801   0857             
2802   0857 CC 3D 08            CALL    Z,L083D         ; routine CHECK-END if zero flag set.
2803   085A                                             ; (classes 03 and 00)
2804   085A             
2805   085A EB                  EX      DE,HL           ; save HL in DE (original CH_ADD)
2806   085B             
2807   085B 2A 1A 40            LD      HL,($401A)      ; fetch table address from T_ADDR
2808   085E             
2809   085E 4E                  LD      C,(HL)          ; low byte to C
2810   085F 23                  INC     HL              ;
2811   0860 46                  LD      B,(HL)          ; high byte to B
2812   0861             
2813   0861 EB                  EX      DE,HL           ; bring back the original character address
2814   0862             
2815   0862             ;; JUMP-BC
2816   0862 C5          L0862:  PUSH    BC              ; push routine address on machine stack
2817   0863 ED 4B 22 40         LD      BC,($4022)      ; load value of last expression from RESULT
2818   0867 78                  LD      A,B             ; test the value
2819   0868 B1                  OR      C               ; for zero.
2820   0869 C9                  RET                     ; jump to the command routine.
2821   086A                                             ; with HL pointing at original CH_ADD
2822   086A                                             ; DE pointing to T_ADDR
2823   086A                                             ; BC holding parameter
2824   086A             
2825   086A             ; ---------------------------------------
2826   086A             ; THE 'COMMAND CLASSES - 01, 02, 04 & 06'
2827   086A             ; ---------------------------------------
2828   086A             
2829   086A             ; the first routine is for LET or INPUT.
2830   086A             
2831   086A             ;; CLASS-01
2832   086A CD 14 0D    L086A:  CALL    L0D14           ; routine ALPHA tests the character.
2833   086D 30 3F               JR      NC,L08AE        ; forward to INS-ERR if character not A-Z.
2834   086F             
2835   086F FD CB 01 7E         BIT     7,(IY+$01)      ; test FLAGS - the syntax bit.
2836   0873 CA AD 0A            JP      Z,L0AAD         ; jump forward to LOOK-VARS if checking syntax.
2837   0876             
2838   0876             ; continue in runtime
2839   0876             
2840   0876 22 20 40            LD      ($4020),HL      ; save address of destination variable
2841   0879                                             ; in BASIC line in DEST system variable.
2842   0879             
2843   0879 FD CB 01 BE         RES     7,(IY+$01)      ; signal to FLAGS that syntax is being checked.
2844   087D             
2845   087D CD AD 0A            CALL    L0AAD           ; routine LOOK-VARS.
2846   0880             
2847   0880 FD CB 01 FE         SET     7,(IY+$01)      ; set FLAGS back to 'running program' status.
2848   0884 C9                  RET                     ; return     (to SCAN-LOOP).
2849   0885             
2850   0885             ; ------------------------------
2851   0885             
2852   0885             ; used only for LET - an expression of the correct type must be present.
2853   0885             
2854   0885             ;; CLASS-02
2855   0885 C1          L0885:  POP     BC              ; drop the looping address as CLASS-02 is the
2856   0886                                             ; last in a sequence of parameters. It is
2857   0886                                             ; relevant only to the LET command.
2858   0886             
2859   0886 FD 46 01            LD      B,(IY+$01)      ; load B with value of FLAGS.
2860   0889             
2861   0889             ; (runtime input joins here with FLAGX in B instead of FLAGS)
2862   0889             
2863   0889             ; ---------------------------
2864   0889             ; THE 'FETCH A VALUE' SECTION
2865   0889             ; ---------------------------
2866   0889             
2867   0889             ;; VAL-FETCH
2868   0889 C5          L0889:  PUSH    BC              ; preserve value of FLAGS (or FLAGX if input)
2869   088A EF                  RST     28H             ; SCAN-CALC evaluates the expression
2870   088B                                             ; to be assigned setting the result type flag.
2871   088B D1                  POP     DE              ; restore the pre-evaluation copy of the
2872   088C                                             ; flag register to D.
2873   088C             
2874   088C 01 3D 0C            LD      BC,L0C3D        ; the address of the LET routine is pushed on
2875   088F                                             ; the machine stack.
2876   088F             
2877   088F 3A 01 40            LD      A,($4001)       ; fetch the post-evaluation FLAGS to A
2878   0892 CB 7F               BIT     7,A             ; test the syntax bit.
2879   0894 20 CC               JR      NZ,L0862        ; back in runtime to JUMP-BC and then LET
2880   0896             
2881   0896             ; if checking syntax.
2882   0896             
2883   0896 AA                  XOR     D               ; exclusive or the two flags
2884   0897 E6 40               AND     $40             ; AND 01000000 to isolate the type bit.
2885   0899             
2886   0899 C4 AE 08            CALL    NZ,L08AE        ; routine INS-ERR inserts the error position
2887   089C                                             ; when they are not the same type.
2888   089C             
2889   089C 18 A5               JR      L0843           ; back to CH-END-2 to consider lesser errors
2890   089E                                             ; and advance to end of line.
2891   089E             
2892   089E             ; ------------------------------
2893   089E             
2894   089E             ; FOR, NEXT, DIM - HL points to variable in BASIC line, A holds the character
2895   089E             
2896   089E             ;; CLASS-04
2897   089E 22 20 40    L089E:  LD      ($4020),HL      ; set system variable DEST from HL.
2898   08A1             
2899   08A1 CD 14 0D            CALL    L0D14           ; routine ALPHA checks the character.
2900   08A4             
2901   08A4 30 08               JR      NC,L08AE        ; forward to INS-ERR if not A-Z.
2902   08A6             
2903   08A6 DF                  RST     18H             ; NXT-CH-SP advances character address.
2904   08A7             
2905   08A7 C9                  RET                     ; return to SCAN-LOOP >>
2906   08A8             
2907   08A8             ; ------------------------------
2908   08A8             
2909   08A8             ; a mandatory INTEGER expression must follow. e.g. GO TO 100
2910   08A8             
2911   08A8             ;; CLASS-06
2912   08A8 EF          L08A8:  RST     28H             ; SCAN-CALC evaluates expression.
2913   08A9 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS - numeric result ?
2914   08AD C0                  RET     NZ              ; return if numeric.
2915   08AE             
2916   08AE             ; -----------------------------
2917   08AE             ; THE 'INSERT ERROR' SUBROUTINE
2918   08AE             ; -----------------------------
2919   08AE             
2920   08AE             ;; INS-ERR
2921   08AE 3A 15 40    L08AE:  LD      A,($4015)       ; check that error pointer X_PTR
2922   08B1 FD B6 16            OR      (IY+$16)        ; contains zero.
2923   08B4 C0                  RET     NZ              ; return if there is already an error
2924   08B5             
2925   08B5 22 15 40            LD      ($4015),HL      ; else place error address at X-PTR
2926   08B8 C9                  RET                     ; return.
2927   08B9             
2928   08B9             ; ------------------------
2929   08B9             ; THE 'IF' COMMAND ROUTINE
2930   08B9             ; ------------------------
2931   08B9             
2932   08B9             ;; IF
2933   08B9 20 06       L08B9:  JR      NZ,L08C1        ; if expression is TRUE forward to IF-1
2934   08BB             
2935   08BB FD CB 01 7E         BIT     7,(IY+$01)      ; test FLAGS - checking syntax ?
2936   08BF 20 89               JR      NZ,L084A        ; back to REM to ignore rest of the line
2937   08C1                                             ; in runtime.
2938   08C1             
2939   08C1             ; - else continue and check the syntax of the rest of the line.
2940   08C1             
2941   08C1             ;; IF-1
2942   08C1 C3 E8 07    L08C1:  JP      L07E8           ; jump back to LINE-SCAN to execute what
2943   08C4                                             ; follows the 'THEN'
2944   08C4             
2945   08C4             ; -------------------------
2946   08C4             ; THE 'FOR' COMMAND ROUTINE
2947   08C4             ; -------------------------
2948   08C4             ; for example, FOR X = 1 TO 10
2949   08C4             ; There is no step or direction.
2950   08C4             ; The body of the loop is always entered at least once - even if the initial
2951   08C4             ; value exceeds the limit.
2952   08C4             ; The ZX81 and ZX Spectrum adhered more closely to the ANS X3.60 1978 BASIC 
2953   08C4             ; standard.
2954   08C4             
2955   08C4             ;; FOR
2956   08C4 C5          L08C4:  PUSH    BC              ; save the start value.
2957   08C5             
2958   08C5 CD A8 08            CALL    L08A8           ; routine CLASS-06 evaluates LIMIT
2959   08C8                                             ; expression.
2960   08C8             
2961   08C8 C1                  POP     BC              ; start value back to BC
2962   08C9             
2963   08C9 CD 3D 08            CALL    L083D           ; routine CHECK-END quits if checking
2964   08CC                                             ; syntax                        >>
2965   08CC 2A 22 40            LD      HL,($4022)      ; fetch limit from RESULT
2966   08CF E5                  PUSH    HL              ; save limit
2967   08D0             
2968   08D0 CD 3D 0C            CALL    L0C3D           ; routine LET
2969   08D3             
2970   08D3 C1                  POP     BC              ; restore limit to BC
2971   08D4 FD CB 00 7E         BIT     7,(IY+$00)      ; examine ERR_NR
2972   08D8 C8                  RET     Z               ; return if not $FF             >>
2973   08D9             
2974   08D9 C5                  PUSH    BC              ; push the limit value.
2975   08DA 2B                  DEC     HL              ; point to letter.
2976   08DB CB 7E               BIT     7,(HL)          ; test bit 7 - is it a FOR-NEXT variable.
2977   08DD CB FE               SET     7,(HL)          ; set bit 7 as it is going to be.
2978   08DF             
2979   08DF 23                  INC     HL              ; point to end of value
2980   08E0 23                  INC     HL
2981   08E1 20 07               JR      NZ,L08EA        ; skip forward if it is a proper
2982   08E3                                             ; for/next variable to FOR-2
2983   08E3             
2984   08E3 01 04 00            LD      BC,$0004        ; else an extra 4 bytes are needed.
2985   08E6 23                  INC     HL              ; point to start of new space.
2986   08E7             
2987   08E7 CD D5 05            CALL    L05D5           ; routine MAKE-ROOM creates it.
2988   08EA                                             ; HL - first, DE- last
2989   08EA             
2990   08EA             ;; FOR-2
2991   08EA 23          L08EA:  INC     HL              ; address limit location
2992   08EB D1                  POP     DE              ; retrieve limit value to DE.
2993   08EC 73                  LD      (HL),E          ; insert low byte of limit.
2994   08ED 23                  INC     HL
2995   08EE 72                  LD      (HL),D          ; and then the high byte
2996   08EF             
2997   08EF 23                  INC     HL              ; point to the looping line cell.
2998   08F0 ED 5B 02 40         LD      DE,($4002)      ; load DE with the current line from PPC
2999   08F4 13                  INC     DE              ; increment as iteration will start from the
3000   08F5                                             ; next line at least.
3001   08F5             
3002   08F5 73                  LD      (HL),E          ; insert low byte of line number.
3003   08F6 23                  INC     HL
3004   08F7 72                  LD      (HL),D          ; insert high byte of line number.
3005   08F8 C9                  RET                     ; return.
3006   08F9             
3007   08F9             ; --------------------------
3008   08F9             ; THE 'NEXT' COMMAND ROUTINE
3009   08F9             ; --------------------------
3010   08F9             
3011   08F9             ;; NEXT
3012   08F9 2A 20 40    L08F9:  LD      HL,($4020)      ; fetch address of variable in BASIC from DEST.
3013   08FC             
3014   08FC CD 3B 0B            CALL    L0B3B           ; routine LV-FIND finds the equivalent in the
3015   08FF                                             ; variables area and returns the value in HL.
3016   08FF FD CB 00 7E         BIT     7,(IY+$00)      ; test ERR_NR
3017   0903 C8                  RET     Z               ; return with error.
3018   0904                                             ; will be 02 - variable not found.
3019   0904             
3020   0904             ; continue if LV-FIND found the variable - HL contains the value, DE points
3021   0904             ; to the high byte of value location.
3022   0904             
3023   0904 EB                  EX      DE,HL           ; value to DE, address to HL
3024   0905 2B                  DEC     HL              ; point to low byte
3025   0906 2B                  DEC     HL              ; point to the variable letter.
3026   0907 CB 7E               BIT     7,(HL)          ; - should have letter mask 111xxxxx
3027   0909             
3028   0909 28 16               JR      Z,L0921         ; forward to ERROR-01 if not initialized by FOR.
3029   090B                                             ; - NEXT without FOR.
3030   090B             
3031   090B 13                  INC     DE              ; increment the integer value
3032   090C                                             ; no step or direction possible.
3033   090C 23                  INC     HL              ; address first location
3034   090D 73                  LD      (HL),E          ; store low byte of value.
3035   090E 23                  INC     HL              ; next
3036   090F 72                  LD      (HL),D          ; store high byte of value.
3037   0910 23                  INC     HL              ;
3038   0911 4E                  LD      C,(HL)          ; pick up limit low
3039   0912 23                  INC     HL              ;
3040   0913 46                  LD      B,(HL)          ; and limit high.
3041   0914 C5                  PUSH    BC              ; save limit.
3042   0915 E3                  EX      (SP),HL         ; limit to HL, pointer to stack.
3043   0916             
3044   0916 CD CD 0D            CALL    L0DCD           ; routine no-less compares HL DE
3045   0919                                             ; setting carry if HL is less.
3046   0919             
3047   0919 E1                  POP     HL              ; retrieve the pointer from the stack.
3048   091A D8                  RET     C               ; return if no more iterations possible  >>
3049   091B             
3050   091B 23                  INC     HL              ; else address next location.
3051   091C 4E                  LD      C,(HL)          ; pick up low byte of line number
3052   091D 23                  INC     HL              ; address next
3053   091E 46                  LD      B,(HL)          ; pick up high byte of looping line.
3054   091F             
3055   091F 18 13               JR      L0934           ; jump to GOTO to perform another
3056   0921                                             ; iteration
3057   0921             
3058   0921             ; ---
3059   0921             
3060   0921             ;; ERROR-01
3061   0921 CF          L0921:  RST     08H             ; ERROR restart
3062   0922 00                  DEFB    $00             ; NEXT without FOR
3063   0923             
3064   0923             ; -------------------------------
3065   0923             ; THE 'RANDOMISE' COMMAND ROUTINE
3066   0923             ; -------------------------------
3067   0923             ; This command sets the seed to the supplied integer -32767 to 32767.
3068   0923             ; In the absence of a parameter the FRAMES counter, related to the time
3069   0923             ; the computer has been switched on, is used.
3070   0923             
3071   0923             ;; RANDOMISE
3072   0923 20 04       L0923:  JR      NZ,L0929        ; forward to RAND-1 if parameter is
3073   0925                                             ; not zero.
3074   0925             
3075   0925 ED 4B 1E 40         LD      BC,($401E)      ; else use value of system variable FRAMES.
3076   0929             
3077   0929             ;; RAND-1
3078   0929 ED 43 1C 40 L0929:  LD      ($401C),BC      ; insert value in system variable SEED.
3079   092D C9                  RET                     ; return.
3080   092E             
3081   092E             ; --------------------------
3082   092E             ; THE 'STOP' COMMAND ROUTINE
3083   092E             ; --------------------------
3084   092E             
3085   092E             ;; STOP
3086   092E             ;; ERROR-9
3087   092E CF          L092E:  RST     08H             ; ERROR restart
3088   092F 08                  DEFB    $08             ; - STOP statement executed.
3089   0930             
3090   0930             ; ------------------------------
3091   0930             ; THE 'CONTINUE' COMMAND ROUTINE
3092   0930             ; ------------------------------
3093   0930             
3094   0930             ;; CONTINUE
3095   0930 ED 4B 17 40 L0930:  LD      BC,($4017)      ; fetch continuing line number from OLDPPC
3096   0934                                             ; and continue into GOTO routine.
3097   0934             
3098   0934             ; ---------------------------
3099   0934             ; THE 'GO TO' COMMAND ROUTINE
3100   0934             ; ---------------------------
3101   0934             
3102   0934             ;; GOTO
3103   0934 ED 43 02 40 L0934:  LD      ($4002),BC      ; set PPC to supplied line number.
3104   0938 FD CB 01 DE         SET     3,(IY+$01)      ; update FLAGS - use K cursor.
3105   093C C9                  RET                     ; return.
3106   093D             
3107   093D             ; -------------------------
3108   093D             ; THE 'RUN' COMMAND ROUTINE
3109   093D             ; -------------------------
3110   093D             ; The RUN command may have an optional line number that will be passed to
3111   093D             ; the GOTO routine before erasing any variables and executing the line
3112   093D             ; (or first line after zero).
3113   093D             
3114   093D             ;; RUN
3115   093D CD 34 09    L093D:  CALL    L0934           ; routine GOTO sets up any supplied line number.
3116   0940                     ;JP      MISTS_OF_TIME   ; put up mists of time, then jump to clear 
3117   0940 C3 5B 06            JP      L065B           ; exit via CLEAR to erase variables.
3118   0943                     
3119   0943             ; ----------------------------
3120   0943             ; THE 'GO SUB' COMMAND ROUTINE
3121   0943             ; ----------------------------
3122   0943             
3123   0943             ;; GOSUB
3124   0943 2A 02 40    L0943:  LD      HL,($4002)      ; fetch current line from PPC
3125   0946 23                  INC     HL              ; increment the line number
3126   0947 E3                  EX      (SP),HL         ; place on machine stack
3127   0948                                             ;
3128   0948 E5                  PUSH    HL              ; push what was on the stack back up there.
3129   0949 CD 34 09            CALL    L0934           ; routine GOTO sets up a branch to the line
3130   094C                                             ; number.
3131   094C 01 06 00            LD      BC,$0006        ; and exit by a six-byte memory check.
3132   094F             
3133   094F             ; --------------------------
3134   094F             ; THE 'TEST ROOM' SUBROUTINE
3135   094F             ; --------------------------
3136   094F             ; The ZX80 dates from the days when RAM chips cost a fortune and it came with
3137   094F             ; only 1K of RAM, 1024 bytes.
3138   094F             ; The screen could show 768 characters and to economize it is dynamic and
3139   094F             ; initialized to a single newline ($76) by CLS. The TEST-ROOM routine has to
3140   094F             ; allow for enough newlines to expand down to the bottom line and a few extra
3141   094F             ; for the report codes "0/9999".
3142   094F             ; The second entry point is from PRINT-A and the character is similarly
3143   094F             ; in H and the line number in L.
3144   094F             
3145   094F             ;; TEST-ROOM
3146   094F 2A 10 40    L094F:  LD      HL,($4010)      ; fetch DF_END last location before
3147   0952                                             ; spare memory.
3148   0952 09                  ADD     HL,BC           ; add the supplied overhead.
3149   0953 EB                  EX      DE,HL           ; save the result in DE.
3150   0954             
3151   0954 2A 25 40            LD      HL,($4025)      ; SPOSN-Y to L gives 24 - number
3152   0957                                             ; of screen lines used so far.
3153   0957 67                  LD      H,A             ; preserve the accumulator in H
3154   0958             
3155   0958             ;; TEST-RM-2
3156   0958 3E 13       L0958:  LD      A,$13           ; load A with 19
3157   095A 85                  ADD     A,L             ; add to L to give the number of bytes
3158   095B                                             ; required to fill rest of screen with
3159   095B                                             ; newlines - plus a bit extra.
3160   095B 6F                  LD      L,A             ; put result in L.
3161   095C 7C                  LD      A,H             ; restore the accumulator.
3162   095D 26 00               LD      H,$00           ; set H to zero.
3163   095F 19                  ADD     HL,DE           ; add this extra screen allowance
3164   0960                                             ; to the previous result.
3165   0960 ED 72               SBC     HL,SP           ; subtract the stack pointer.
3166   0962 D8                  RET     C               ; return if the stack pointer is
3167   0963                                             ; above the estimate. All is well.
3168   0963             
3169   0963             ;
3170   0963             
3171   0963             ;; ERROR-4
3172   0963 CF          L0963:  RST     08H             ; ERROR restart
3173   0964 03                  DEFB    $03             ; No room
3174   0965             
3175   0965             ; ----------------------------
3176   0965             ; THE 'RETURN' COMMAND ROUTINE
3177   0965             ; ----------------------------
3178   0965             ; As with all commands, there is only one value on the machine stack during
3179   0965             ; command execution. This is the return address.
3180   0965             ; Above the machine stack is the gosub stack that contains a line number
3181   0965             ; (only one statement per line).
3182   0965             
3183   0965             ;; RETURN
3184   0965 E1          L0965:  POP     HL              ; drop the return address clearing the stack.
3185   0966 C1                  POP     BC              ; drop a line number off the gosub stack.
3186   0967 E5                  PUSH    HL              ; restore the machine stack.
3187   0968             
3188   0968 78                  LD      A,B             ; test high byte of line number.
3189   0969 FE 3F               CP      $3F             ; against the gosub stack end-marker.
3190   096B 20 C7               JR      NZ,L0934        ; back to GOTO if a valid line number.
3191   096D             
3192   096D E1                  POP     HL              ; else collapse the machine stack.
3193   096E C5                  PUSH    BC              ; push the end-marker.
3194   096F E5                  PUSH    HL              ; restore the machine stack.
3195   0970             
3196   0970             ;; ERROR-07
3197   0970 CF                  RST     08H             ; ERROR restart
3198   0971 06                  DEFB    $06             ; RETURN with no corresponding GO SUB.
3199   0972             
3200   0972             ; ---------------------------
3201   0972             ; THE 'PRINT' COMMAND ROUTINE
3202   0972             ; ---------------------------
3203   0972             
3204   0972             ;; PRINT
3205   0972 7E          L0972:  LD      A,(HL)          ; fetch the character
3206   0973 FE 76               CP      $76             ; compare to NEWLINE
3207   0975 CA 1B 07            JP      Z,L071B         ; back to PRINT-CR if so.
3208   0978             
3209   0978             ;; PR-POSN-1
3210   0978 D6 D8       L0978:  SUB     $D8             ; subtract ','
3211   097A                                             ; (';' gives -1 and carry set)
3212   097A             
3213   097A CE 00               ADC     A,$00           ; convert the two separators to zero.
3214   097C 28 13               JR      Z,L0991         ; forward to PR-POSN-2 with ';' and ','
3215   097E             
3216   097E EF                  RST     28H             ; else SCAN-CALC evaluates expression.
3217   097F CD F1 06            CALL    L06F1           ; routine PRINT-ITEM prints it.
3218   0982 CD 1A 00            CALL    L001A           ; routine GET-CHAR gets following character.
3219   0985             
3220   0985 D6 D8               SUB     $D8             ; compare with ',' and test for
3221   0987 CE 00               ADC     A,$00           ; terminating separators.
3222   0989 28 06               JR      Z,L0991         ; forward to PR-POSN-2 with ';' and ','
3223   098B             
3224   098B CD 3D 08            CALL    L083D           ; routine CHECK-END errors with anything else.
3225   098E C3 1B 07            JP      L071B           ; jump to PRINT-CR for carriage return.
3226   0991             
3227   0991             ; ---
3228   0991             
3229   0991             
3230   0991             ;; PR-POSN-2
3231   0991 D4 27 07    L0991:  CALL    NC,L0727        ; routine PO-FILL if comma control.
3232   0994             
3233   0994 E7                  RST     20H             ; NEXT-CHAR
3234   0995 FE 76               CP      $76             ; compare to NEWLINE
3235   0997 C8                  RET     Z               ; return if so leaving print position
3236   0998                                             ; unchanged.
3237   0998             
3238   0998 18 DE               JR      L0978           ; else loop back to PR-POSN-1 to consider
3239   099A                                             ; more sequences of positional
3240   099A                                             ; controls and print items.
3241   099A             
3242   099A             ; ---------------------------
3243   099A             ; THE 'INPUT' COMMAND ROUTINE
3244   099A             ; ---------------------------
3245   099A             
3246   099A             ; INPUT must be used from a running program. It is not available as a
3247   099A             ; direct command.
3248   099A             
3249   099A             ;; INPUT
3250   099A FD CB 03 7E L099A:  BIT     7,(IY+$03)      ; test PPC_hi - will be -2 if a direct command
3251   099E 20 2F               JR      NZ,L09CF        ; forward if so, to ERROR-08
3252   09A0             
3253   09A0 E1                  POP     HL              ; discard return address - L0447
3254   09A1             
3255   09A1 21 19 40            LD      HL,$4019        ; point to FLAGX
3256   09A4             
3257   09A4 CB EE               SET     5,(HL)          ; signal input
3258   09A6 CB B6               RES     6,(HL)          ;           reset so as not to affect combine
3259   09A8             
3260   09A8 3A 01 40            LD      A,($4001)       ; fetch FLAGS to A
3261   09AB             
3262   09AB E6 40               AND     $40             ; isolate bit 6 - the result type
3263   09AD             
3264   09AD 01 02 00            LD      BC,$0002        ; allow two locations for numeric.
3265   09B0             
3266   09B0 20 02               JR      NZ,L09B4        ; skip forward to IN-PR-1 if numeric.
3267   09B2             
3268   09B2 0E 04               LD      C,$04           ; allow two extra spaces for quotes.
3269   09B4             
3270   09B4             ;; IN-PR-1
3271   09B4 B6          L09B4:  OR      (HL)            ; combine FLAG bit with FLAGX.
3272   09B5 77                  LD      (HL),A          ; and place result in FLAGS.
3273   09B6             
3274   09B6 F7                  RST     30H             ; BC-SPACES creates 2/4 locations.
3275   09B7 D0                  RET     NC              ; return with problems.
3276   09B8             
3277   09B8 36 76               LD      (HL),$76        ; insert a newline at end.
3278   09BA             
3279   09BA 79                  LD      A,C             ; now test C - 2 (num) 4 (str).
3280   09BB 0F                  RRCA                    ;              1       2
3281   09BC 0F                  RRCA                    ;              carry   1
3282   09BD 38 03               JR      C,L09C2         ; skip forward with numeric to IN-PR-3
3283   09BF             
3284   09BF 12                  LD      (DE),A          ; insert initial quote (chr$ 1) at DE
3285   09C0 2B                  DEC     HL              ; decrease HL pointer
3286   09C1 77                  LD      (HL),A          ; insert closing quote.
3287   09C2             
3288   09C2             ;; IN-PR-3
3289   09C2 2B          L09C2:  DEC     HL              ; decrease pointer
3290   09C3 36 B0               LD      (HL),$B0        ; insert cursor inverse 'K'
3291   09C5             
3292   09C5 3A 25 40            LD      A,($4025)       ; SPOSN-Y
3293   09C8 3C                  INC     A               ; allow a blank line
3294   09C9 32 12 40            LD      ($4012),A       ; set DF-SZ
3295   09CC             
3296   09CC C3 F7 02            JP      L02F7           ; jump back to ED-COPY
3297   09CF             
3298   09CF             ; ---
3299   09CF             
3300   09CF             ;; ERROR-08
3301   09CF CF          L09CF:  RST     08H             ; ERROR restart
3302   09D0 07                  DEFB    $07             ; INPUT can only be used in a program.
3303   09D1             
3304   09D1             ; --------------------------
3305   09D1             ; THE 'POKE' COMMAND ROUTINE
3306   09D1             ; --------------------------
3307   09D1             
3308   09D1             ;; POKE
3309   09D1 C5          L09D1:  PUSH    BC              ; save result of first expression.
3310   09D2 EF                  RST     28H             ; use SCAN-CALC to evaluate expression
3311   09D3                                             ; after the comma.
3312   09D3             
3313   09D3 D1                  POP     DE              ; restore destination address.
3314   09D4 CD 3D 08            CALL    L083D           ; routine CHECK-END
3315   09D7 3A 22 40            LD      A,($4022)       ; RESULT
3316   09DA FD CB 00 7E         BIT     7,(IY+$00)      ; ERR_NR
3317   09DE C8                  RET     Z               ; return if error
3318   09DF             
3319   09DF 12                  LD      (DE),A          ; load memory location with A
3320   09E0 C9                  RET                     ; return
3321   09E1             
3322   09E1             ; ----------------------
3323   09E1             ; THE 'SCANNING' ROUTINE
3324   09E1             ; ----------------------
3325   09E1             ; The scanning routine is a continuation of RST 28.
3326   09E1             ; The B register has been set to zero as a starting priority.
3327   09E1             ; The HL register contains the character address CH_ADD.
3328   09E1             ; The addressed character is in A.
3329   09E1             
3330   09E1             ;; SCANNING
3331   09E1 48          L09E1:  LD      C,B             ; make BC zero - the starting priority
3332   09E2                                             ; marker.
3333   09E2 C5                  PUSH    BC              ; save on machine stack.
3334   09E3             
3335   09E3             ;; S-LOOP-1
3336   09E3 CD 18 0D    L09E3:  CALL    L0D18           ; routine ALPHANUM
3337   09E6 38 3C               JR      C,L0A24         ; forward if a variable or digit. to S-VAR-NUM
3338   09E8             
3339   09E8             ; now consider negate (-) and perform '$0000 - value' if so.
3340   09E8             
3341   09E8 01 00 09            LD      BC,$0900        ; prepare priority $09, operation 'subtract'
3342   09EB 51                  LD      D,C             ; set DE to $0000 for value to be stacked.
3343   09EC 59                  LD      E,C             ;
3344   09ED D6 DC               SUB     $DC             ; subtract the character '-'
3345   09EF 28 26               JR      Z,L0A17         ; forward with unary minus to S-PUSH-PO
3346   09F1             
3347   09F1             ; now consider 'not' and perform $FFFF - value if so.
3348   09F1             
3349   09F1 1B                  DEC     DE              ; set DE to $FFFF for value to be stacked.
3350   09F2 06 04               LD      B,$04           ; prepare priority 4, operation still 'subtract'
3351   09F4 3C                  INC     A               ; test for 'NOT' ?
3352   09F5 28 20               JR      Z,L0A17         ; forward with NOT to S-PUSH-PO
3353   09F7             
3354   09F7             ; now consider an opening bracket.
3355   09F7             
3356   09F7 3C                  INC     A               ; test the character.
3357   09F8 28 22               JR      Z,L0A1C         ; forward with '(' to S-BRACKET
3358   09FA                                             ; to evaluate the sub-expression recursively
3359   09FA                                             ; using SCANNING.
3360   09FA             
3361   09FA FE 27               CP      $27             ; commencing quote ?
3362   09FC 20 10               JR      NZ,L0A0E        ; forward to S-ABORT if not, as all valid
3363   09FE                                             ; possibilities have been exhausted.
3364   09FE             
3365   09FE             ; continue to evaluate a string.
3366   09FE             
3367   09FE FD CB 01 B6         RES     6,(IY+$01)      ; signal string result to FLAGS.
3368   0A02 23                  INC     HL              ; step past the opening quote.
3369   0A03 22 22 40            LD      ($4022),HL      ; store the string pointer in
3370   0A06                                             ; system variable RESULT.
3371   0A06             
3372   0A06             ;; S-Q-CHAR
3373   0A06 DF          L0A06:  RST     18H             ; NXT-CH-SP
3374   0A07 3D                  DEC     A               ; test for the string terminator.
3375   0A08 28 17               JR      Z,L0A21         ; forward to S-CONT if found.           >>
3376   0A0A             
3377   0A0A FE 75               CP      $75             ; [ EDIT ]      SHIFT-ENTER
3378   0A0C 20 F8               JR      NZ,L0A06        ; loop back to S-Q-CHAR till terminator found.
3379   0A0E             
3380   0A0E             ; ---
3381   0A0E             
3382   0A0E             ; the branch was here when something unexpected appeared in the expression
3383   0A0E             ; or, if from above, in the string.
3384   0A0E             
3385   0A0E             ;; S-ABORT
3386   0A0E CD AE 08    L0A0E:  CALL    L08AE           ; routine INS-ERR marks the spot.
3387   0A11 D9                  EXX                     ;
3388   0A12 01 00 00            LD      BC,$0000        ; this forces the zero priority marker down
3389   0A15                                             ; from the stack.
3390   0A15                                             ; Note. just setting B to zero should do.
3391   0A15 18 35               JR      L0A4C           ; forward to S-LOOP to balance and exit
3392   0A17             
3393   0A17             ; ---
3394   0A17             
3395   0A17             ; the ZX80 juggles with expression components using just the machine stack
3396   0A17             ; pushing first the value and then the priority/operator beneath.
3397   0A17             ; As with all ZX computers, provided there is enough memory, an expression of
3398   0A17             ; unlimited complexity can be evaluated.
3399   0A17             
3400   0A17             ;; S-PUSH-PO
3401   0A17 D5          L0A17:  PUSH    DE              ; push the value ($0000 if '-', $FFFF if 'NOT')
3402   0A18 C5                  PUSH    BC              ; then push the priority and operator.
3403   0A19             
3404   0A19             ;; SCAN-LOOP
3405   0A19 E7          L0A19:  RST     20H             ; NEXT-CHAR advances the character address.
3406   0A1A 18 C7               JR      L09E3           ; back to S-LOOP-1
3407   0A1C             
3408   0A1C             ; ---
3409   0A1C             
3410   0A1C             ;; S-BRACKET
3411   0A1C CD 49 00    L0A1C:  CALL    L0049           ; routine BRACKET evaluates expression
3412   0A1F                                             ; inside the brackets checking for
3413   0A1F                                             ; terminator using SCANNING
3414   0A1F                                             ; recursively.
3415   0A1F 18 16               JR      L0A37           ; forward to S-OPERTR
3416   0A21             
3417   0A21             ; ---
3418   0A21             
3419   0A21             ; the branch was here when the end of a string had been found.
3420   0A21             
3421   0A21             ;; S-CONT
3422   0A21 DF          L0A21:  RST     18H             ; NXT-CH-SP
3423   0A22 18 13               JR      L0A37           ; forward to S-OPERTR to consider comparisons
3424   0A24             
3425   0A24             ; ---
3426   0A24             
3427   0A24             ;; S-VAR-NUM
3428   0A24 FE 26       L0A24:  CP      $26             ; compare to 'A'
3429   0A26 38 05               JR      C,L0A2D         ; forward if numeric to S-DIGIT
3430   0A28             
3431   0A28             ; present character is alpha
3432   0A28             
3433   0A28 CD AD 0A            CALL    L0AAD           ; routine LOOK-VARS
3434   0A2B 18 0A               JR      L0A37           ; forward to S-OPERTR
3435   0A2D             
3436   0A2D             ; ---
3437   0A2D             
3438   0A2D             ;; S-DIGIT
3439   0A2D CD 79 06    L0A2D:  CALL    L0679           ; routine INT-TO-HL
3440   0A30 DC AE 08            CALL    C,L08AE         ; routine INS-ERR with overflow.
3441   0A33 FD CB 01 F6         SET     6,(IY+$01)      ; signal numeric result in FLAGS
3442   0A37             
3443   0A37             ;; S-OPERTR
3444   0A37 CD 1A 00    L0A37:  CALL    L001A           ; routine get-char
3445   0A3A             
3446   0A3A D9                  EXX
3447   0A3B 01 00 00            LD      BC,$0000        ; prepare zero priority in case not an operator
3448   0A3E                                             ; in which case at end of expression
3449   0A3E             
3450   0A3E D6 DC               SUB     $DC             ; reduce by '-'
3451   0A40 38 0A               JR      C,L0A4C         ; forward if less than an operator to S-LOOP
3452   0A42             
3453   0A42 FE 0A               CP      $0A             ; compare to ten.
3454   0A44 30 06               JR      NC,L0A4C        ; forward if higher than nine to S-LOOP
3455   0A46             
3456   0A46             ; leaves ten operators -, +, *, /, AND, OR, **, =, >, <.
3457   0A46             
3458   0A46 4F                  LD      C,A             ; transfer operation to C, register B is zero.
3459   0A47 21 A3 0A            LD      HL,L0AA3        ; address table of priorities.
3460   0A4A 09                  ADD     HL,BC           ; index into table.
3461   0A4B 46                  LD      B,(HL)          ; pick up the priority.
3462   0A4C             
3463   0A4C             ;; S-LOOP
3464   0A4C D1          L0A4C:  POP     DE              ; pop the previous priority/operation
3465   0A4D 7A                  LD      A,D             ; priority to A
3466   0A4E B8                  CP      B               ; compare with current priority B
3467   0A4F 38 37               JR      C,L0A88         ; forward to S-TIGHTER if current priority is
3468   0A51                                             ; higher
3469   0A51             
3470   0A51             ; else this is the correct place in the expression to perform this operation.
3471   0A51             
3472   0A51 A7                  AND     A               ; first test for zero priority marker
3473   0A52             
3474   0A52 D9                  EXX                     ;
3475   0A53 C8                  RET     Z               ; return if so, HL is result.  >>>>>
3476   0A54 D9                  EXX                     ;
3477   0A55             
3478   0A55 FD CB 01 7E         BIT     7,(IY+$01)      ; FLAGS
3479   0A59 28 14               JR      Z,L0A6F         ; forward if checking syntax to S-SYNTEST
3480   0A5B             
3481   0A5B             ; but in runtime the operation is performed.
3482   0A5B             
3483   0A5B 16 00               LD      D,$00           ; prepare to index.
3484   0A5D 21 1F 0D            LD      HL,L0D1F        ; address the table of operators and addresses.
3485   0A60             
3486   0A60 19                  ADD     HL,DE           ; index twice using the operation code.
3487   0A61 19                  ADD     HL,DE           ; as there are two bytes per entry.
3488   0A62 5E                  LD      E,(HL)          ; pick up low byte of address.
3489   0A63 23                  INC     HL              ; next location.
3490   0A64 56                  LD      D,(HL)          ; get high byte of address.
3491   0A65             
3492   0A65 21 7F 0A            LD      HL,L0A7F        ; the return address S-INS-VAL
3493   0A68 E3                  EX      (SP),HL         ; goes to the stack and argument to HL
3494   0A69             
3495   0A69 D5                  PUSH    DE              ; now push the address of the routine.
3496   0A6A ED 5B 22 40         LD      DE,($4022)      ; pick up last value from RESULT
3497   0A6E C9                  RET                     ; and make an indirect jump to
3498   0A6F                                             ; the routine.                  >>>>>>>>
3499   0A6F             
3500   0A6F             ; ------------------------------
3501   0A6F             
3502   0A6F             ;; S-SYNTEST
3503   0A6F 7B          L0A6F:  LD      A,E             ; get the last operation code
3504   0A70 FE 0A               CP      $0A             ; compare to ten - sets carry if numeric
3505   0A72 1F                  RRA                     ; carry to bit 7
3506   0A73 1F                  RRA                     ; carry to bit 6
3507   0A74 FD AE 01            XOR     (IY+$01)        ; exclusive or with FLAGS
3508   0A77 E6 40               AND     $40             ; isolate bit 6 - the result type.
3509   0A79             
3510   0A79 D9                  EXX                     ;
3511   0A7A C4 AE 08            CALL    NZ,L08AE        ; routine INS-ERR if not of same type.
3512   0A7D D9                  EXX                     ;
3513   0A7E             
3514   0A7E E1                  POP     HL              ; fetch the last value from machine stack
3515   0A7F             
3516   0A7F             ;  >>>>>>>>
3517   0A7F             ; Note. this is also the return address from mathematical and string
3518   0A7F             ; comparisons, see above, in which case HL will contain the result and BC
3519   0A7F             ; the priority/operation.
3520   0A7F             
3521   0A7F             ;; S-INS-VAL
3522   0A7F 22 22 40    L0A7F:  LD      ($4022),HL      ; place value in system variable RESULT
3523   0A82 FD CB 01 F6         SET     6,(IY+$01)      ; signal numeric result to FLAGS
3524   0A86 18 C4               JR      L0A4C           ; back to S-LOOP
3525   0A88             
3526   0A88             ; ---
3527   0A88             
3528   0A88             ;; S-TIGHTER
3529   0A88 D5          L0A88:  PUSH    DE              ; push lower priority
3530   0A89             
3531   0A89 79                  LD      A,C             ; fetch operator
3532   0A8A FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS
3533   0A8E 20 0A               JR      NZ,L0A9A        ; forward if numeric to S-NEXT.
3534   0A90             
3535   0A90 C6 03               ADD     A,$03           ; augment nos-eql to strs-eql etc.
3536   0A92 4F                  LD      C,A             ; and put back in C
3537   0A93             
3538   0A93 FE 0A               CP      $0A             ; compare to ten - start of string comparisons
3539   0A95             
3540   0A95 D9                  EXX                     ;
3541   0A96 DC AE 08            CALL    C,L08AE         ; routine INS-ERR if lower
3542   0A99                                             ; a$ * b$ is invalid but so too
3543   0A99                                             ; is a$ + b$ (no string concatenation)
3544   0A99 D9                  EXX                     ;
3545   0A9A             
3546   0A9A             ;; S-NEXT
3547   0A9A 2A 22 40    L0A9A:  LD      HL,($4022)      ; fetch RESULT to HL
3548   0A9D E5                  PUSH    HL              ; push intermediate result
3549   0A9E C5                  PUSH    BC              ; and then priority/operator
3550   0A9F D9                  EXX                     ;
3551   0AA0 C3 19 0A            JP      L0A19           ; jump back to SCAN-LOOP
3552   0AA3             
3553   0AA3             
3554   0AA3             ; -------------------------
3555   0AA3             ; THE 'TABLE OF PRIORITIES'
3556   0AA3             ; -------------------------
3557   0AA3             ; Table of mathematical priorities that dictate, in the absence of brackets,
3558   0AA3             ; the order in which operations are performed.
3559   0AA3             ; unary minus (priority $09) and NOT (priority $04) are handled directly.
3560   0AA3             
3561   0AA3             ;; TAB-PRIO
3562   0AA3 06          L0AA3:  DEFB    $06             ; $00  subtract
3563   0AA4 06                  DEFB    $06             ; $01  addition
3564   0AA5 08                  DEFB    $08             ; $02  multiply
3565   0AA6 07                  DEFB    $07             ; $03  division
3566   0AA7 03                  DEFB    $03             ; $04  and
3567   0AA8 02                  DEFB    $02             ; $05  or
3568   0AA9 0A                  DEFB    $0A             ; $06  to-power
3569   0AAA 05                  DEFB    $05             ; $07  nos-eql
3570   0AAB 05                  DEFB    $05             ; $08  no-grtr
3571   0AAC 05                  DEFB    $05             ; $09  no-less
3572   0AAD             
3573   0AAD             ; --------------------------
3574   0AAD             ; THE 'LOOK-VARS' SUBROUTINE
3575   0AAD             ; --------------------------
3576   0AAD             
3577   0AAD             ;; LOOK-VARS
3578   0AAD E5          L0AAD:  PUSH    HL              ; * push pointer to first letter
3579   0AAE             
3580   0AAE 21 01 40            LD      HL,$4001        ; address FLAGS
3581   0AB1 CB AE               RES     5,(HL)          ; update FLAGS - signal not a function yet.
3582   0AB3                                             ; but no use is made of this flag bit.
3583   0AB3 CB F6               SET     6,(HL)          ; update FLAGS - presume a numeric result.
3584   0AB5 DF                  RST     18H             ; NXT-CH-SP
3585   0AB6 FE 0D               CP      $0D             ; compare  to '$' ?
3586   0AB8 CA 30 0B            JP      Z,L0B30         ;; JUMP forward with match to STRING
3587   0ABB             
3588   0ABB FE DA               CP      $DA             ; compare  to '(' ?
3589   0ABD CA 2B 0B            JP      Z,L0B2B         ;; JUMP forward with match to ARRAY
3590   0AC0             
3591   0AC0             ; that leaves three types of integer plus functions.
3592   0AC0             
3593   0AC0             ;; V-CHAR
3594   0AC0 CD 18 0D    L0AC0:  CALL    L0D18           ; routine ALPHANUM
3595   0AC3 30 03               JR      NC,L0AC8        ; forward when not alphanumeric to FUNC-LOOP.
3596   0AC5             
3597   0AC5 DF                  RST     18H             ; fetch NXT-CH-SP.
3598   0AC6 18 F8               JR      L0AC0           ; loop back to V-CHAR for more.
3599   0AC8             
3600   0AC8             ; ---
3601   0AC8             
3602   0AC8             ;; FUNC-LOOP
3603   0AC8 FE DA       L0AC8:  CP      $DA             ; compare  to '(' ?
3604   0ACA 28 0A               JR      Z,L0AD6         ; forward with a match to FUNC-SRCH
3605   0ACC             
3606   0ACC FE 0D               CP      $0D             ; compare  to '$' ?
3607   0ACE C2 35 0B            JP      NZ,L0B35        ;; JUMP forward if not to V-SYN
3608   0AD1             
3609   0AD1             ; but if this is a string function such as CHR$ then the bracket must follow.
3610   0AD1             
3611   0AD1 DF                  RST     18H             ; NXT-CH-SP
3612   0AD2 FE DA               CP      $DA             ; compare  to '(' ?
3613   0AD4 20 51               JR      NZ,L0B27        ; forward if not to FUNC-ERR.
3614   0AD6             
3615   0AD6             ; This has the correct format for a function and an exact match must now be
3616   0AD6             ; made to one of the entries in the functions table.
3617   0AD6             
3618   0AD6             ;; FUNC-SRCH
3619   0AD6 11 BF 0B    L0AD6:  LD      DE,L0BC0 - 1    ; point to location before TAB-FUNC
3620   0AD9             
3621   0AD9             ;; FUNC-LOOP
3622   0AD9 E1          L0AD9:  POP     HL              ; pop pointer to first character in command
3623   0ADA E5                  PUSH    HL              ; and push again.
3624   0ADB             
3625   0ADB             ;; FUNC-CHAR
3626   0ADB 4E          L0ADB:  LD      C,(HL)          ; fetch command character to C.
3627   0ADC CD 55 00            CALL    L0055           ; routine CH-ADD-LP advances CH-ADD
3628   0ADF                                             ; to next non-space position.
3629   0ADF 13                  INC     DE              ; increment position in table
3630   0AE0 1A                  LD      A,(DE)          ; fetch table character to A.
3631   0AE1 B9                  CP      C               ; compare with one in command.
3632   0AE2 28 F7               JR      Z,L0ADB         ; loop back with match to FUNC-CHAR
3633   0AE4                                             ; e.g. PEEK
3634   0AE4             
3635   0AE4 E6 3F               AND     $3F             ; cancel any inversion.
3636   0AE6 B9                  CP      C               ; and compare again
3637   0AE7 20 05               JR      NZ,L0AEE        ; skip if no match to FUNC-NEXT.
3638   0AE9             
3639   0AE9 3E DA               LD      A,$DA           ; load with '('
3640   0AEB BE                  CP      (HL)            ; compare to next valid character
3641   0AEC 28 0B               JR      Z,L0AF9         ; forward with success to FUNC-MTCH.
3642   0AEE             
3643   0AEE             
3644   0AEE             ;; FUNC-NEXT
3645   0AEE 1A          L0AEE:  LD      A,(DE)          ; fetch next character from table.
3646   0AEF A7                  AND     A               ; test for zero end-marker.
3647   0AF0 28 35               JR      Z,L0B27         ; forward if at end of table to FUNC-ERR.
3648   0AF2             
3649   0AF2 13                  INC     DE              ; else increment pointer.
3650   0AF3 17                  RLA                     ; test for inverted bit.
3651   0AF4 30 F8               JR      NC,L0AEE        ; loop back to FUNC-NEXT
3652   0AF6                                             ; until new token found.
3653   0AF6             
3654   0AF6 13                  INC     DE              ; increment pointer.
3655   0AF7                                             ; to skip address in table.
3656   0AF7             
3657   0AF7 18 E0               JR      L0AD9           ; loop back to FUNC-LOOP
3658   0AF9                                             ; which begins by skipping the
3659   0AF9                                             ; remaining address byte.
3660   0AF9             
3661   0AF9             ; ---
3662   0AF9             
3663   0AF9             ; A function such as PEEK has been found with the necessary opening bracket.
3664   0AF9             
3665   0AF9             ;; FUNC-MTCH
3666   0AF9 D5          L0AF9:  PUSH    DE              ; save pointer to address within
3667   0AFA                                             ; table.
3668   0AFA             
3669   0AFA CD 49 00            CALL    L0049           ; routine BRACKET evaluates an
3670   0AFD                                             ; expression within brackets in command.
3671   0AFD                                             ; result in HL
3672   0AFD             
3673   0AFD D1                  POP     DE              ; retrieve table address pointer.
3674   0AFE             
3675   0AFE E3                  EX      (SP),HL         ; result to stack, discarding command
3676   0AFF                                             ; character pointer.
3677   0AFF 21 01 40            LD      HL,$4001        ; load with address FLAGS
3678   0B02             
3679   0B02 1A                  LD      A,(DE)          ; fetch the last inverted character.
3680   0B03 AE                  XOR     (HL)            ; XOR with FLAGS
3681   0B04 E6 40               AND     $40             ; isolate bit 6 - result type.
3682   0B06 20 1F               JR      NZ,L0B27        ; to FUNC-ERR to insert an error with
3683   0B08                                             ; an argument type mismatch.
3684   0B08             
3685   0B08 CB EE               SET     5,(HL)          ; update FLAGS signal a function has been found
3686   0B0A                                             ; but no use is made of this ?????
3687   0B0A CB F6               SET     6,(HL)          ; default the result type to be numeric.
3688   0B0C             
3689   0B0C 1A                  LD      A,(DE)          ; fetch last character
3690   0B0D E6 3F               AND     $3F             ; lose the indicator bits.
3691   0B0F             
3692   0B0F FE 0D               CP      $0D             ; is character '$' ?
3693   0B11                                             ; i.e. CHR$, STR$ or TL$.
3694   0B11 20 02               JR      NZ,L0B15        ; forward with numeric function results
3695   0B13                                             ; to FUNC-SYN.
3696   0B13             
3697   0B13 CB B6               RES     6,(HL)          ; else set FLAGS to indicate a string
3698   0B15                                             ; result is expected.
3699   0B15             
3700   0B15             ;; FUNC-SYN
3701   0B15 CB 7E       L0B15:  BIT     7,(HL)          ; test FLAGS checking syntax?
3702   0B17             
3703   0B17 E1                  POP     HL              ; restore RESULT of expression in brackets.
3704   0B18 C8                  RET     Z               ; return if checking syntax.           >>
3705   0B19             
3706   0B19 21 BA 0B            LD      HL,L0BBA        ; else the routine INS-RSLT
3707   0B1C E5                  PUSH    HL              ; is pushed on the machine stack
3708   0B1D             
3709   0B1D EB                  EX      DE,HL           ; HL now points to table entry.
3710   0B1E 23                  INC     HL              ; point to address low byte.
3711   0B1F 5E                  LD      E,(HL)          ; pick up the low byte.
3712   0B20 23                  INC     HL
3713   0B21 56                  LD      D,(HL)          ; pick up the high byte.
3714   0B22 D5                  PUSH    DE              ; push routine address on stack.
3715   0B23             
3716   0B23 2A 22 40            LD      HL,($4022)      ; load HL with argument from RESULT
3717   0B26                                             ; either integer or string pointer.
3718   0B26 C9                  RET                     ; indirect jump to routine and then
3719   0B27                                             ; to INS-RSLT .
3720   0B27             
3721   0B27             ; ---
3722   0B27             
3723   0B27             ;; FUNC-ERR
3724   0B27 E1          L0B27:  POP     HL              ; balance stack.
3725   0B28 C3 AE 08            JP      L08AE           ; jump back to INS-ERR
3726   0B2B             
3727   0B2B             ; ------------------------------
3728   0B2B             
3729   0B2B             ;; ARRAY
3730   0B2B CD 49 00    L0B2B:  CALL    L0049           ; routine BRACKET evaluates expression
3731   0B2E 18 05               JR      L0B35           ; skip to V-SYN
3732   0B30             
3733   0B30             ; ---
3734   0B30             
3735   0B30             ;; STRING
3736   0B30 FD CB 01 B6 L0B30:  RES     6,(IY+$01)      ; FLAGS signal string result.
3737   0B34 DF                  RST     18H             ; NXT-CH-SP
3738   0B35             
3739   0B35             ;; V-SYN
3740   0B35 E1          L0B35:  POP     HL              ; * restore pointer to first letter
3741   0B36 FD CB 01 7E         BIT     7,(IY+$01)      ; check FLAGS
3742   0B3A C8                  RET     Z               ; return if checking syntax
3743   0B3B                                             ; but continue in run-time
3744   0B3B             
3745   0B3B             ; also called from NEXT and LET 
3746   0B3B             ; HL points to first letter of variable in the command.
3747   0B3B             
3748   0B3B             ;; LV-FIND
3749   0B3B 4E          L0B3B:  LD      C,(HL)          ; C first character
3750   0B3C 23                  INC     HL
3751   0B3D 7E                  LD      A,(HL)          ; A second character
3752   0B3E             
3753   0B3E E5                  PUSH    HL              ; save pointer to character 2
3754   0B3F             
3755   0B3F FE DA               CP      $DA             ; is second character '(' ?
3756   0B41 20 19               JR      NZ,L0B5C        ; forward if not to LV-ENCODE with strings and 
3757   0B43                                             ; simple numeric variables.
3758   0B43             
3759   0B43             ; an array
3760   0B43             
3761   0B43 C5                  PUSH    BC              ; save BC on stack
3762   0B44 ED 4B 26 40         LD      BC,($4026)      ; fetch character address CH_ADD
3763   0B48 C5                  PUSH    BC              ; and save that on stack as well.
3764   0B49             
3765   0B49 CD 25 00            CALL    L0025           ; routine EVAL-EXPR evaluates the
3766   0B4C                                             ; expression after the current '('
3767   0B4C                                             ; disturbing CH_ADD
3768   0B4C             
3769   0B4C E1                  POP     HL              ; restore original value of CH_ADD
3770   0B4D 22 26 40            LD      ($4026),HL      ; and backdate CH_ADD system variable.
3771   0B50 C1                  POP     BC              ; restore the letter in BC.
3772   0B51             
3773   0B51 21 00 40            LD      HL,$4000        ; address system variable ERR_NR
3774   0B54 CB 7E               BIT     7,(HL)          ; test if $FF has been disturbed by eval_expr.
3775   0B56 20 13               JR      NZ,L0B6B        ; forward if not to V-RUN.
3776   0B58             
3777   0B58 36 02               LD      (HL),$02        ; else insert the code for subscript error
3778   0B5A E1                  POP     HL              ; balance the stack
3779   0B5B C9                  RET                     ; return with error set.        >>
3780   0B5C             
3781   0B5C             ; ---
3782   0B5C             
3783   0B5C             ; encode the variable type into bits 5-7 of the letter.
3784   0B5C             
3785   0B5C             ;; LV-ENCODE
3786   0B5C CB A9       L0B5C:  RES     5,C             ; presume type string
3787   0B5E FE 0D               CP      $0D             ; is second character '$' ?
3788   0B60 28 09               JR      Z,L0B6B         ; forward if so to V-RUN
3789   0B62             
3790   0B62 CB F1               SET     6,C             ; presume long-named numeric.
3791   0B64             
3792   0B64 CD 18 0D            CALL    L0D18           ; routine ALPHANUM test second character.
3793   0B67             
3794   0B67 38 02               JR      C,L0B6B         ; forward if so to V-RUN
3795   0B69             
3796   0B69 CB E9               SET     5,C             ; else mark as simple numeric or for/next
3797   0B6B             
3798   0B6B             ;; V-RUN
3799   0B6B 2A 08 40    L0B6B:  LD      HL,($4008)      ; point HL to the first variable from VARS.
3800   0B6E             
3801   0B6E             ;; V-EACH
3802   0B6E 7E          L0B6E:  LD      A,(HL)          ; fetch letter/marker
3803   0B6F E6 7F               AND     $7F             ; reset bit 7 to allow simple numeric variables
3804   0B71                                             ; to match against FOR-NEXT variables.
3805   0B71 CA D0 0C            JP      Z,L0CD0         ; if character was $80 then forward to ERROR-02
3806   0B74                                             ; Variable not found.
3807   0B74             
3808   0B74 B9                  CP      C               ; else compare to first letter in command
3809   0B75 20 1C               JR      NZ,L0B93        ; forward if no match to V-NEXT
3810   0B77             
3811   0B77 17                  RLA                     ; rotate A to left and then
3812   0B78 87                  ADD     A,A             ; double to test bits 5 and 6.
3813   0B79             
3814   0B79 FA A4 0B            JP      M,L0BA4         ; forward to STK-VAR with
3815   0B7C                                             ; all single letter numeric variables
3816   0B7C                                             ; including for/next and arrays.
3817   0B7C             
3818   0B7C 30 3A               JR      NC,L0BB8        ; forward to STR-RSLT with string.
3819   0B7E             
3820   0B7E             ; that leaves long-named variables (mask 010xxxxx)
3821   0B7E             ; that have to be matched in full.
3822   0B7E             
3823   0B7E D1                  POP     DE              ; take a copy of pointer.
3824   0B7F D5                  PUSH    DE              ; to 2nd character in BASIC area.
3825   0B80 E5                  PUSH    HL              ; save 1st letter pointer in vars area.
3826   0B81             
3827   0B81             
3828   0B81             ;; V-MATCHES
3829   0B81 23          L0B81:  INC     HL              ; point to next vars character.
3830   0B82 1A                  LD      A,(DE)          ; fetch each BASIC char in turn.
3831   0B83 13                  INC     DE              ; advance BASIC pointer
3832   0B84 BE                  CP      (HL)            ; compare to character in variable
3833   0B85 28 FA               JR      Z,L0B81         ; back if the same to V-MATCHES
3834   0B87             
3835   0B87 F6 80               OR      $80             ; try a match on inverted character.
3836   0B89 BE                  CP      (HL)            ; compare to variable
3837   0B8A 20 06               JR      NZ,L0B92        ; forward to V-GET-PTR without full
3838   0B8C                                             ; match.
3839   0B8C             
3840   0B8C 1A                  LD      A,(DE)          ; check that the end of name in BASIC
3841   0B8D                                             ; has been reached.
3842   0B8D             
3843   0B8D CD 18 0D            CALL    L0D18           ; routine ALPHANUM checks that no
3844   0B90                                             ; more letters follow.
3845   0B90             
3846   0B90 30 09               JR      NC,L0B9B        ; forward to V-FOUND-1 with a full
3847   0B92                                             ; match on an inverted long name.
3848   0B92             
3849   0B92             ; else continue the search
3850   0B92             
3851   0B92             ;; V-GET-PTR
3852   0B92 E1          L0B92:  POP     HL              ; fetch the pointer.
3853   0B93             
3854   0B93             ;; V-NEXT
3855   0B93 C5          L0B93:  PUSH    BC              ; save B and C
3856   0B94             
3857   0B94 CD 24 06            CALL    L0624           ; routine NEXT-ONE points DE at next
3858   0B97                                             ; variable
3859   0B97             
3860   0B97 EB                  EX      DE,HL           ; switch pointers.
3861   0B98 C1                  POP     BC              ; retrieve B and C.
3862   0B99 18 D3               JR      L0B6E           ; back for another search to V-EACH.
3863   0B9B             
3864   0B9B             ; ---
3865   0B9B             
3866   0B9B             ;; V-FOUND-1
3867   0B9B D1          L0B9B:  POP     DE              ; drop saved var pointer
3868   0B9C             
3869   0B9C             ;; V-FOUND-2
3870   0B9C D1          L0B9C:  POP     DE              ; drop pointer to second character
3871   0B9D             
3872   0B9D             ;; V-FOUND-3
3873   0B9D 23          L0B9D:  INC     HL              ; advance to value.
3874   0B9E 5E                  LD      E,(HL)          ; fetch low byte to E
3875   0B9F 23                  INC     HL              ;
3876   0BA0 56                  LD      D,(HL)          ; fetch high byte to D.
3877   0BA1 EB                  EX      DE,HL           ; value to HL
3878   0BA2 18 16               JR      L0BBA           ; forward to INS-RSLT
3879   0BA4             
3880   0BA4             ; ---
3881   0BA4             
3882   0BA4             ; simple 011xxxxx, array 101xxxxx, for/next 111xxxxx
3883   0BA4             
3884   0BA4             ;; STK-VAR
3885   0BA4 38 F6       L0BA4:  JR      C,L0B9C         ; back to V-FOUND-2 above with simple
3886   0BA6                                             ; and FOR/NEXT variables.
3887   0BA6             
3888   0BA6             ;; SV-ARRAYS
3889   0BA6 E3                  EX      (SP),HL         ; save pointer to letter on stack discarding
3890   0BA7                                             ; the second letter pointer
3891   0BA7 2A 22 40            LD      HL,($4022)      ; fetch argument within brackets from RESULT
3892   0BAA             
3893   0BAA CB 04               RLC     H               ; test the high byte.
3894   0BAC             
3895   0BAC D1                  POP     DE              ; retrieve pointer to letter
3896   0BAD 20 0F               JR      NZ,L0BBE        ; forward to ERROR-03 subscript error
3897   0BAF                                             ; if subscript > 255
3898   0BAF             
3899   0BAF 13                  INC     DE              ; point to dimensions value - 1 byte
3900   0BB0 1A                  LD      A,(DE)          ; fetch the max subscription
3901   0BB1             
3902   0BB1 BD                  CP      L               ; compare to low byte of argument.
3903   0BB2 38 0A               JR      C,L0BBE         ; forward if higher than max subscription
3904   0BB4                                             ; to ERROR-03.
3905   0BB4             
3906   0BB4 29                  ADD     HL,HL           ; double the subscript 0 - 510
3907   0BB5 19                  ADD     HL,DE           ; add to variable pointer
3908   0BB6                                             ; now point to location before required cell.
3909   0BB6                                             ; if the first element is 0 then still pointing
3910   0BB6                                             ; at the max subscription byte.
3911   0BB6 18 E5               JR      L0B9D           ; back to V-FOUND-3 above.
3912   0BB8             
3913   0BB8             ; ---
3914   0BB8             
3915   0BB8             ; string type mask 100xxxxx
3916   0BB8             
3917   0BB8             ;; STR-RSLT
3918   0BB8 D1          L0BB8:  POP     DE              ; drop pointer to var.
3919   0BB9 23                  INC     HL              ; advance to first character of string.
3920   0BBA             
3921   0BBA             ;; INS-RSLT
3922   0BBA 22 22 40    L0BBA:  LD      ($4022),HL      ; insert value/pointer into RESULT
3923   0BBD C9                  RET                     ; return.
3924   0BBE             
3925   0BBE             ; ---
3926   0BBE             
3927   0BBE             ;; ERROR-03
3928   0BBE CF          L0BBE:  RST     08H             ; ERROR restart
3929   0BBF 02                  DEFB    $02             ; subscript error
3930   0BC0             
3931   0BC0             ; ------------------------------
3932   0BC0             ; THE 'INTEGRAL FUNCTIONS TABLE'
3933   0BC0             ; ------------------------------
3934   0BC0             ; Table of functions to be parsed and addresses.
3935   0BC0             ; Parsed by LOOK-VARS.
3936   0BC0             ; Inversion is with $80 (string argument)
3937   0BC0             ; and with $CO (numeric argument).
3938   0BC0             ; The TL$, "Truncate Left string", of "CABBAGE" is "ABBAGE".
3939   0BC0             
3940   0BC0             ;; TAB-FUNC
3941   0BC0 35 2A 2A F0 L0BC0:  DEFB    $35,$2A,$2A,$F0 ; PEEK  (+$C0)
3942   0BC4 24 0C               DEFW    L0C24           ; $0C24
3943   0BC6             
3944   0BC6 28 2D 37 CD         DEFB    $28,$2D,$37,$CD ; CHR$  (+$C0)
3945   0BCA 28 0C               DEFW    L0C28           ; $0C28
3946   0BCC             
3947   0BCC 28 34 29 AA         DEFB    $28,$34,$29,$AA ; CODE  (+$80)
3948   0BD0 24 0C               DEFW    L0C24           ; $0C24
3949   0BD2             
3950   0BD2 37 33 E9            DEFB    $37,$33,$E9     ; RND   (+$C0)
3951   0BD5 ED 0B               DEFW    L0BED           ; $OBED
3952   0BD7             
3953   0BD7 39 31 8D            DEFB    $39,$31,$8D     ; TL$   (+$80)
3954   0BDA 38 0C               DEFW    L0C38           ; $0C38
3955   0BDC             
3956   0BDC 3A 38 F7            DEFB    $3A,$38,$F7     ; USR   (+$C0)
3957   0BDF F0 06               DEFW    L06F0           ; $06F0
3958   0BE1             
3959   0BE1 38 39 37 CD         DEFB    $38,$39,$37,$CD ; STR$  (+$C0)
3960   0BE5 10 0C               DEFW    L0C10           ; $0C10
3961   0BE7             
3962   0BE7 26 27 F8            DEFB    $26,$27,$F8     ; ABS   (+$C0)
3963   0BEA F2 0D               DEFW    L0DF2           ; $0DF2
3964   0BEC             
3965   0BEC 00                  DEFB    $00             ; zero end-marker
3966   0BED             
3967   0BED             ; ------------------
3968   0BED             ; THE 'RND' FUNCTION
3969   0BED             ; ------------------
3970   0BED             ; e.g. LET LOTTERYNUMBER = RND (49) produces a random number in the range
3971   0BED             ; 1 to 49.
3972   0BED             ; the routine has two stages -
3973   0BED             ; First the seed is fetched and manipulated in such a way that it cycles through
3974   0BED             ; every value between 0 and 65535 in a pseudo-random way before repeating the
3975   0BED             ; sequence. If the seed fetched is zero it is set to 65536-77.
3976   0BED             ; The multiplicand used is 77 and any overflow is subtracted from the
3977   0BED             ; register result.
3978   0BED             
3979   0BED             ;; RND
3980   0BED E5          L0BED:  PUSH    HL              ; * save the integer parameter e.g. 49.
3981   0BEE 2A 1C 40            LD      HL,($401C)      ; fetch the 'seed' from SEED.
3982   0BF1 11 4D 00            LD      DE,$004D        ; place 77 in DE
3983   0BF4 7C                  LD      A,H             ; test the seed
3984   0BF5 B5                  OR      L               ; for value zero
3985   0BF6 28 0B               JR      Z,L0C03         ; forward if zero.
3986   0BF8             
3987   0BF8 CD 55 0D            CALL    L0D55           ; routine MULT16 multiplies seed by 77
3988   0BFB                                             ; BC contains zero or overflow
3989   0BFB             
3990   0BFB A7                  AND     A               ; clear carry flag.
3991   0BFC ED 42               SBC     HL,BC           ; subtract any overflow from lower 16 bits
3992   0BFE 30 05               JR      NC,L0C05        ; forward if no carry to RND-3
3993   0C00             
3994   0C00 23                  INC     HL              ; increase seed value.
3995   0C01 18 02               JR      L0C05           ; forward to RND-3
3996   0C03             
3997   0C03             ; ---
3998   0C03             
3999   0C03             ;; RND-2
4000   0C03 ED 52       L0C03:  SBC     HL,DE           ; form number $FFB3 if seed is zero.
4001   0C05             
4002   0C05             
4003   0C05             ;; RND-3
4004   0C05 22 1C 40    L0C05:  LD      ($401C),HL      ; store new value of SEED
4005   0C08             
4006   0C08             ; now multiply the new seed by the argument to give result-1 in BC.
4007   0C08             
4008   0C08 D1                  POP     DE              ; * restore argument
4009   0C09             
4010   0C09 CD 55 0D            CALL    L0D55           ; routine MULT16 multiplies HL by DE
4011   0C0C                                             ; returning in BC, for the example, 0-48
4012   0C0C             
4013   0C0C 60                  LD      H,B             ; transfer BC
4014   0C0D 69                  LD      L,C             ; to HL - the result register.
4015   0C0E 23                  INC     HL              ; increment - make range start with 1.
4016   0C0F C9                  RET                     ; return
4017   0C10             
4018   0C10             ; -------------------
4019   0C10             ; THE 'STR$' FUNCTION
4020   0C10             ; -------------------
4021   0C10             ; the function produces a string comprising the characters that would appear
4022   0C10             ; if the numeric argument were printed.
4023   0C10             ; So seven characters e.g. "-10000" terminated by the null character ($01)
4024   0C10             ; is the maximum amount of characters required.
4025   0C10             ; Note. that for this reason the ZX80, unlike the ZX81 and ZX Spectrum, is able
4026   0C10             ; to have four tabstops across the 32 character screen.
4027   0C10             
4028   0C10             ;; str$
4029   0C10 D9          L0C10:  EXX
4030   0C11 01 07 00            LD      BC,$0007        ; 7 characters required at most.
4031   0C14 F7                  RST     30H             ; routine BC-SPACES
4032   0C15 30 1D               JR      NC,L0C34        ; forward to NULL-STR if not enough
4033   0C17                                             ; memory.
4034   0C17             
4035   0C17 D5                  PUSH    DE              ; * save start of new space
4036   0C18             
4037   0C18 D9                  EXX                     ; switch in other set
4038   0C19 44                  LD      B,H             ; transfer argument to BC
4039   0C1A 4D                  LD      C,L             ; register.
4040   0C1B             
4041   0C1B CD A1 06            CALL    L06A1           ; OUT-NUM-1 prints at this DE in WKG Space.
4042   0C1E             
4043   0C1E D9                  EXX                     ; switch back
4044   0C1F             
4045   0C1F 3E 01               LD      A,$01           ; prepare the terminating '"'
4046   0C21 12                  LD      (DE),A          ; and place at end of string.
4047   0C22             
4048   0C22             ;; POP-RET
4049   0C22 E1          L0C22:  POP     HL              ; * restore result pointer.
4050   0C23 C9                  RET                     ; return.
4051   0C24             
4052   0C24             ; -------------------------------
4053   0C24             ; THE 'CODE' AND 'PEEK' FUNCTIONS
4054   0C24             ; -------------------------------
4055   0C24             ; Two functions in one subroutine.
4056   0C24             ; CODE with HL pointing to start of string.
4057   0C24             ; and also,
4058   0C24             ; PEEK with HL pointing to a memory address.
4059   0C24             ; The return value is in HL.
4060   0C24             
4061   0C24             ;; CODE
4062   0C24             ;; PEEK
4063   0C24 6E          L0C24:  LD      L,(HL)          ; parameter is in HL.
4064   0C25 26 00               LD      H,$00           ;
4065   0C27 C9                  RET                     ; return with result in HL.
4066   0C28             
4067   0C28             ; -------------------
4068   0C28             ; THE 'CHR$' FUNCTION
4069   0C28             ; -------------------
4070   0C28             ; this function returns the null-terminated single-character string that
4071   0C28             ; corresponds to the integer argument e.g. CHR$(38) returns "A".
4072   0C28             
4073   0C28             ;; chr$
4074   0C28 01 02 00    L0C28:  LD      BC,$0002        ; two locations required.
4075   0C2B 7D                  LD      A,L             ; character to A.
4076   0C2C F7                  RST     30H             ; BC-SPACES creates two locations
4077   0C2D                                             ; in WORKSPACE
4078   0C2D 30 05               JR      NC,L0C34        ; forward to NULL-STR if no room.
4079   0C2F             
4080   0C2F             ;; NULL-PTR
4081   0C2F 36 01       L0C2F:  LD      (HL),$01        ; insert the '"' terminator at last new location
4082   0C31 2B                  DEC     HL              ; decrease the pointer.
4083   0C32 77                  LD      (HL),A          ; insert the character.
4084   0C33 C9                  RET                     ; return with HL pointing to string.
4085   0C34             
4086   0C34             ; ---
4087   0C34             
4088   0C34             ;; NULL-STR
4089   0C34 21 30 0C    L0C34:  LD      HL,L0C2F + 1    ; point to the null string at NULL-PTR + 1
4090   0C37                                             ; in the above code.
4091   0C37 C9                  RET                     ; return.
4092   0C38             
4093   0C38             ; ------------------
4094   0C38             ; THE 'TL$' FUNCTION
4095   0C38             ; ------------------
4096   0C38             ; This limited string slicing function returns the tail of a string starting
4097   0C38             ; at the second character and the null string otherwise.
4098   0C38             ; It requires no string workspace.
4099   0C38             
4100   0C38             ;; tl$
4101   0C38 7E          L0C38:  LD      A,(HL)          ; fetch first character of string
4102   0C39 3D                  DEC     A               ; decrement it.
4103   0C3A C8                  RET     Z               ; return if was CHR$ 1 - the null string.
4104   0C3B             
4105   0C3B 23                  INC     HL              ; else increase the string pointer
4106   0C3C C9                  RET                     ; return with HL pointing at result.
4107   0C3D             
4108   0C3D             
4109   0C3D             ; -----------------
4110   0C3D             ; THE 'LET' ROUTINE
4111   0C3D             ; -----------------
4112   0C3D             ; This subroutine is called from the FOR command and the CLASS-02 routine
4113   0C3D             ; to create the variable.
4114   0C3D             
4115   0C3D             ;; LET
4116   0C3D FD CB 00 7E L0C3D:  BIT     7,(IY+$00)      ; test ERR_NR
4117   0C41 C8                  RET     Z               ; return if not $FF
4118   0C42             
4119   0C42             ; proceed if no errors so far.
4120   0C42             
4121   0C42 C5                  PUSH    BC              ; save start val
4122   0C43             
4123   0C43 2A 20 40            LD      HL,($4020)      ; fetch location of letter in BASIC from DEST
4124   0C46             
4125   0C46 CD 3B 0B            CALL    L0B3B           ; routine LV-FIND will set error
4126   0C49             
4127   0C49 21 00 40            LD      HL,$4000        ; ERR_NR
4128   0C4C 7E                  LD      A,(HL)
4129   0C4D FE 02               CP      $02             ; compare to 2 - subscript out of range
4130   0C4F             
4131   0C4F 28 D1               JR      Z,L0C22         ; back to POP-RET if so         >>>
4132   0C51             
4133   0C51             ; continue with variable not found or OK.
4134   0C51             
4135   0C51 17                  RLA                     ; test for $FF??
4136   0C52 FD CB 01 76         BIT     6,(IY+$01)      ; test bit 6 FLAGS - affects zero flag only.
4137   0C56                                             ; zero if string NZ if numeric
4138   0C56 38 3B               JR      C,L0C93         ; forward if error was $FF to L-EXISTS
4139   0C58             
4140   0C58             ; continue if variable does not exist.
4141   0C58             
4142   0C58 36 FF               LD      (HL),$FF        ; cancel the error as variable will be created.
4143   0C5A             
4144   0C5A 28 47               JR      Z,L0CA3         ; forward to L-STRING with string var.
4145   0C5C             
4146   0C5C             ; continue with numeric INTEGER variable
4147   0C5C             
4148   0C5C 2A 20 40            LD      HL,($4020)      ; pick up  destination from DEST
4149   0C5F 01 02 00            LD      BC,$0002        ; set default space for integer contents
4150   0C62                                             ; will be 3 including letter
4151   0C62             
4152   0C62             ;; L-EACH-CH
4153   0C62 03          L0C62:  INC     BC              ; pre-increment character count.
4154   0C63 23                  INC     HL              ; increment character pointer in BASIC or
4155   0C64                                             ; workspace.
4156   0C64 7E                  LD      A,(HL)          ; fetch the character.
4157   0C65             
4158   0C65 CD 18 0D            CALL    L0D18           ; routine ALPHANUM check if "[0-Z]"
4159   0C68 38 F8               JR      C,L0C62         ; loop back if so to L-EACH-CH
4160   0C6A             
4161   0C6A FE DA               CP      $DA             ; is character '(' ?
4162   0C6C 28 62               JR      Z,L0CD0         ; forward if so to ERROR-02 - var not found.
4163   0C6E                                             ; e.g. perhaps a function has been misspelled.
4164   0C6E             
4165   0C6E F7                  RST     30H             ; BC-SPACES creates room for new INTEGER
4166   0C6F                                             ; variable at D-FILE - 1, the variables
4167   0C6F                                             ; end-marker.
4168   0C6F 30 B1               JR      NC,L0C22        ; back to POP-RET if not enough room
4169   0C71             
4170   0C71 D5                  PUSH    DE              ; save first new location        ***
4171   0C72 2A 20 40            LD      HL,($4020)      ; fetch DEST the pointer to letter in command
4172   0C75             
4173   0C75 0B                  DEC     BC              ; reduce count by
4174   0C76 0B                  DEC     BC              ; the three bytes
4175   0C77 0B                  DEC     BC              ; for simple integer.
4176   0C78             
4177   0C78 1B                  DEC     DE              ; point to destination
4178   0C79             
4179   0C79 78                  LD      A,B             ; check if this is a one-character
4180   0C7A B1                  OR      C               ; variable name from reduced count.
4181   0C7B             
4182   0C7B 3E 40               LD      A,$40           ; prepare mask 010xxxxx
4183   0C7D 28 08               JR      Z,L0C87         ; forward to L-SINGLE if is simple numeric.
4184   0C7F             
4185   0C7F ED B0               LDIR                    ; else copy all but one characters of name.
4186   0C81 7E                  LD      A,(HL)          ; fetch last character
4187   0C82 F6 80               OR      $80             ; invert it
4188   0C84 12                  LD      (DE),A          ; place at last destination
4189   0C85             
4190   0C85 3E 60               LD      A,$60           ; prepare mask 011xxxxx
4191   0C87             
4192   0C87             ;; L-SINGLE
4193   0C87 E1          L0C87:  POP     HL              ; restore first new location            ***
4194   0C88             
4195   0C88 CD B9 0C            CALL    L0CB9           ; routine L-MASK inserts masked letter.
4196   0C8B             
4197   0C8B EB                  EX      DE,HL           ;
4198   0C8C 1B                  DEC     DE              ;
4199   0C8D                                             ; and continue to initialize variable contents.
4200   0C8D             
4201   0C8D             ; this branch is taken from below to overwrite contents.
4202   0C8D             
4203   0C8D             ;; L-NUMERIC
4204   0C8D E1          L0C8D:  POP     HL              ; restore variable value
4205   0C8E EB                  EX      DE,HL           ; HL points last location
4206   0C8F             
4207   0C8F 72                  LD      (HL),D          ; insert high byte.
4208   0C90 2B                  DEC     HL              ; decrement the pointer.
4209   0C91 73                  LD      (HL),E          ; and insert low-byte value
4210   0C92 C9                  RET                     ; return. with HL addressing the value. >>>>
4211   0C93             
4212   0C93             ; ---
4213   0C93             
4214   0C93             ;; L-EXISTS
4215   0C93 20 F8       L0C93:  JR      NZ,L0C8D        ; back to L-NUMERIC to overwrite variable
4216   0C95                                             ; if numeric type.
4217   0C95             
4218   0C95 E1                  POP     HL              ; restore string
4219   0C96             
4220   0C96 CD A4 0C            CALL    L0CA4           ; routine L-LENGTH evaluates length of OLD
4221   0C99                                             ; string
4222   0C99             
4223   0C99 2A 22 40            LD      HL,($4022)      ; fetch string pointer from RESULT
4224   0C9C 2B                  DEC     HL              ; decrement to point to letter.
4225   0C9D CD 24 06            CALL    L0624           ; routine NEXT-ONE calculate space to delete
4226   0CA0 C3 66 06            JP      L0666           ; routine RECLAIM-2
4227   0CA3             
4228   0CA3             ; now continue into L-STRING to evaluate length of new string.
4229   0CA3             
4230   0CA3             ; ---
4231   0CA3             
4232   0CA3             ;; L-STRING
4233   0CA3 E1          L0CA3:  POP     HL              ; restore pointer to contents.
4234   0CA4             
4235   0CA4             ;; L-LENGTH
4236   0CA4 3E 01       L0CA4:  LD      A,$01           ; the search will be for the quote character.
4237   0CA6 01 01 00            LD      BC,$0001        ; initialize length to one.
4238   0CA9             
4239   0CA9             ;; L-COUNT
4240   0CA9 BE          L0CA9:  CP      (HL)            ; is addressed character null ?
4241   0CAA 23                  INC     HL              ; increase pointer.
4242   0CAB 03                  INC     BC              ; increase length.
4243   0CAC             
4244   0CAC 20 FB               JR      NZ,L0CA9        ; loop back to L-COUNT till terminating
4245   0CAE                                             ; quote found.
4246   0CAE             
4247   0CAE E5                  PUSH    HL              ; save pointer to end - null terminator.
4248   0CAF             
4249   0CAF F7                  RST     30H             ; routine BC-SPACES creates room at end.
4250   0CB0 EB                  EX      DE,HL           ; transfer end to DE.
4251   0CB1             
4252   0CB1 E1                  POP     HL              ; retrieve pointer to null terminator in E-LINE.
4253   0CB2             
4254   0CB2 D0                  RET     NC              ; return if no room was available.
4255   0CB3             
4256   0CB3 ED B8               LDDR                    ; else copy string to the variables area.
4257   0CB5 EB                  EX      DE,HL           ; HL now points to letter -1
4258   0CB6 23                  INC     HL              ; adjust
4259   0CB7 3E A0               LD      A,$A0           ; prepare mask %10100000
4260   0CB9             
4261   0CB9             ;; L-MASK
4262   0CB9 EB          L0CB9:  EX      DE,HL           ; save variable pointer in DE.
4263   0CBA 2A 20 40            LD      HL,($4020)      ; fetch destination in prog/e-line area
4264   0CBD                                             ; from system variable DEST
4265   0CBD AE                  XOR     (HL)            ; XOR mask with the letter.
4266   0CBE                                             ; Note. All letters have bit 5 set. The 
4267   0CBE                                             ; preparation of masks must accommodate this.
4268   0CBE EB                  EX      DE,HL           ; variable pointer to HL,
4269   0CBF F5                  PUSH    AF              ; save masked letter
4270   0CC0             
4271   0CC0 CD 0D 0D            CALL    L0D0D           ; routine REC-V80 reclaims
4272   0CC3                                             ; the previous $80 variables end-marker.
4273   0CC3             
4274   0CC3 F1                  POP     AF              ; pop the letter.
4275   0CC4 2B                  DEC     HL              ; point to the letter in the variables area.
4276   0CC5                                             ; which is now one location lower than it was
4277   0CC5                                             ; a moment ago.
4278   0CC5 77                  LD      (HL),A          ; insert masked letter.
4279   0CC6             
4280   0CC6 2A 0C 40            LD      HL,($400C)      ; use D_FILE value
4281   0CC9 22 0A 40            LD      ($400A),HL      ; to update new E_LINE
4282   0CCC 2B                  DEC     HL              ; step back.
4283   0CCD 36 80               LD      (HL),$80        ; and insert the new variable $80 end-marker.
4284   0CCF C9                  RET                     ; return.
4285   0CD0             
4286   0CD0             ; ---
4287   0CD0             
4288   0CD0             ;; ERROR-02
4289   0CD0 E1          L0CD0:  POP     HL              ;
4290   0CD1             
4291   0CD1 CF                  RST     08H             ; ERROR restart
4292   0CD2 01                  DEFB    $01             ; variable name not found.
4293   0CD3             
4294   0CD3             ; -------------------------
4295   0CD3             ; THE 'DIM' COMMAND ROUTINE
4296   0CD3             ; -------------------------
4297   0CD3             ; This routine creates a one-dimensional numeric array with up to
4298   0CD3             ; 256 subscripts. Each is initialized to the integer zero.
4299   0CD3             ; Note. array subscripts begin at zero. On later ZX computers subscripts began
4300   0CD3             ; at 1 and there were no limits to the dimensions and subscripts other than
4301   0CD3             ; memory.
4302   0CD3             
4303   0CD3             ;; DIM
4304   0CD3 A0          L0CD3:  AND     B               ; check high byte of parameter.
4305   0CD4                                             ; a maximum of 255 subscripts possible.
4306   0CD4 C2 BE 0B            JP      NZ,L0BBE        ; back to ERROR-03 - subscript error.
4307   0CD7             
4308   0CD7 C5                  PUSH    BC              ; save max subscript
4309   0CD8 60                  LD      H,B             ; transfer
4310   0CD9 69                  LD      L,C             ; to HL.
4311   0CDA             
4312   0CDA 23                  INC     HL              ; increment to make range 1-256 from 0-255
4313   0CDB 23                  INC     HL              ; increment for letter and subscript byte
4314   0CDC 29                  ADD     HL,HL           ; double - allocates two bytes per integer
4315   0CDD                                             ; and two for the letter and subscript.
4316   0CDD             
4317   0CDD 44                  LD      B,H             ; transfer count
4318   0CDE 4D                  LD      C,L             ; to BC
4319   0CDF             
4320   0CDF F7                  RST     30H             ; BC-SPACES
4321   0CE0 D2 22 0C            JP      NC,L0C22        ; back to POP-RET if out of memory
4322   0CE3             
4323   0CE3 2B                  DEC     HL              ; point to last new location
4324   0CE4 54                  LD      D,H             ; transfer to DE
4325   0CE5 5D                  LD      E,L             ; - the destination.
4326   0CE6 1B                  DEC     DE              ; make DE one less than source.
4327   0CE7 0B                  DEC     BC              ; reduce count
4328   0CE8 0B                  DEC     BC              ; by two.
4329   0CE9 36 00               LD      (HL),$00        ; insert a zero at source.
4330   0CEB             
4331   0CEB ED B8               LDDR                    ; block fill locations with zero.
4332   0CED             
4333   0CED C1                  POP     BC              ; restore number of subscripts
4334   0CEE 71                  LD      (HL),C          ; and place in location before data.
4335   0CEF 3E 80               LD      A,$80           ; prepare mask %100
4336   0CF1 18 C6               JR      L0CB9           ; back to L-MASK
4337   0CF3             
4338   0CF3             ; ---------------------
4339   0CF3             ; THE 'RESERVE' ROUTINE
4340   0CF3             ; ---------------------
4341   0CF3             ; A continuation of the BC-SPACES RESTART.
4342   0CF3             ; the number of bytes required is on the machine stack.
4343   0CF3             
4344   0CF3             ;; RESERVE
4345   0CF3 2A 0A 40    L0CF3:  LD      HL,($400A)      ; fetch start of WKG Space from E_LINE
4346   0CF6 E5                  PUSH    HL              ; preserve location.
4347   0CF7             
4348   0CF7 2A 0C 40            LD      HL,($400C)      ; fetch location after WKG Space from D_FILE
4349   0CFA 2B                  DEC     HL              ; point to last byte of WKG space.
4350   0CFB             
4351   0CFB CD D5 05            CALL    L05D5           ; routine MAKE-ROOM creates the space after
4352   0CFE                                             ; last byte sliding D-FILE up and updating
4353   0CFE                                             ; D_FILE, DF_EA and DF_END
4354   0CFE             
4355   0CFE 23                  INC     HL              ; increase address
4356   0CFF 23                  INC     HL              ; by two bytes
4357   0D00             
4358   0D00 C1                  POP     BC              ; retrieve E_LINE which may have been updated
4359   0D01                                             ; by pointers
4360   0D01 ED 43 0A 40         LD      ($400A),BC      ; restore E_LINE
4361   0D05 C1                  POP     BC              ; restore the number of bytes required.
4362   0D06             
4363   0D06 EB                  EX      DE,HL           ; switch - DE points to first
4364   0D07 23                  INC     HL              ; make HL point to last new byte
4365   0D08 37                  SCF                     ; signal success
4366   0D09 C9                  RET                     ; return
4367   0D0A             
4368   0D0A             ; --------------------------------------
4369   0D0A             ; THE 'RECLAIM THE EDIT LINE' SUBROUTINE
4370   0D0A             ; --------------------------------------
4371   0D0A             ; Interestingly, Hugo Davenport refers to this subroutine in the manual
4372   0D0A             ; by its Nine Tiles source code label X_TEMP.
4373   0D0A             ; The second entry point deletes the old variables end-marker when creating
4374   0D0A             ; a new variable immediately after this position.
4375   0D0A             
4376   0D0A             ;; REC-EDIT
4377   0D0A 2A 0C 40    L0D0A:  LD      HL,($400C)      ; D_FILE
4378   0D0D             
4379   0D0D             ;; REC-V80
4380   0D0D ED 5B 0A 40 L0D0D:  LD      DE,($400A)      ; E_LINE
4381   0D11 C3 63 06            JP      L0663           ; RECLAIM-1
4382   0D14             
4383   0D14             ; ----------------------
4384   0D14             ; THE 'ALPHA' SUBROUTINE
4385   0D14             ; ----------------------
4386   0D14             
4387   0D14             ;; ALPHA
4388   0D14 FE 26       L0D14:  CP      $26             ; compare to 'A'
4389   0D16 18 02               JR      L0D1A           ; forward to ALPHA-2 to compare
4390   0D18                                             ; against 'Z'
4391   0D18             
4392   0D18             ; -------------------------
4393   0D18             ; THE 'ALPHANUM' SUBROUTINE
4394   0D18             ; -------------------------
4395   0D18             ; The zx80 character set makes this routine as straightforward as the one above
4396   0D18             ; as there is no gap between numerals and alphabetic characters.
4397   0D18             
4398   0D18             ;; ALPHANUM
4399   0D18 FE 1C       L0D18:  CP      $1C             ; compare to '0' - carry set if less
4400   0D1A             
4401   0D1A             ;; ALPHA-2
4402   0D1A 3F          L0D1A:  CCF                     ; change to carry reset if less.
4403   0D1B D0                  RET     NC              ; return if less than '0'
4404   0D1C             
4405   0D1C FE 40               CP      $40             ; compare to character after 'Z'
4406   0D1E C9                  RET                     ; return with carry set if in the
4407   0D1F                                             ; range '0' - 'Z'
4408   0D1F             
4409   0D1F             ; ------------------------------------------------
4410   0D1F             ; THE 'ARITHMETIC OPERATORS AND COMPARISONS' TABLE
4411   0D1F             ; ------------------------------------------------
4412   0D1F             ; This table is indexed with the operator * 2 to access the address of the
4413   0D1F             ; associated routine.
4414   0D1F             
4415   0D1F             ;; TAB-OPS
4416   0D1F 39 0D       L0D1F:  DEFW    L0D39           ; $00  subtract
4417   0D21 3E 0D               DEFW    L0D3E           ; $01  addition
4418   0D23 44 0D               DEFW    L0D44           ; $02  multiply
4419   0D25 90 0D               DEFW    L0D90           ; $03  division
4420   0D27 B5 0D               DEFW    L0DB5           ; $04  and
4421   0D29 BC 0D               DEFW    L0DBC           ; $05  or
4422   0D2B 70 0D               DEFW    L0D70           ; $06  to-power
4423   0D2D C3 0D               DEFW    L0DC3           ; $07  nos-eql
4424   0D2F CC 0D               DEFW    L0DCC           ; $08  no-grtr
4425   0D31 CD 0D               DEFW    L0DCD           ; $09  no-less
4426   0D33 D9 0D               DEFW    L0DD9           ; $0A  strs-eql
4427   0D35 DF 0D               DEFW    L0DDF           ; $0B  str-grtr
4428   0D37 DE 0D               DEFW    L0DDE           ; $0C  str-less
4429   0D39             
4430   0D39             ; ---------------------------
4431   0D39             ; THE 'SUBTRACTION' OPERATION
4432   0D39             ; ---------------------------
4433   0D39             ; offset $00 : subtract
4434   0D39             ; This operation simply uses the Z80's 16-bit register subtract instruction
4435   0D39             ; which sets the overflow flag if the lower 15 bits overflow.
4436   0D39             
4437   0D39             ;; subtract
4438   0D39 A7          L0D39:  AND     A               ; clear carry flag.
4439   0D3A ED 52               SBC     HL,DE           ; 16 bit subtraction.
4440   0D3C 18 03               JR      L0D41           ; forward to RSLT-TEST
4441   0D3E             
4442   0D3E             ; ------------------------
4443   0D3E             ; THE 'ADDITION' OPERATION
4444   0D3E             ; ------------------------
4445   0D3E             ; offset $01 : add
4446   0D3E             ; This operation simply uses the Z80's 16-bit register add instruction
4447   0D3E             ; which sets the overflow flag in the manner above.
4448   0D3E             
4449   0D3E             ;; addition
4450   0D3E A7          L0D3E:  AND     A               ; clear carry flag.
4451   0D3F ED 5A               ADC     HL,DE           ; 16 bit addition.
4452   0D41             
4453   0D41             ;; RSLT-TEST
4454   0D41 E0          L0D41:  RET     PO              ; return if no twos-complement arithmetic
4455   0D42                                             ; overflow.
4456   0D42             
4457   0D42             ;; ERROR-06
4458   0D42 CF          L0D42:  RST     08H             ; ERROR restart
4459   0D43 05                  DEFB    $05             ; arithmetic overflow.
4460   0D44             
4461   0D44             ; ------------------------------
4462   0D44             ; THE 'MULTIPLICATION' OPERATION
4463   0D44             ; ------------------------------
4464   0D44             ; offset $02 : multiply
4465   0D44             ; the multiplication operation converts the two numbers HL and DE to positive
4466   0D44             ; integers, saving the result sign in the accumulator. If the positive result
4467   0D44             ; is above 32767 then an error code is produced else result is converted
4468   0D44             ; to the required sign, if necessary, as dictated by the accumulator.
4469   0D44             
4470   0D44             ;; multiply
4471   0D44 CD ED 0D    L0D44:  CALL    L0DED           ; routine PREP-MD
4472   0D47             
4473   0D47 C5                  PUSH    BC              ; save priority/operation
4474   0D48 08                  EX      AF,AF'          ; save result sign
4475   0D49             
4476   0D49 CD 55 0D            CALL    L0D55           ; routine MULT16
4477   0D4C             
4478   0D4C 20 3F               JR      NZ,L0D8D        ; forward with overflow to POP6
4479   0D4E                                             ; clear the stack and produce ERROR-06
4480   0D4E             
4481   0D4E             ;; MULT-2
4482   0D4E C1          L0D4E:  POP     BC              ; restore priority/operation
4483   0D4F 08                  EX      AF,AF'          ; restore result sign.
4484   0D50 1F                  RRA                     ; test sign bit.
4485   0D51 D0                  RET     NC              ; return if result positive.
4486   0D52             
4487   0D52 C3 F6 0D            JP      L0DF6           ; exit via routine TWOS-COMP
4488   0D55             
4489   0D55             ; ----------------------------------------
4490   0D55             ; THE 'SIXTEEN BIT MULTIPLICATION' ROUTINE
4491   0D55             ; ----------------------------------------
4492   0D55             ; Binary long multiplication by shifting and addition at the appropriate place
4493   0D55             ; if the multiplier bit is set.
4494   0D55             ; This important subroutine is called from the multiply routine, the to-power
4495   0D55             ; routine and twice from the RND function routine.
4496   0D55             ; It multiplies the 16 bit multiplier, HL, by the 16-bit multiplicand DE.
4497   0D55             ; Since the highest number the ZX80 can hold is 32767, the routine detects
4498   0D55             ; any overflow above this, resetting the zero flag - NZ with overflow.
4499   0D55             ; However if overflow occurs the routine does not abort, as does say the
4500   0D55             ; Spectrum, but continues to calculate the 32-bit result in B, C, H, L.
4501   0D55             ; Use is made of this by the RND routine.
4502   0D55             
4503   0D55             ;; MULT16
4504   0D55 44          L0D55:  LD      B,H             ; transfer HL to BC
4505   0D56 4D                  LD      C,L             ; register.
4506   0D57             
4507   0D57 3E 10               LD      A,$10           ; count 16 bits.
4508   0D59 21 00 00            LD      HL,$0000        ; initialize result register.
4509   0D5C             
4510   0D5C             ;; MULT-LP
4511   0D5C 29          L0D5C:  ADD     HL,HL           ; shift result left.
4512   0D5D CB 11               RL      C               ; shift multiplier
4513   0D5F CB 10               RL      B               ; to the left.
4514   0D61                                             ; and capture any overflow.
4515   0D61 30 04               JR      NC,L0D67        ; skip addition if no carry to MULT-SKIP.
4516   0D63             
4517   0D63 19                  ADD     HL,DE           ; else add in multiplicand for this bit
4518   0D64 30 01               JR      NC,L0D67        ; forward if no overflow.
4519   0D66             
4520   0D66 03                  INC     BC              ; capture overflow in BC
4521   0D67             
4522   0D67             ;; MULT-SKIP
4523   0D67 3D          L0D67:  DEC     A               ; decrement bit count.
4524   0D68 20 F2               JR      NZ,L0D5C        ; loop back for all 16 bits to MULT-LP.
4525   0D6A             
4526   0D6A 7C                  LD      A,H             ; test for a
4527   0D6B E6 80               AND     $80             ; negative result.
4528   0D6D             
4529   0D6D B0                  OR      B               ; test for any
4530   0D6E B1                  OR      C               ; intermediate overflow
4531   0D6F             
4532   0D6F C9                  RET                     ; return with zero flag set
4533   0D70                                             ; for success.
4534   0D70             
4535   0D70             ; ------------------------
4536   0D70             ; THE 'TO-POWER' OPERATION
4537   0D70             ; ------------------------
4538   0D70             ; offset $06 : to-power
4539   0D70             ; This routine raises HL to the power DE, by performing a multiplication
4540   0D70             ; for each unit of the power. For the integer range supported this is quite
4541   0D70             ; adequate with 2**14 returning the result without any noticeable delay
4542   0D70             ; and 1**32767 blacking the screen out for no more than a second.
4543   0D70             ; Note also that
4544   0D70             ; 0 ** 0 = 1.
4545   0D70             ; 0 ** +n = 0.
4546   0D70             ; 0 ** -n = arithmetic overflow.
4547   0D70             
4548   0D70             ;; to-power
4549   0D70 CB 7A       L0D70:  BIT     7,D             ; test if second number negative.
4550   0D72 20 CE               JR      NZ,L0D42        ; back to ERROR-06 if so.
4551   0D74             
4552   0D74 AF                  XOR     A               ; initialize sign flag
4553   0D75 CD F2 0D            CALL    L0DF2           ; routine ABS - makes HL positive.
4554   0D78                                             ; A holds 1 if HL was negative else 0.
4555   0D78             
4556   0D78 A3                  AND     E               ;
4557   0D79 08                  EX      AF,AF'          ; save result
4558   0D7A             
4559   0D7A C5                  PUSH    BC              ; save priority/operation
4560   0D7B             
4561   0D7B 42                  LD      B,D             ; transfer power
4562   0D7C 4B                  LD      C,E             ; to BC
4563   0D7D             
4564   0D7D EB                  EX      DE,HL           ; transfer number to DE
4565   0D7E 21 01 00            LD      HL,$0001        ; initialize result.
4566   0D81             
4567   0D81             ;; POWER-LP
4568   0D81 0B          L0D81:  DEC     BC              ; decrement power counter.
4569   0D82 CB 78               BIT     7,B             ; check when zero passed.
4570   0D84             
4571   0D84 20 C8               JR      NZ,L0D4E        ; back when finished to MULT-2
4572   0D86                                             ; to test result.                   >>
4573   0D86             
4574   0D86 C5                  PUSH    BC              ; save counter.
4575   0D87             
4576   0D87 CD 55 0D            CALL    L0D55           ; routine MULT16
4577   0D8A             
4578   0D8A C1                  POP     BC              ; restore counter.
4579   0D8B 28 F4               JR      Z,L0D81         ; loop while no overflow exists from
4580   0D8D                                             ; the multiplication to POWER-LP.
4581   0D8D             
4582   0D8D             ;; POP6
4583   0D8D C1          L0D8D:  POP     BC              ; restore priority/operation
4584   0D8E 18 B2               JR      L0D42           ; back to ERROR-06 - arithmetic overflow.
4585   0D90             
4586   0D90             ; ------------------------
4587   0D90             ; THE 'DIVISION' OPERATION
4588   0D90             ; ------------------------
4589   0D90             ; offset $03 : division
4590   0D90             ; Binary long division by shifting and subtraction at the appropriate place,
4591   0D90             ; setting correct quotient bit if the subtraction goes.
4592   0D90             ; dividend (HL) / divisor (DE) = quotient (HL)
4593   0D90             
4594   0D90             ;; division
4595   0D90 7A          L0D90:  LD      A,D             ; test divisor for zero
4596   0D91 B3                  OR      E               ; avoiding division by zero.
4597   0D92             
4598   0D92 28 AE               JR      Z,L0D42         ; to ERROR-06 - arithmetic overflow
4599   0D94                                             ; if so.
4600   0D94             
4601   0D94 CD ED 0D            CALL    L0DED           ; routine PREP-MD converts HL and DE to 15-bit 
4602   0D97                                             ; integers and records the result sign in A.
4603   0D97             
4604   0D97 C5                  PUSH    BC              ; save the priority/operation.
4605   0D98             
4606   0D98 1F                  RRA                     ; sets carry if a negative result.
4607   0D99             
4608   0D99 ED 6A               ADC     HL,HL           ; pick up the carry in HL, (bit 15 was reset)
4609   0D9B 7C                  LD      A,H             ; transfer modified dividend to 
4610   0D9C 4D                  LD      C,L             ; registers A and C.
4611   0D9D             
4612   0D9D 21 00 00            LD      HL,L0000        ; initialize 'accumulator' to zero.
4613   0DA0 06 10               LD      B,$10           ; sixteen bits including sign bit.
4614   0DA2             
4615   0DA2             ;; DIV-1
4616   0DA2 ED 6A       L0DA2:  ADC     HL,HL           ; 
4617   0DA4 ED 52               SBC     HL,DE           ; subtract divisor.
4618   0DA6 30 01               JR      NC,L0DA9        ; skip forward if subtraction goes to DIV-2.
4619   0DA8             
4620   0DA8 19                  ADD     HL,DE           ; add back divisor.
4621   0DA9             
4622   0DA9             ;; DIV-2
4623   0DA9 CB 11       L0DA9:  RL      C               ; as dividend bits are shifted out, the 
4624   0DAB 17                  RLA                     ; result bits are shifted in.
4625   0DAC 10 F4               DJNZ    L0DA2           ; back for all 16 bits.
4626   0DAE             
4627   0DAE             ; note after 16 bits the final RLA retrieves the sign
4628   0DAE             
4629   0DAE 67                  LD      H,A             ; transfer result in A and C
4630   0DAF 69                  LD      L,C             ; to HL
4631   0DB0 23                  INC     HL              ; increment
4632   0DB1             
4633   0DB1 C1                  POP     BC              ; restore priority/operation.
4634   0DB2 D8                  RET     C               ; return if .
4635   0DB3             
4636   0DB3 18 41               JR      L0DF6           ; else forward to TWOS-COMP.
4637   0DB5             
4638   0DB5             ; ---------------------------
4639   0DB5             ; THE 'BITWISE AND' OPERATION
4640   0DB5             ; ---------------------------
4641   0DB5             ; offset $04 : and
4642   0DB5             
4643   0DB5             ;; and
4644   0DB5 7C          L0DB5:  LD      A,H             ;
4645   0DB6 A2                  AND     D               ;
4646   0DB7 67                  LD      H,A             ;
4647   0DB8             
4648   0DB8 7D                  LD      A,L             ;
4649   0DB9 A3                  AND     E               ;
4650   0DBA 6F                  LD      L,A             ;
4651   0DBB             
4652   0DBB C9                  RET                     ;
4653   0DBC             
4654   0DBC             ; --------------------------
4655   0DBC             ; THE 'BITWISE OR' OPERATION
4656   0DBC             ; --------------------------
4657   0DBC             ; offset $05 : or
4658   0DBC             
4659   0DBC             ;; or
4660   0DBC 7C          L0DBC:  LD      A,H             ;
4661   0DBD B2                  OR      D               ;
4662   0DBE 67                  LD      H,A             ;
4663   0DBF             
4664   0DBF 7D                  LD      A,L             ;
4665   0DC0 B3                  OR      E               ;
4666   0DC1 6F                  LD      L,A             ;
4667   0DC2             
4668   0DC2 C9                  RET                     ;
4669   0DC3             
4670   0DC3             ; -----------------------------------------
4671   0DC3             ; THE 'THREE NUMERIC COMPARISON' OPERATIONS
4672   0DC3             ; -----------------------------------------
4673   0DC3             ; offsets $07 - nos-eql, $08 - no-grtr, $09 - no-less.
4674   0DC3             ;
4675   0DC3             ; for example, PRINT 2=2 gives result -1 (true)
4676   0DC3             
4677   0DC3             ;; nos-eql
4678   0DC3 A7          L0DC3:  AND     A               ; prepare to subtract.
4679   0DC4 ED 52               SBC     HL,DE           ; subtract the two numbers.
4680   0DC6             
4681   0DC6             ;; SET-RSLT
4682   0DC6 21 FF FF    L0DC6:  LD      HL,$FFFF        ; prepare true result.
4683   0DC9 C8                  RET     Z               ; return true result, $FFFF, in HL
4684   0DCA                                             ; if remainder was zero.
4685   0DCA             
4686   0DCA 23                  INC     HL              ; else increment to $0000
4687   0DCB C9                  RET                     ; return false result, zero in HL.
4688   0DCC             
4689   0DCC             ; ---
4690   0DCC             
4691   0DCC             ;; no-grtr
4692   0DCC EB          L0DCC:  EX      DE,HL           ; swap values and continue into ...
4693   0DCD             
4694   0DCD             ;; no-less
4695   0DCD A7          L0DCD:  AND     A               ; prepare for true subtraction
4696   0DCE ED 52               SBC     HL,DE           ; subtract using registers
4697   0DD0 7C                  LD      A,H             ; fetch MSB
4698   0DD1 17                  RLA                     ; test the sign bit without affecting P/V flag
4699   0DD2 E2 D6 0D            JP      PO,L0DD6        ; skip to TEST-HL with no overflow
4700   0DD5             
4701   0DD5 3F                  CCF                     ; complement the carry flag
4702   0DD6             
4703   0DD6             ;; TEST-HL
4704   0DD6 ED 62       L0DD6:  SBC     HL,HL           ; result HL will be $0000 false or $FFFF true
4705   0DD8                                             ; with carry.
4706   0DD8 C9                  RET                     ; return
4707   0DD9             
4708   0DD9             ; ----------------------------------------
4709   0DD9             ; THE 'THREE STRING COMPARISON' OPERATIONS
4710   0DD9             ; ----------------------------------------
4711   0DD9             ; offsets $0A - strs-eql, $0B - str-grtr, $0C - str-less.
4712   0DD9             
4713   0DD9             ;; strs-eql
4714   0DD9 CD E4 0D    L0DD9:  CALL    L0DE4           ; routine STR-CMP
4715   0DDC 18 E8               JR      L0DC6           ; to SET-RSLT
4716   0DDE             
4717   0DDE             ; ---
4718   0DDE             
4719   0DDE             ;; str-grtr
4720   0DDE EB          L0DDE:  EX      DE,HL           ; swap the two string pointers
4721   0DDF             
4722   0DDF             ;; str-less
4723   0DDF CD E4 0D    L0DDF:  CALL    L0DE4           ; routine STR-CMP
4724   0DE2 18 F2               JR      L0DD6           ; back to TEST-HL
4725   0DE4             
4726   0DE4             ; ----------------------------------
4727   0DE4             ; THE 'STRING COMPARISON' SUBROUTINE
4728   0DE4             ; ----------------------------------
4729   0DE4             
4730   0DE4             ;; STR-CMP
4731   0DE4 1A          L0DE4:  LD      A,(DE)          ; fetch character of 2nd string.
4732   0DE5 BE                  CP      (HL)            ; compare to first.
4733   0DE6 C0                  RET     NZ              ; return with mismatch, carry flag
4734   0DE7                                             ; shows the comparison.
4735   0DE7             
4736   0DE7 3D                  DEC     A               ; test for the null string chr$ 1.
4737   0DE8 C8                  RET     Z               ; return as both strings have
4738   0DE9                                             ; terminated - an exact match.
4739   0DE9             
4740   0DE9 13                  INC     DE              ; else increase
4741   0DEA 23                  INC     HL              ; both the string pointers.
4742   0DEB             
4743   0DEB 18 F7               JR      L0DE4           ; and loop back to STR-CMP till one
4744   0DED                                             ; of the two conditions is met.
4745   0DED             
4746   0DED             ; ----------------------------------------------
4747   0DED             ; THE 'PREPARE TO MULTIPLY OR DIVIDE' SUBROUTINE
4748   0DED             ; ----------------------------------------------
4749   0DED             
4750   0DED             ;; PREP-MD
4751   0DED AF          L0DED:  XOR     A               ; initialize a sign flag.
4752   0DEE CD F1 0D            CALL    L0DF1           ; call PREP-1 to prepare one number
4753   0DF1                                             ; and continue into routine to prepare
4754   0DF1                                             ; the other number.
4755   0DF1             ;; PREP-1
4756   0DF1 EB          L0DF1:  EX      DE,HL           ; switch numbers at each pass
4757   0DF2             
4758   0DF2             ; ------------------
4759   0DF2             ; THE 'ABS' FUNCTION
4760   0DF2             ; ------------------
4761   0DF2             ; finds the absolute value of an signed integer.
4762   0DF2             ; Negative numbers are twos complemented.
4763   0DF2             ; e.g. minus 1 ($FFFF) is first 'ones complemented' to $0000 then incremented.
4764   0DF2             
4765   0DF2             ;; abs
4766   0DF2 CB 7C       L0DF2:  BIT     7,H             ; test sign of HL.
4767   0DF4 C8                  RET     Z               ; return if positive.
4768   0DF5             
4769   0DF5 3C                  INC     A               ; sets bit 0 if result is negative.
4770   0DF6                                             ; two negatives will reset bit 0 when this
4771   0DF6                                             ; routine is used to prepare for multiplication.
4772   0DF6                                             ; 'a minus times a minus gives a plus'.
4773   0DF6             
4774   0DF6             ;; TWOS-COMP
4775   0DF6 08          L0DF6:  EX      AF,AF'          ; save running flag.
4776   0DF7             
4777   0DF7 7C                  LD      A,H             ; fetch high byte
4778   0DF8 2F                  CPL                     ; complement it
4779   0DF9 67                  LD      H,A             ; put back
4780   0DFA             
4781   0DFA 7D                  LD      A,L             ; fetch low byte
4782   0DFB 2F                  CPL                     ; complement
4783   0DFC 6F                  LD      L,A             ; put back
4784   0DFD             
4785   0DFD 23                  INC     HL              ; twos complement
4786   0DFE             
4787   0DFE 08                  EX      AF,AF'          ; restore running flag.
4788   0DFF C9                  RET                     ; return.
4789   0E00             
4790   0E00             ; -------------------
4791   0E00             ; THE 'SPARE' SECTION
4792   0E00             ; -------------------
4793   0E00             
4794   0E00             ; Start of Spare bytes
4795   0E00             
4796   0E00             ; End of Spare bytes.
4797   0E00             
4798   0E00             ;--------------------
4799   0E00             ; THE 'CHARACTER SET'
4800   0E00             ;--------------------
4801   0E00             
4802   0E00             ;; char-set
4803   0E00             
4804   0E00             ; $00 - space character           CHR$(0)
4805   0E00             
4806   0E00 00          L0E00:  DEFB    %00000000
4807   0E01 00                  DEFB    %00000000
4808   0E02 00                  DEFB    %00000000
4809   0E03 00                  DEFB    %00000000
4810   0E04 00                  DEFB    %00000000
4811   0E05 00                  DEFB    %00000000
4812   0E06 00                  DEFB    %00000000
4813   0E07 00                  DEFB    %00000000
4814   0E08             
4815   0E08             ; $01 - Character: '"'            CHR$(1)
4816   0E08             
4817   0E08 00                  DEFB    %00000000
4818   0E09 14                  DEFB    %00010100
4819   0E0A 14                  DEFB    %00010100
4820   0E0B 00                  DEFB    %00000000
4821   0E0C 00                  DEFB    %00000000
4822   0E0D 00                  DEFB    %00000000
4823   0E0E 00                  DEFB    %00000000
4824   0E0F 00                  DEFB    %00000000
4825   0E10             
4826   0E10             ; $02 - Character: mosaic         CHR$(2)
4827   0E10             
4828   0E10 F0                  DEFB    %11110000
4829   0E11 F0                  DEFB    %11110000
4830   0E12 F0                  DEFB    %11110000
4831   0E13 F0                  DEFB    %11110000
4832   0E14 F0                  DEFB    %11110000
4833   0E15 F0                  DEFB    %11110000
4834   0E16 F0                  DEFB    %11110000
4835   0E17 F0                  DEFB    %11110000
4836   0E18             
4837   0E18             ; $03 - Character: mosaic         CHR$(3)
4838   0E18             
4839   0E18 00                  DEFB    %00000000
4840   0E19 00                  DEFB    %00000000
4841   0E1A 00                  DEFB    %00000000
4842   0E1B 00                  DEFB    %00000000
4843   0E1C FF                  DEFB    %11111111
4844   0E1D FF                  DEFB    %11111111
4845   0E1E FF                  DEFB    %11111111
4846   0E1F FF                  DEFB    %11111111
4847   0E20             
4848   0E20             ; $04 - Character: mosaic         CHR$(4)
4849   0E20             
4850   0E20 F0                  DEFB    %11110000
4851   0E21 F0                  DEFB    %11110000
4852   0E22 F0                  DEFB    %11110000
4853   0E23 F0                  DEFB    %11110000
4854   0E24 00                  DEFB    %00000000
4855   0E25 00                  DEFB    %00000000
4856   0E26 00                  DEFB    %00000000
4857   0E27 00                  DEFB    %00000000
4858   0E28             
4859   0E28             ; $05 - Character: mosaic         CHR$(5)
4860   0E28             
4861   0E28 0F                  DEFB    %00001111
4862   0E29 0F                  DEFB    %00001111
4863   0E2A 0F                  DEFB    %00001111
4864   0E2B 0F                  DEFB    %00001111
4865   0E2C 00                  DEFB    %00000000
4866   0E2D 00                  DEFB    %00000000
4867   0E2E 00                  DEFB    %00000000
4868   0E2F 00                  DEFB    %00000000
4869   0E30             
4870   0E30             ; $06 - Character: mosaic         CHR$(6)
4871   0E30             
4872   0E30 00                  DEFB    %00000000
4873   0E31 00                  DEFB    %00000000
4874   0E32 00                  DEFB    %00000000
4875   0E33 00                  DEFB    %00000000
4876   0E34 F0                  DEFB    %11110000
4877   0E35 F0                  DEFB    %11110000
4878   0E36 F0                  DEFB    %11110000
4879   0E37 F0                  DEFB    %11110000
4880   0E38             
4881   0E38             ; $07 - Character: mosaic         CHR$(7)
4882   0E38             
4883   0E38 00                  DEFB    %00000000
4884   0E39 00                  DEFB    %00000000
4885   0E3A 00                  DEFB    %00000000
4886   0E3B 00                  DEFB    %00000000
4887   0E3C 0F                  DEFB    %00001111
4888   0E3D 0F                  DEFB    %00001111
4889   0E3E 0F                  DEFB    %00001111
4890   0E3F 0F                  DEFB    %00001111
4891   0E40             
4892   0E40             ; $08 - Character: mosaic         CHR$(8)
4893   0E40             
4894   0E40 0F                  DEFB    %00001111
4895   0E41 0F                  DEFB    %00001111
4896   0E42 0F                  DEFB    %00001111
4897   0E43 0F                  DEFB    %00001111
4898   0E44 F0                  DEFB    %11110000
4899   0E45 F0                  DEFB    %11110000
4900   0E46 F0                  DEFB    %11110000
4901   0E47 F0                  DEFB    %11110000
4902   0E48             
4903   0E48             ; $09 - Character: mosaic         CHR$(9)
4904   0E48             
4905   0E48 AA                  DEFB    %10101010
4906   0E49 55                  DEFB    %01010101
4907   0E4A AA                  DEFB    %10101010
4908   0E4B 55                  DEFB    %01010101
4909   0E4C AA                  DEFB    %10101010
4910   0E4D 55                  DEFB    %01010101
4911   0E4E AA                  DEFB    %10101010
4912   0E4F 55                  DEFB    %01010101
4913   0E50             
4914   0E50             ; $0A - Character: mosaic         CHR$(10)
4915   0E50             
4916   0E50 00                  DEFB    %00000000
4917   0E51 00                  DEFB    %00000000
4918   0E52 00                  DEFB    %00000000
4919   0E53 00                  DEFB    %00000000
4920   0E54 AA                  DEFB    %10101010
4921   0E55 55                  DEFB    %01010101
4922   0E56 AA                  DEFB    %10101010
4923   0E57 55                  DEFB    %01010101
4924   0E58             
4925   0E58             ; $0B - Character: mosaic         CHR$(11)
4926   0E58             
4927   0E58 AA                  DEFB    %10101010
4928   0E59 55                  DEFB    %01010101
4929   0E5A AA                  DEFB    %10101010
4930   0E5B 55                  DEFB    %01010101
4931   0E5C 00                  DEFB    %00000000
4932   0E5D 00                  DEFB    %00000000
4933   0E5E 00                  DEFB    %00000000
4934   0E5F 00                  DEFB    %00000000
4935   0E60             
4936   0E60             ; $0C - Character: uk pound       CHR$(12)
4937   0E60             
4938   0E60 00                  DEFB    %00000000
4939   0E61 1E                  DEFB    %00011110
4940   0E62 21                  DEFB    %00100001
4941   0E63 78                  DEFB    %01111000
4942   0E64 20                  DEFB    %00100000
4943   0E65 20                  DEFB    %00100000
4944   0E66 7F                  DEFB    %01111111
4945   0E67 00                  DEFB    %00000000
4946   0E68             
4947   0E68             ; $0D - Character: '$'            CHR$(13)
4948   0E68             
4949   0E68 00                  DEFB    %00000000
4950   0E69 08                  DEFB    %00001000
4951   0E6A 3E                  DEFB    %00111110
4952   0E6B 48                  DEFB    %01001000
4953   0E6C 3E                  DEFB    %00111110
4954   0E6D 09                  DEFB    %00001001
4955   0E6E 3E                  DEFB    %00111110
4956   0E6F 08                  DEFB    %00001000
4957   0E70             
4958   0E70             ; $0E - Character: ':'            CHR$(14)
4959   0E70             
4960   0E70 00                  DEFB    %00000000
4961   0E71 00                  DEFB    %00000000
4962   0E72 00                  DEFB    %00000000
4963   0E73 08                  DEFB    %00001000
4964   0E74 00                  DEFB    %00000000
4965   0E75 00                  DEFB    %00000000
4966   0E76 08                  DEFB    %00001000
4967   0E77 00                  DEFB    %00000000
4968   0E78             
4969   0E78             ; $0F - Character: '?'            CHR$(15)
4970   0E78             
4971   0E78 00                  DEFB    %00000000
4972   0E79 3E                  DEFB    %00111110
4973   0E7A 41                  DEFB    %01000001
4974   0E7B 06                  DEFB    %00000110
4975   0E7C 08                  DEFB    %00001000
4976   0E7D 00                  DEFB    %00000000
4977   0E7E 08                  DEFB    %00001000
4978   0E7F 00                  DEFB    %00000000
4979   0E80             
4980   0E80             ; $10 - Character: '('            CHR$(16)
4981   0E80             
4982   0E80 00                  DEFB    %00000000
4983   0E81 04                  DEFB    %00000100
4984   0E82 08                  DEFB    %00001000
4985   0E83 08                  DEFB    %00001000
4986   0E84 08                  DEFB    %00001000
4987   0E85 08                  DEFB    %00001000
4988   0E86 04                  DEFB    %00000100
4989   0E87 00                  DEFB    %00000000
4990   0E88             
4991   0E88             ; $11 - Character: ')'            CHR$(17)
4992   0E88             
4993   0E88 00                  DEFB    %00000000
4994   0E89 10                  DEFB    %00010000
4995   0E8A 08                  DEFB    %00001000
4996   0E8B 08                  DEFB    %00001000
4997   0E8C 08                  DEFB    %00001000
4998   0E8D 08                  DEFB    %00001000
4999   0E8E 10                  DEFB    %00010000
5000   0E8F 00                  DEFB    %00000000
5001   0E90             
5002   0E90             ; $12 - Character: '-'            CHR$(18)
5003   0E90             
5004   0E90 00                  DEFB    %00000000
5005   0E91 00                  DEFB    %00000000
5006   0E92 00                  DEFB    %00000000
5007   0E93 00                  DEFB    %00000000
5008   0E94 3E                  DEFB    %00111110
5009   0E95 00                  DEFB    %00000000
5010   0E96 00                  DEFB    %00000000
5011   0E97 00                  DEFB    %00000000
5012   0E98             
5013   0E98             ; $13 - Character: '+'            CHR$(19)
5014   0E98             
5015   0E98 00                  DEFB    %00000000
5016   0E99 00                  DEFB    %00000000
5017   0E9A 08                  DEFB    %00001000
5018   0E9B 08                  DEFB    %00001000
5019   0E9C 3E                  DEFB    %00111110
5020   0E9D 08                  DEFB    %00001000
5021   0E9E 08                  DEFB    %00001000
5022   0E9F 00                  DEFB    %00000000
5023   0EA0             
5024   0EA0             ; $14 - Character: '*'            CHR$(20)
5025   0EA0             
5026   0EA0 00                  DEFB    %00000000
5027   0EA1 00                  DEFB    %00000000
5028   0EA2 2A                  DEFB    %00101010
5029   0EA3 1C                  DEFB    %00011100
5030   0EA4 08                  DEFB    %00001000
5031   0EA5 1C                  DEFB    %00011100
5032   0EA6 2A                  DEFB    %00101010
5033   0EA7 00                  DEFB    %00000000
5034   0EA8             
5035   0EA8             ; $15 - Character: '/'            CHR$(21)
5036   0EA8             
5037   0EA8 00                  DEFB    %00000000
5038   0EA9 00                  DEFB    %00000000
5039   0EAA 02                  DEFB    %00000010
5040   0EAB 04                  DEFB    %00000100
5041   0EAC 08                  DEFB    %00001000
5042   0EAD 10                  DEFB    %00010000
5043   0EAE 20                  DEFB    %00100000
5044   0EAF 00                  DEFB    %00000000
5045   0EB0             
5046   0EB0             ; $16 - Character: '='            CHR$(22)
5047   0EB0             
5048   0EB0 00                  DEFB    %00000000
5049   0EB1 00                  DEFB    %00000000
5050   0EB2 00                  DEFB    %00000000
5051   0EB3 3E                  DEFB    %00111110
5052   0EB4 00                  DEFB    %00000000
5053   0EB5 3E                  DEFB    %00111110
5054   0EB6 00                  DEFB    %00000000
5055   0EB7 00                  DEFB    %00000000
5056   0EB8             
5057   0EB8             ; $17 - Character: '>'            CHR$(23)
5058   0EB8             
5059   0EB8 00                  DEFB    %00000000
5060   0EB9 00                  DEFB    %00000000
5061   0EBA 10                  DEFB    %00010000
5062   0EBB 08                  DEFB    %00001000
5063   0EBC 04                  DEFB    %00000100
5064   0EBD 08                  DEFB    %00001000
5065   0EBE 10                  DEFB    %00010000
5066   0EBF 00                  DEFB    %00000000
5067   0EC0             
5068   0EC0             ; $18 - Character: '<'            CHR$(24)
5069   0EC0             
5070   0EC0 00                  DEFB    %00000000
5071   0EC1 00                  DEFB    %00000000
5072   0EC2 04                  DEFB    %00000100
5073   0EC3 08                  DEFB    %00001000
5074   0EC4 10                  DEFB    %00010000
5075   0EC5 08                  DEFB    %00001000
5076   0EC6 04                  DEFB    %00000100
5077   0EC7 00                  DEFB    %00000000
5078   0EC8             
5079   0EC8             ; $19 - Character: ';'            CHR$(25)
5080   0EC8             
5081   0EC8 00                  DEFB    %00000000
5082   0EC9 00                  DEFB    %00000000
5083   0ECA 08                  DEFB    %00001000
5084   0ECB 00                  DEFB    %00000000
5085   0ECC 00                  DEFB    %00000000
5086   0ECD 08                  DEFB    %00001000
5087   0ECE 08                  DEFB    %00001000
5088   0ECF 10                  DEFB    %00010000
5089   0ED0             
5090   0ED0             ; $1A - Character: ','            CHR$(26)
5091   0ED0             
5092   0ED0 00                  DEFB    %00000000
5093   0ED1 00                  DEFB    %00000000
5094   0ED2 00                  DEFB    %00000000
5095   0ED3 00                  DEFB    %00000000
5096   0ED4 00                  DEFB    %00000000
5097   0ED5 08                  DEFB    %00001000
5098   0ED6 08                  DEFB    %00001000
5099   0ED7 10                  DEFB    %00010000
5100   0ED8             
5101   0ED8             ; $1B - Character: '.'            CHR$(27)
5102   0ED8             
5103   0ED8 00                  DEFB    %00000000
5104   0ED9 00                  DEFB    %00000000
5105   0EDA 00                  DEFB    %00000000
5106   0EDB 00                  DEFB    %00000000
5107   0EDC 00                  DEFB    %00000000
5108   0EDD 0C                  DEFB    %00001100
5109   0EDE 0C                  DEFB    %00001100
5110   0EDF 00                  DEFB    %00000000
5111   0EE0             
5112   0EE0             ; $1C - Character: '0'            CHR$(28)
5113   0EE0             
5114   0EE0 00                  DEFB    %00000000
5115   0EE1 1C                  DEFB    %00011100
5116   0EE2 22                  DEFB    %00100010
5117   0EE3 41                  DEFB    %01000001
5118   0EE4 41                  DEFB    %01000001
5119   0EE5 22                  DEFB    %00100010
5120   0EE6 1C                  DEFB    %00011100
5121   0EE7 00                  DEFB    %00000000
5122   0EE8             
5123   0EE8             ; $1D - Character: '1'            CHR$(29)
5124   0EE8             
5125   0EE8 00                  DEFB    %00000000
5126   0EE9 0C                  DEFB    %00001100
5127   0EEA 14                  DEFB    %00010100
5128   0EEB 04                  DEFB    %00000100
5129   0EEC 04                  DEFB    %00000100
5130   0EED 04                  DEFB    %00000100
5131   0EEE 1E                  DEFB    %00011110
5132   0EEF 00                  DEFB    %00000000
5133   0EF0             
5134   0EF0             ; $1E - Character: '2'            CHR$(30)
5135   0EF0             
5136   0EF0 00                  DEFB    %00000000
5137   0EF1 3E                  DEFB    %00111110
5138   0EF2 41                  DEFB    %01000001
5139   0EF3 01                  DEFB    %00000001
5140   0EF4 3E                  DEFB    %00111110
5141   0EF5 40                  DEFB    %01000000
5142   0EF6 7F                  DEFB    %01111111
5143   0EF7 00                  DEFB    %00000000
5144   0EF8             
5145   0EF8             ; $1F - Character: '3'            CHR$(31)
5146   0EF8             
5147   0EF8 00                  DEFB    %00000000
5148   0EF9 3E                  DEFB    %00111110
5149   0EFA 41                  DEFB    %01000001
5150   0EFB 06                  DEFB    %00000110
5151   0EFC 01                  DEFB    %00000001
5152   0EFD 41                  DEFB    %01000001
5153   0EFE 3E                  DEFB    %00111110
5154   0EFF 00                  DEFB    %00000000
5155   0F00             
5156   0F00             ; $20 - Character: '4'            CHR$(32)
5157   0F00             
5158   0F00 00                  DEFB    %00000000
5159   0F01 0C                  DEFB    %00001100
5160   0F02 14                  DEFB    %00010100
5161   0F03 24                  DEFB    %00100100
5162   0F04 44                  DEFB    %01000100
5163   0F05 7F                  DEFB    %01111111
5164   0F06 04                  DEFB    %00000100
5165   0F07 00                  DEFB    %00000000
5166   0F08             
5167   0F08             ; $21 - Character: '5'            CHR$(33)
5168   0F08             
5169   0F08 00                  DEFB    %00000000
5170   0F09 7F                  DEFB    %01111111
5171   0F0A 40                  DEFB    %01000000
5172   0F0B 7E                  DEFB    %01111110
5173   0F0C 01                  DEFB    %00000001
5174   0F0D 41                  DEFB    %01000001
5175   0F0E 3E                  DEFB    %00111110
5176   0F0F 00                  DEFB    %00000000
5177   0F10             
5178   0F10             ; $22 - Character: '6'            CHR$(34)
5179   0F10             
5180   0F10 00                  DEFB    %00000000
5181   0F11 3E                  DEFB    %00111110
5182   0F12 40                  DEFB    %01000000
5183   0F13 7E                  DEFB    %01111110
5184   0F14 41                  DEFB    %01000001
5185   0F15 41                  DEFB    %01000001
5186   0F16 3E                  DEFB    %00111110
5187   0F17 00                  DEFB    %00000000
5188   0F18             
5189   0F18             ; $23 - Character: '7'            CHR$(35)
5190   0F18             
5191   0F18 00                  DEFB    %00000000
5192   0F19 7F                  DEFB    %01111111
5193   0F1A 01                  DEFB    %00000001
5194   0F1B 02                  DEFB    %00000010
5195   0F1C 04                  DEFB    %00000100
5196   0F1D 08                  DEFB    %00001000
5197   0F1E 08                  DEFB    %00001000
5198   0F1F 00                  DEFB    %00000000
5199   0F20             
5200   0F20             ; $24 - Character: '8'            CHR$(36)
5201   0F20             
5202   0F20 00                  DEFB    %00000000
5203   0F21 3E                  DEFB    %00111110
5204   0F22 41                  DEFB    %01000001
5205   0F23 3E                  DEFB    %00111110
5206   0F24 41                  DEFB    %01000001
5207   0F25 41                  DEFB    %01000001
5208   0F26 3E                  DEFB    %00111110
5209   0F27 00                  DEFB    %00000000
5210   0F28             
5211   0F28             ; $25 - Character: '9'            CHR$(37)
5212   0F28             
5213   0F28 00                  DEFB    %00000000
5214   0F29 3E                  DEFB    %00111110
5215   0F2A 41                  DEFB    %01000001
5216   0F2B 41                  DEFB    %01000001
5217   0F2C 3F                  DEFB    %00111111
5218   0F2D 01                  DEFB    %00000001
5219   0F2E 3E                  DEFB    %00111110
5220   0F2F 00                  DEFB    %00000000
5221   0F30             
5222   0F30             ; $26 - Character: 'A'            CHR$(38)
5223   0F30             
5224   0F30 00                  DEFB    %00000000
5225   0F31 3E                  DEFB    %00111110
5226   0F32 41                  DEFB    %01000001
5227   0F33 41                  DEFB    %01000001
5228   0F34 7F                  DEFB    %01111111
5229   0F35 41                  DEFB    %01000001
5230   0F36 41                  DEFB    %01000001
5231   0F37 00                  DEFB    %00000000
5232   0F38             
5233   0F38             ; $27 - Character: 'B'            CHR$(39)
5234   0F38             
5235   0F38 00                  DEFB    %00000000
5236   0F39 7E                  DEFB    %01111110
5237   0F3A 41                  DEFB    %01000001
5238   0F3B 7E                  DEFB    %01111110
5239   0F3C 41                  DEFB    %01000001
5240   0F3D 41                  DEFB    %01000001
5241   0F3E 7E                  DEFB    %01111110
5242   0F3F 00                  DEFB    %00000000
5243   0F40             
5244   0F40             ; $28 - Character: 'C'            CHR$(40)
5245   0F40             
5246   0F40 00                  DEFB    %00000000
5247   0F41 1E                  DEFB    %00011110
5248   0F42 21                  DEFB    %00100001
5249   0F43 40                  DEFB    %01000000
5250   0F44 40                  DEFB    %01000000
5251   0F45 21                  DEFB    %00100001
5252   0F46 1E                  DEFB    %00011110
5253   0F47 00                  DEFB    %00000000
5254   0F48             
5255   0F48             ; $29 - Character: 'D'            CHR$(41)
5256   0F48             
5257   0F48 00                  DEFB    %00000000
5258   0F49 7C                  DEFB    %01111100
5259   0F4A 42                  DEFB    %01000010
5260   0F4B 41                  DEFB    %01000001
5261   0F4C 41                  DEFB    %01000001
5262   0F4D 42                  DEFB    %01000010
5263   0F4E 7C                  DEFB    %01111100
5264   0F4F 00                  DEFB    %00000000
5265   0F50             
5266   0F50             ; $2A - Character: 'E'            CHR$(42)
5267   0F50             
5268   0F50 00                  DEFB    %00000000
5269   0F51 7F                  DEFB    %01111111
5270   0F52 40                  DEFB    %01000000
5271   0F53 7C                  DEFB    %01111100
5272   0F54 40                  DEFB    %01000000
5273   0F55 40                  DEFB    %01000000
5274   0F56 7F                  DEFB    %01111111
5275   0F57 00                  DEFB    %00000000
5276   0F58             
5277   0F58             ; $2B - Character: 'F'            CHR$(43)
5278   0F58             
5279   0F58 00                  DEFB    %00000000
5280   0F59 7F                  DEFB    %01111111
5281   0F5A 40                  DEFB    %01000000
5282   0F5B 7C                  DEFB    %01111100
5283   0F5C 40                  DEFB    %01000000
5284   0F5D 40                  DEFB    %01000000
5285   0F5E 40                  DEFB    %01000000
5286   0F5F 00                  DEFB    %00000000
5287   0F60             
5288   0F60             ; $2C - Character: 'G'            CHR$(44)
5289   0F60             
5290   0F60 00                  DEFB    %00000000
5291   0F61 1E                  DEFB    %00011110
5292   0F62 21                  DEFB    %00100001
5293   0F63 40                  DEFB    %01000000
5294   0F64 47                  DEFB    %01000111
5295   0F65 21                  DEFB    %00100001
5296   0F66 1E                  DEFB    %00011110
5297   0F67 00                  DEFB    %00000000
5298   0F68             
5299   0F68             ; $2D - Character: 'H'            CHR$(45)
5300   0F68             
5301   0F68 00                  DEFB    %00000000
5302   0F69 41                  DEFB    %01000001
5303   0F6A 41                  DEFB    %01000001
5304   0F6B 7F                  DEFB    %01111111
5305   0F6C 41                  DEFB    %01000001
5306   0F6D 41                  DEFB    %01000001
5307   0F6E 41                  DEFB    %01000001
5308   0F6F 00                  DEFB    %00000000
5309   0F70             
5310   0F70             ; $2E - Character: 'I'            CHR$(46)
5311   0F70             
5312   0F70 00                  DEFB    %00000000
5313   0F71 3E                  DEFB    %00111110
5314   0F72 08                  DEFB    %00001000
5315   0F73 08                  DEFB    %00001000
5316   0F74 08                  DEFB    %00001000
5317   0F75 08                  DEFB    %00001000
5318   0F76 3E                  DEFB    %00111110
5319   0F77 00                  DEFB    %00000000
5320   0F78             
5321   0F78             ; $2F - Character: 'J'            CHR$(47)
5322   0F78             
5323   0F78 00                  DEFB    %00000000
5324   0F79 02                  DEFB    %00000010
5325   0F7A 02                  DEFB    %00000010
5326   0F7B 02                  DEFB    %00000010
5327   0F7C 42                  DEFB    %01000010
5328   0F7D 22                  DEFB    %00100010
5329   0F7E 1C                  DEFB    %00011100
5330   0F7F 00                  DEFB    %00000000
5331   0F80             
5332   0F80             ; $30 - Character: 'K'            CHR$(48)
5333   0F80             
5334   0F80 00                  DEFB    %00000000
5335   0F81 42                  DEFB    %01000010
5336   0F82 44                  DEFB    %01000100
5337   0F83 78                  DEFB    %01111000
5338   0F84 44                  DEFB    %01000100
5339   0F85 42                  DEFB    %01000010
5340   0F86 41                  DEFB    %01000001
5341   0F87 00                  DEFB    %00000000
5342   0F88             
5343   0F88             ; $31 - Character: 'L'            CHR$(49)
5344   0F88             
5345   0F88 00                  DEFB    %00000000
5346   0F89 40                  DEFB    %01000000
5347   0F8A 40                  DEFB    %01000000
5348   0F8B 40                  DEFB    %01000000
5349   0F8C 40                  DEFB    %01000000
5350   0F8D 40                  DEFB    %01000000
5351   0F8E 7F                  DEFB    %01111111
5352   0F8F 00                  DEFB    %00000000
5353   0F90             
5354   0F90             ; $32 - Character: 'M'            CHR$(50)
5355   0F90             
5356   0F90 00                  DEFB    %00000000
5357   0F91 41                  DEFB    %01000001
5358   0F92 63                  DEFB    %01100011
5359   0F93 55                  DEFB    %01010101
5360   0F94 49                  DEFB    %01001001
5361   0F95 41                  DEFB    %01000001
5362   0F96 41                  DEFB    %01000001
5363   0F97 00                  DEFB    %00000000
5364   0F98             
5365   0F98             ; $33 - Character: 'N'            CHR$(51)
5366   0F98             
5367   0F98 00                  DEFB    %00000000
5368   0F99 61                  DEFB    %01100001
5369   0F9A 51                  DEFB    %01010001
5370   0F9B 49                  DEFB    %01001001
5371   0F9C 45                  DEFB    %01000101
5372   0F9D 43                  DEFB    %01000011
5373   0F9E 41                  DEFB    %01000001
5374   0F9F 00                  DEFB    %00000000
5375   0FA0             
5376   0FA0             ; $34 - Character: 'O'            CHR$(52)
5377   0FA0             
5378   0FA0 00                  DEFB    %00000000
5379   0FA1 3E                  DEFB    %00111110
5380   0FA2 41                  DEFB    %01000001
5381   0FA3 41                  DEFB    %01000001
5382   0FA4 41                  DEFB    %01000001
5383   0FA5 41                  DEFB    %01000001
5384   0FA6 3E                  DEFB    %00111110
5385   0FA7 00                  DEFB    %00000000
5386   0FA8             
5387   0FA8             ; $35 - Character: 'P'            CHR$(53)
5388   0FA8             
5389   0FA8 00                  DEFB    %00000000
5390   0FA9 7E                  DEFB    %01111110
5391   0FAA 41                  DEFB    %01000001
5392   0FAB 41                  DEFB    %01000001
5393   0FAC 7E                  DEFB    %01111110
5394   0FAD 40                  DEFB    %01000000
5395   0FAE 40                  DEFB    %01000000
5396   0FAF 00                  DEFB    %00000000
5397   0FB0             
5398   0FB0             ; $36 - Character: 'Q'            CHR$(54)
5399   0FB0             
5400   0FB0 00                  DEFB    %00000000
5401   0FB1 3E                  DEFB    %00111110
5402   0FB2 41                  DEFB    %01000001
5403   0FB3 41                  DEFB    %01000001
5404   0FB4 49                  DEFB    %01001001
5405   0FB5 45                  DEFB    %01000101
5406   0FB6 3E                  DEFB    %00111110
5407   0FB7 00                  DEFB    %00000000
5408   0FB8             
5409   0FB8             ; $37 - Character: 'R'            CHR$(55)
5410   0FB8             
5411   0FB8 00                  DEFB    %00000000
5412   0FB9 7E                  DEFB    %01111110
5413   0FBA 41                  DEFB    %01000001
5414   0FBB 41                  DEFB    %01000001
5415   0FBC 7E                  DEFB    %01111110
5416   0FBD 44                  DEFB    %01000100
5417   0FBE 42                  DEFB    %01000010
5418   0FBF 00                  DEFB    %00000000
5419   0FC0             
5420   0FC0             ; $38 - Character: 'S'            CHR$(56)
5421   0FC0             
5422   0FC0 00                  DEFB    %00000000
5423   0FC1 3E                  DEFB    %00111110
5424   0FC2 40                  DEFB    %01000000
5425   0FC3 3E                  DEFB    %00111110
5426   0FC4 01                  DEFB    %00000001
5427   0FC5 41                  DEFB    %01000001
5428   0FC6 3E                  DEFB    %00111110
5429   0FC7 00                  DEFB    %00000000
5430   0FC8             
5431   0FC8             ; $39 - Character: 'T'            CHR$(57)
5432   0FC8             
5433   0FC8 00                  DEFB    %00000000
5434   0FC9 7F                  DEFB    %01111111
5435   0FCA 08                  DEFB    %00001000
5436   0FCB 08                  DEFB    %00001000
5437   0FCC 08                  DEFB    %00001000
5438   0FCD 08                  DEFB    %00001000
5439   0FCE 08                  DEFB    %00001000
5440   0FCF 00                  DEFB    %00000000
5441   0FD0             
5442   0FD0             ; $3A - Character: 'U'            CHR$(58)
5443   0FD0             
5444   0FD0 00                  DEFB    %00000000
5445   0FD1 41                  DEFB    %01000001
5446   0FD2 41                  DEFB    %01000001
5447   0FD3 41                  DEFB    %01000001
5448   0FD4 41                  DEFB    %01000001
5449   0FD5 41                  DEFB    %01000001
5450   0FD6 3E                  DEFB    %00111110
5451   0FD7 00                  DEFB    %00000000
5452   0FD8             
5453   0FD8             ; $3B - Character: 'V'            CHR$(59)
5454   0FD8             
5455   0FD8 00                  DEFB    %00000000
5456   0FD9 41                  DEFB    %01000001
5457   0FDA 41                  DEFB    %01000001
5458   0FDB 41                  DEFB    %01000001
5459   0FDC 22                  DEFB    %00100010
5460   0FDD 14                  DEFB    %00010100
5461   0FDE 08                  DEFB    %00001000
5462   0FDF 00                  DEFB    %00000000
5463   0FE0             
5464   0FE0             ; $3C - Character: 'W'            CHR$(60)
5465   0FE0             
5466   0FE0 00                  DEFB    %00000000
5467   0FE1 41                  DEFB    %01000001
5468   0FE2 41                  DEFB    %01000001
5469   0FE3 41                  DEFB    %01000001
5470   0FE4 49                  DEFB    %01001001
5471   0FE5 55                  DEFB    %01010101
5472   0FE6 22                  DEFB    %00100010
5473   0FE7 00                  DEFB    %00000000
5474   0FE8             
5475   0FE8             ; $3D - Character: 'X'            CHR$(61)
5476   0FE8             
5477   0FE8 00                  DEFB    %00000000
5478   0FE9 21                  DEFB    %00100001
5479   0FEA 12                  DEFB    %00010010
5480   0FEB 0C                  DEFB    %00001100
5481   0FEC 0C                  DEFB    %00001100
5482   0FED 12                  DEFB    %00010010
5483   0FEE 21                  DEFB    %00100001
5484   0FEF 00                  DEFB    %00000000
5485   0FF0             
5486   0FF0             ; $3E - Character: 'Y'            CHR$(62)
5487   0FF0             
5488   0FF0 00                  DEFB    %00000000
5489   0FF1 41                  DEFB    %01000001
5490   0FF2 22                  DEFB    %00100010
5491   0FF3 1C                  DEFB    %00011100
5492   0FF4 08                  DEFB    %00001000
5493   0FF5 08                  DEFB    %00001000
5494   0FF6 08                  DEFB    %00001000
5495   0FF7 00                  DEFB    %00000000
5496   0FF8             
5497   0FF8             ; $3F - Character: 'Z'            CHR$(63)
5498   0FF8             
5499   0FF8 00                  DEFB    %00000000
5500   0FF9 7F                  DEFB    %01111111
5501   0FFA 02                  DEFB    %00000010
5502   0FFB 04                  DEFB    %00000100
5503   0FFC 08                  DEFB    %00001000
5504   0FFD 10                  DEFB    %00010000
5505   0FFE 7F                  DEFB    %01111111
5506   0FFF 00          L0FFF:  DEFB    %00000000
5507   1000             
5508   1000             ;##################################
5509   1000             ;# Extras
5510   1000             
5511   1000             
5512   1000             
5513   1000             ;##############################################################################
5514   1000             ; Initialisation code for the 4TH
5515   1000             ;
5516   1000             ; Clear the video RAM and load the ZX80 font into the font RAM
5517   1000             ; Display a banner, which will remain until interrupts are enabled
5518   1000             ;
5519   1000             
5520   1000             INIT_4TH:
5521   1000             
5522   1000             ; Fill all the video RAM with zeroes (space)
5523   1000             CLEAR_VIDEO_RAM:
5524   1000 21 00 24            LD      HL, $2400       ; start of video RAM
5525   1003 11 01 24            LD      DE, $2401       ; the next byte
5526   1006 01 FF 03            LD      BC, $03FF       ; number of bytes to clear (video RAM + mirror of font RAM)
5527   1009 36 00               LD      (HL), $00       ; Clear the first byte
5528   100B ED B0               LDIR                    ; Clear all the rest
5529   100D             
5530   100D             ; copy the ZX80 font into the first half of font RAM
5531   100D             COPYFONT:        
5532   100D 01 00 02            LD      BC, $0200       ; There are 64 bit-mapped 8x8 characters
5533   1010 11 00 2C            LD      DE, $2C00       ; Destination is write only font RAM
5534   1013 21 00 0E            LD      HL, $0E00       ; ZX80 font in ROM
5535   1016 ED B0               LDIR                    ; Copy font from ROM to RAM
5536   1018             
5537   1018             ; copy a banner message onto the top of the screen
5538   1018             BANNER:
5539   1018 11 00 24            LD      DE, $2400       ; Copy banner text to top of 4TH video RAM 
5540   101B 21 12 12            LD      HL, BANNER_TEXT
5541   101E 01 20 00            LD      BC, BANNER_TEXT_END-BANNER_TEXT
5542   1021 ED B0               LDIR
5543   1023             
5544   1023             ; clear the remaining 64 characters in the font RAM
5545   1023             CLEARUDGS:
5546   1023 21 00 2E            LD      HL, $2E00       ; start of second 64 character font RAM
5547   1026 11 01 2E            LD      DE, $2E01       ; the next byte
5548   1029 01 FF 01            LD      BC, $01FF       ; number of bytes to clear (video RAM + mirror of font RAM)
5549   102C 36 00               LD      (HL), $00       ; Clear the first byte
5550   102E ED B0               LDIR                    ; Clear all the rest
5551   1030             
5552   1030             ; resume where the initial reset function
5553   1030             ON_TO_RAM_CHECK:
5554   1030 21 FF 7F            LD      HL,$7FFF        ; top of possible RAM.
5555   1033                                             ; (highest integer is 32767).
5556   1033 3E 3F               LD      A,$3F           ; page before RAM.
5557   1035 C3 61 02            JP      L0261           ; on to RAM-FILL.
5558   1038             
5559   1038             
5560   1038             ; interrupting the init routine to add a banner
5561   1038             INIT_BANNER:
5562   1038 22 0A 40            LD      ($400A),HL      ; set the system variable E_LINE.
5563   103B 36 B0               LD      (HL),$B0        ; insert the character inverse 'K'.
5564   103D             
5565   103D 23                  INC     HL              ; address the next location.
5566   103E 36 76               LD      (HL),$76        ; insert a newline.
5567   1040             
5568   1040 23                  INC     HL              ; address the next location.
5569   1041 22 0C 40            LD      ($400C),HL      ; set D-FILE to start of dynamic display file.
5570   1044 FD 36 12 02         LD      (IY+$12),$02    ; set DF-SZ to 2 lines.
5571   1048             
5572   1048                     ; replacement CLS function
5573   1048 36 76               LD      (HL),$76        ; insert a single newline.
5574   104A 23                  INC     HL              ; advance address.
5575   104B             
5576   104B EB                  EX      DE,HL           ; DE now contains D-FILE location
5577   104C 21 12 12            LD      HL, BANNER_TEXT
5578   104F 01 20 00            LD      BC, BANNER_TEXT_END-BANNER_TEXT
5579   1052 ED B0               LDIR
5580   1054             
5581   1054 EB                  EX      DE,HL           ; HL now contains D-FILE location
5582   1055                     
5583   1055 CD 4D 07            CALL    L074D           ; call the original CLS routine
5584   1058             
5585   1058 C3 96 02            JP      L0296           ; return to just after the CLS
5586   105B             
5587   105B             
5588   105B             ;##########################################################
5589   105B             ; Double buffer the ZX80 video frame to the 4TH screen RAM
5590   105B             
5591   105B             ; this is called twice, once to produce the top border and main screen
5592   105B             ; and again to produce the bottom border.
5593   105B             
5594   105B             ; The first call witll copy the screen, 
5595   105B             ; the sender will wait for the interrupt at the end of the screen
5596   105B             
5597   105B             DISPLAY_ROUTINE:
5598   105B 05                  DEC     B               ; decrement row counter (24 = top, 1 = bottom)
5599   105C 20 04               JR      NZ, COPY_SCREEN ; if B was > 1, draw the screen to the 4TH RAM
5600   105E             
5601   105E             ; second call, display has finished, so wait until the start of the next frame                                
5602   105E FB                  EI                      ; enable interrupts.
5603   105F 76                  HALT                    ; halt and wait for the next interrupt
5604   1060 F3                  DI                      ; disable interrupts until next time.
5605   1061             
5606   1061 C9                  RET                     ; finished.
5607   1062             
5608   1062             ; On the first call, copy the display to the 4TH video RAM
5609   1062             COPY_SCREEN:
5610   1062 CB BC               RES     7, H            ; move the display file pointer back to low RAM
5611   1064             
5612   1064 23                  INC     HL              ; Skip over the first HALT / newline
5613   1065 11 00 24            LD      DE,$2400        ; Minstrel 4th screen RAM
5614   1068                             
5615   1068 48                  LD      C, B            ; line counter from B (pad to 24 at end?)
5616   1069                     
5617   1069             COPY_LINE:
5618   1069 06 20               LD      B,$20           ; 32 characters per line
5619   106B             
5620   106B             COPY_CHAR:
5621   106B 7E                  LD      A,(HL)          ; read the character
5622   106C 23                  INC     HL              ; next character
5623   106D FE 76               CP      $76             ; check for CR/Halt
5624   106F 28 07               JR      Z, PAD_LINE     ; skip to padding if it is
5625   1071             
5626   1071 12                  LD      (DE),A          ; write the character
5627   1072 13                  INC     DE              ; next character
5628   1073 10 F6               DJNZ    COPY_CHAR       ; loop
5629   1075 23                  INC     HL              ; skip next character (should be HALT / newline)
5630   1076 18 05               JR      CHECK_END       ; finished?
5631   1078             
5632   1078             PAD_LINE:
5633   1078 AF                  XOR     A               ; set A to $00, space        
5634   1079             PAD:        
5635   1079 12                  LD      (DE),A          ; write a space
5636   107A 13                  INC     DE
5637   107B 10 FC               DJNZ    PAD             ; loop until the end of the line
5638   107D             
5639   107D             CHECK_END:
5640   107D 0D                  DEC     C               ; end of the screen?
5641   107E 20 E9               JR      NZ, COPY_LINE
5642   1080             
5643   1080             FILL_TO_END:
5644   1080 3E 27               LD      A, $27          ; check if we are at the 
5645   1082 BA                  CP      D               ; is DE > $27xx
5646   1083 DA 8B 10            JP      C, DISPLAY_END  ; yes
5647   1086 AF                  XOR     A               ; no, fill with space
5648   1087 12                  LD      (DE), A         ; 
5649   1088 13                  INC     DE              ;
5650   1089 18 F5               JR      FILL_TO_END     ; back for more
5651   108B             
5652   108B             DISPLAY_END:
5653   108B                                             ; B is 0 at this point
5654   108B C9                  RET                     ; finished
5655   108C             
5656   108C             ;##########################################################
5657   108C             ; display loading screen
5658   108C             ; /------------\
5659   108C             ; |LOADING ....|
5660   108C             ; \------------/
5661   108C             
5662   108C             DRAW_BOX:
5663   108C                     
5664   108C AF                  XOR     A               ; clear the screen, using A=0
5665   108D 21 00 24            LD      HL, $2400       ; start of video RAM
5666   1090 11 01 24            LD      DE, $2401       ; the next byte
5667   1093 01 FF 03            LD      BC, $03FF       ; number of bytes to clear
5668   1096 77                  LD      (HL), A         ; Clear the first byte
5669   1097 ED B0               LDIR                    ; Clear all the rest
5670   1099                     
5671   1099 11 49 25            LD      DE, LINE1_POS   ; draw the top of the box
5672   109C 21 DA 11            LD      HL, BOXTOP   
5673   109F 01 0E 00            LD      BC, $0E
5674   10A2 ED B0               LDIR
5675   10A4             
5676   10A4 11 89 25            LD      DE, LINE3_POS   ; draw the bottom of the box
5677   10A7 21 04 12            LD      HL, BOXBOTTOM
5678   10AA 01 0E 00            LD      BC, $0E
5679   10AD ED B0               LDIR
5680   10AF             
5681   10AF C9                  RET
5682   10B0             
5683   10B0             ;##########################################################
5684   10B0             ; diplay the current value of HL in the loading / saving box
5685   10B0             ; works from right to left, updating as few digits as necessary
5686   10B0             ; (if a digit is not 0, then don't update anything to it's left)
5687   10B0             ;
5688   10B0             DISPLAY_HL:        
5689   10B0 11 75 25            LD      DE, DIGITS_POS+3
5690   10B3 0E 0F               LD      C, $0F          ; 0F is used a lot, so preload it                  
5691   10B5                     
5692   10B5                     ; start with the LSB ...L
5693   10B5 7D                  LD      A, L
5694   10B6 A1                  AND     C
5695   10B7 28 1F               JR      Z, DISPLAY_HL_END  ; skip to the end if this is non-zero
5696   10B9             
5697   10B9                     ; ...L is 0, so also update ..L.
5698   10B9 C6 1C               ADD     A, $1C
5699   10BB 12                  LD      (DE), A
5700   10BC 1B                  DEC     DE
5701   10BD             
5702   10BD                     ; display ..L.
5703   10BD 7D                  LD      A, L
5704   10BE 1F                  RRA
5705   10BF 1F                  RRA
5706   10C0 1F                  RRA
5707   10C1 1F                  RRA
5708   10C2 A1                  AND     C
5709   10C3 28 13               JR      Z, DISPLAY_HL_END  ; skip to the end if this is non-zero
5710   10C5             
5711   10C5                     ; ..LL is 00, so also update .H..
5712   10C5 C6 1C               ADD     A, $1C
5713   10C7 12                  LD      (DE), A
5714   10C8 1B                  DEC     DE
5715   10C9             
5716   10C9                     ; display .H..
5717   10C9 7C                  LD      A, H
5718   10CA A1                  AND     C
5719   10CB 28 0B               JR      Z, DISPLAY_HL_END  ; skip to the end if this is non-zero
5720   10CD             
5721   10CD                     ; .HLL is 000, so also update H...
5722   10CD C6 1C               ADD     A, $1C
5723   10CF 12                  LD      (DE), A
5724   10D0 1B                  DEC     DE
5725   10D1             
5726   10D1                     ; display H
5727   10D1 7C                  LD      A, H
5728   10D2 1F                  RRA
5729   10D3 1F                  RRA
5730   10D4 1F                  RRA
5731   10D5 1F                  RRA
5732   10D6 E6 0F               AND     $0F
5733   10D8             
5734   10D8             DISPLAY_HL_END:
5735   10D8 C6 1C               ADD     A, $1C
5736   10DA 12                  LD      (DE), A
5737   10DB              
5738   10DB C9                  RET
5739   10DC             
5740   10DC             ;##########################################################
5741   10DC             ; replacement LOAD function with countdown
5742   10DC             NEW_LOAD:       
5743   10DC C1                  POP     BC              ; discard the return address.
5744   10DD             
5745   10DD CD 8C 10            CALL    DRAW_BOX
5746   10E0             
5747   10E0 11 69 25            LD      DE, LINE2_POS   ; draw the LOADING message
5748   10E3 21 E8 11            LD      HL, LOADING 
5749   10E6 01 0E 00            LD      BC, $0E
5750   10E9 ED B0               LDIR
5751   10EB             
5752   10EB             ;; LOAD-1
5753   10EB 01 12 57    LOAD_1: LD      BC,$5712        ; set the timing constants.
5754   10EE             
5755   10EE 3E 7F               LD      A,$7F           ; read from port $7FFE.
5756   10F0 DB FE               IN      A,($FE)         ; the keyboard row with space.
5757   10F2 E6 21               AND     IO_FE_MASK      ; mask all but the tape and space column bits
5758   10F4             
5759   10F4             ;; LOAD-2
5760   10F4 57          LOAD_2: LD      D, A            ; save the old state 
5761   10F5                     
5762   10F5 1F                  RRA                     ; test the outer key.
5763   10F6 D2 03 02            JP      NC,L0203        ; back, if pressed, indirectly to MAIN-EXEC
5764   10F9 17                  RLA                     ; rotate back
5765   10FA                     
5766   10FA             ;; LOAD-3
5767   10FA 3E 7F       LOAD_3: LD      A,$7F           ; read from port $7FFE.
5768   10FC DB FE               IN      A,($FE)         ; the keyboard row with space.
5769   10FE E6 21               AND     IO_FE_MASK      ; mask all but the tape and space column bits
5770   1100             
5771   1100 BA                  CP      D               ; test if this is the same as the previous byte
5772   1101 C2 F4 10            JP      NZ, LOAD_2      ; if different go and test for break or restart counter        
5773   1104                     
5774   1104 0B                  DEC     BC              ; decrement timer
5775   1105 78                  LD      A,B             ; and test 
5776   1106 B1                  OR      C               ; for zero.
5777   1107 20 F1               JR      NZ,LOAD_3       ; back if not to inner loop LOAD-3.
5778   1109             
5779   1109                     ; at this point, the value has been stable for a few seconds
5780   1109             
5781   1109 FD 34 0B            INC     (IY+$0B)        ; increment E_LINE_hi to prevent premature
5782   110C                                             ; end after loading E_LINE-lo.
5783   110C                                             ; see TEST-END.
5784   110C             
5785   110C 21 00 40            LD      HL,$4000        ; start of RAM - system variables to be         
5786   110F                                             ; overwritten.
5787   110F             
5788   110F             ; ^^^^v^v^v^v^^^^ = 0
5789   110F             ; ^^^^v^v^v^v^v^v^v^v^v^^^^ = 1
5790   110F             
5791   110F             ; A scratch
5792   110F             ; B pulse timer
5793   110F             ; C transition counter
5794   110F             ; D previous value of the io port (masked)
5795   110F             ; E bit counter
5796   110F             ; HL destination address
5797   110F             
5798   110F             LOAD_BYTE:
5799   110F 1E 08               LD      E, $08          ; load bit counter
5800   1111             
5801   1111             LOAD_BIT:
5802   1111 0E 00               LD      C, $00          ; clear transition counter
5803   1113             
5804   1113             LOAD_WAIT:
5805   1113                     ; wait for the next bit to start
5806   1113 3E 7F               LD      A,$7F           ; read from port $7FFE.
5807   1115 DB FE               IN      A,($FE)         ; the keyboard row with space.
5808   1117 E6 21               AND     IO_FE_MASK      ; mask all but the tape and space column bits
5809   1119             
5810   1119 BA                  CP      D               ; test if this is the same as the previous byte
5811   111A CA 13 11            JP      Z, LOAD_WAIT    ; if the same, keep waiting
5812   111D                             
5813   111D CB 47               BIT     0, A            ; has this changed becase of the space key?
5814   111F CA 4D 02            JP      Z,L024D         ; yes space / break pressed -> LD-ABORT
5815   1122             
5816   1122 57                  LD      D, A            ; store previous value
5817   1123             
5818   1123             LOAD_PULSE:
5819   1123 06 14               LD      B, $14          ; number of tests before bit transitions over
5820   1125             
5821   1125             LOAD_TEST:
5822   1125 3E 7F               LD      A,$7F           ; read from port $7FFE.
5823   1127 DB FE               IN      A,($FE)         ; the keyboard row with space.
5824   1129 E6 21               AND     IO_FE_MASK      ; mask all but the tape and space column bits
5825   112B             
5826   112B BA                  CP      D               ; test if this is the same as the previous byte
5827   112C CA 38 11            JP      Z, LOAD_SAME    ; if the same, different skip forward
5828   112F                             
5829   112F CB 47               BIT     0, A            ; has this changed becase of the space key?
5830   1131 CA 4D 02            JP      Z,L024D         ; yes space / break pressed -> LD-ABORT
5831   1134             
5832   1134 0C                  INC     C               ; transition detected, increment counter
5833   1135 57                  LD      D, A            ; store previous value
5834   1136             
5835   1136 18 EB               JR      LOAD_PULSE      ; loop back for more
5836   1138             
5837   1138             LOAD_SAME:
5838   1138 10 EB               DJNZ    LOAD_TEST       ; keep looping up to 16 times
5839   113A             
5840   113A                     ; no transition has been detected for 16 tests
5841   113A             
5842   113A 79                  LD      A, C            ; check the transition count
5843   113B                     
5844   113B FE 04               CP      $04             ; is it < 4
5845   113D 38 D0               JR      C, LOAD_BYTE    ; error, start again
5846   113F             
5847   113F FE 0A               CP      $0A             ; is C < 10
5848   1141 38 06               JR      C, LOAD_ZERO    ; it's a zero
5849   1143             
5850   1143 FE 14               CP      $14             ; is C < 20
5851   1145 38 05               JR      C, LOAD_ONE     ;
5852   1147             
5853   1147 18 C6               JR      LOAD_BYTE       ; error, start again
5854   1149             
5855   1149             LOAD_ZERO:
5856   1149 3F                  CCF                     ; clear carry    
5857   114A 18 00               JR      LOAD_NEXT
5858   114C             
5859   114C             LOAD_ONE:
5860   114C             
5861   114C             LOAD_NEXT:
5862   114C CB 16               RL      (HL)            ; rotate the bit into position.
5863   114E             
5864   114E 1D                  DEC     E               ; decrememnt bit counter
5865   114F 20 C0               JR      NZ, LOAD_BIT    ; get next bit
5866   1151             
5867   1151                     ; 8 bits complete
5868   1151             
5869   1151 42                  LD      B, D            ; save D
5870   1152                    
5871   1152             LOAD_TEST_END:                  ; replacement for L01F8
5872   1152 23                  INC     HL              ; increase pointer.
5873   1153 E5                  PUSH    HL              ; store HL
5874   1154 EB                  EX      DE,HL           ; move the pointer value to DE
5875   1155 2A 0A 40            LD      HL,($400A)      ; load HL with E_LINE - the location following
5876   1158                                             ; the variables end-marker.
5877   1158 37                  SCF                     ; set carry
5878   1159 ED 52               SBC     HL,DE           ; trial subtraction.
5879   115B 38 07               JR      C,LOAD_END      ; end if no more bytes to do.
5880   115D             
5881   115D CD B0 10            CALL    DISPLAY_HL      ; show the progress
5882   1160             
5883   1160 E1                  POP     HL              ; restore pointer.
5884   1161 50                  LD      D, B            ; restore D
5885   1162             
5886   1162 18 AB               JR      LOAD_BYTE       ; get next byte
5887   1164             
5888   1164             LOAD_END:
5889   1164                     ; end has been reached
5890   1164                     
5891   1164                     ; check for nocash LD H,L trick by Martin Korth
5892   1164 11 65 76            LD      DE,$7665        ; check if (402A) = 7665
5893   1167 2A 2A 40            LD      HL,($402A)      ; 
5894   116A 3F                  CCF                     ; clear carry
5895   116B ED 52               SBC     HL,DE           ; check if they are the same
5896   116D CA 40 40            JP      Z,$4040         ; if they match, jump to $4040
5897   1170             
5898   1170                                             ; not an autostart
5899   1170 C3 83 02            JP      L0283           ; JUMP to MAIN-EXEC to list the program
5900   1173             
5901   1173             
5902   1173             ;##########################################################
5903   1173             
5904   1173             ; replacement SAVE function with countdown
5905   1173             NEW_SAVE:       
5906   1173 C1                  POP     BC              ; discard the return address.
5907   1174             
5908   1174 CD 8C 10            CALL    DRAW_BOX
5909   1177             
5910   1177 11 69 25            LD      DE, LINE2_POS   ; draw the SAVING message
5911   117A 21 F6 11            LD      HL, SAVING 
5912   117D 01 0E 00            LD      BC, $0E
5913   1180 ED B0               LDIR
5914   1182             
5915   1182             ;; SAVE
5916   1182 11 CB 12            LD      DE,$12CB        ; timing value of 5 seconds for leader.
5917   1185             
5918   1185 AF                  XOR     A               ; start with the output low
5919   1186 D3 FE               OUT     ($FE), A        ;
5920   1188             
5921   1188             ;; SAVE-1
5922   1188 3E 7F       SAVE_1: LD      A,$7F           ; read port $7FFE.
5923   118A DB FE               IN      A,($FE)         ; all 16 bits are placed on address bus.
5924   118C 1F                  RRA                     ; test for the space key.
5925   118D 30 48               JR      NC,SAVE_EXIT    ; forward, if pressed, indirectly to MAIN-EXEC.
5926   118F             
5927   118F             ;; SAVE-2
5928   118F 10 FE       SAVE_2: DJNZ    SAVE_2          ; delay self-looping to SAVE-2
5929   1191             
5930   1191 1B                  DEC     DE              ; decrement
5931   1192 7A                  LD      A,D             ; and test
5932   1193 B3                  OR      E               ; for zero.
5933   1194 20 F2               JR      NZ,SAVE_1       ; back if not zero to outer delay loop SAVE-1.
5934   1196             
5935   1196 21 00 40            LD      HL,$4000        ; commence saving at start of RAM.
5936   1199             
5937   1199             ;; SAVE-3
5938   1199 11 08 F8    SAVE_3: LD      DE,$F808        ; register E counts the 8 bits.
5939   119C                                             ; $F8 is first delay.
5940   119C             
5941   119C             ;; EACH-BIT
5942   119C             EACH_BIT:  
5943   119C CB 06               RLC     (HL)            ; spin the actual program byte.
5944   119E 9F                  SBC     A,A             ; $FF or $00.
5945   119F E6 05               AND     $05             ; $05 or $00.
5946   11A1 C6 04               ADD     A,$04           ; $09 or $04.
5947   11A3 4F                  LD      C,A             ; timer to C.
5948   11A4                                             ; a set bit has a pulse longer than
5949   11A4                                             ; an unset bit.
5950   11A4             
5951   11A4             ;; SAVE-4
5952   11A4 3E 08       SAVE_4: LD      A, $08          ; set save output high
5953   11A6 D3 FE               OUT     ($FE),A         ; pulses
5954   11A8             
5955   11A8 06 24               LD      B,$24           ; delay counter.
5956   11AA             
5957   11AA             ;; SAVE-5
5958   11AA 10 FE       SAVE_5: DJNZ    SAVE_5          ; self loop for delay to SAVE-5
5959   11AC             
5960   11AC AF                  XOR     A               ; set save output low
5961   11AD D3 FE               OUT     ($FE), A        ;
5962   11AF             
5963   11AF 06 23               LD      B,$23           ; another delay counter.
5964   11B1             
5965   11B1             ;; SAVE-6
5966   11B1 10 FE       SAVE_6: DJNZ    SAVE_6          ; self loop for delay2 to SAVE-6
5967   11B3             
5968   11B3 0D                  DEC     C               ; decrement pulse counter
5969   11B4 20 EE               JR      NZ,SAVE_4       ; back while more to SAVE-4.
5970   11B6             
5971   11B6 42                  LD      B,D             ; a terminating delay - D is zero (256).
5972   11B7             
5973   11B7             ;; SAVE-7
5974   11B7 00          SAVE_7: NOP                     ; 4 T-states.
5975   11B8 10 FD               DJNZ    SAVE_7          ; execute the NOP 256 times.
5976   11BA             
5977   11BA 16 FE               LD      D,$FE           ; subsequent timing value
5978   11BC 1D                  DEC     E               ; decrement the 8 counter.
5979   11BD 20 DD               JR      NZ,EACH_BIT     ; back if more to EACH-BIT.
5980   11BF             
5981   11BF 3E 7F               LD      A,$7F           ; read the space row 
5982   11C1 DB FE               IN      A,($FE)         ; 
5983   11C3 1F                  RRA                     ; test for space key pressed
5984   11C4 30 11               JR      NC,SAVE_EXIT    ; forward, if so, indirectly to MAIN-EXEC.
5985   11C6             
5986   11C6             SAVE_TEST_END:                  ; replacement for L01F8
5987   11C6 23                  INC     HL              ; increase pointer.
5988   11C7 E5                  PUSH    HL              ; store HL
5989   11C8 EB                  EX      DE,HL           ; move the pointer value to DE
5990   11C9 2A 0A 40            LD      HL,($400A)      ; load HL with E_LINE - the location following
5991   11CC                                             ; the variables end-marker.
5992   11CC 37                  SCF                     ; set carry
5993   11CD ED 52               SBC     HL,DE           ; trial subtraction.
5994   11CF 38 06               JR      C,SAVE_EXIT     ; Finished, exit here
5995   11D1             
5996   11D1 CD B0 10            CALL    DISPLAY_HL      ; show the progress
5997   11D4             
5998   11D4 E1                  POP     HL              ; restore pointer.
5999   11D5             
6000   11D5 18 C2               JR      SAVE_3          ; else back to do another byte.
6001   11D7             
6002   11D7             ;; JUMP-EXEC
6003   11D7             SAVE_EXIT:  
6004   11D7 C3 83 02            JP      L0283           ; jump to MAIN-EXEC to list the program
6005   11DA             
6006   11DA             ; strings and defines
6007   11DA             IO_FE_MASK      EQU     %00100001       ; mask for tape and space column
6008   11DA             
6009   11DA             LINE1_POS       EQU     $2549           ; $2400+32*10+9
6010   11DA             LINE2_POS       EQU     $2569           ; $2400+32*11+9
6011   11DA             LINE3_POS       EQU     $2589           ; $2400+32*12+9
6012   11DA             DIGITS_POS      EQU     $2572           ; LINES2_POS+9
6013   11DA             
6014   11DA             _SPACE          EQU $00
6015   11DA             _SNOW           EQU $09
6016   11DA             _DOT            EQU $1B
6017   11DA             
6018   11DA             __              EQU $00
6019   11DA             _0 		EQU $1C
6020   11DA             _1 		EQU $1D
6021   11DA             _2 		EQU $1E
6022   11DA             _3 		EQU $1F
6023   11DA             _4 		EQU $20
6024   11DA             _5 		EQU $21
6025   11DA             _6 		EQU $22
6026   11DA             _7 		EQU $23
6027   11DA             _8 		EQU $24
6028   11DA             _9 		EQU $25
6029   11DA             _A 		EQU $26
6030   11DA             _B 		EQU $27
6031   11DA             _C 		EQU $28
6032   11DA             _D 		EQU $29
6033   11DA             _E 		EQU $2A
6034   11DA             _F 		EQU $2B
6035   11DA             _G 		EQU $2C
6036   11DA             _H 		EQU $2D
6037   11DA             _I 		EQU $2E
6038   11DA             _J 		EQU $2F
6039   11DA             _K 		EQU $30
6040   11DA             _L 		EQU $31
6041   11DA             _M 		EQU $32
6042   11DA             _N 		EQU $33
6043   11DA             _O 		EQU $34
6044   11DA             _P 		EQU $35
6045   11DA             _Q 		EQU $36
6046   11DA             _R 		EQU $37
6047   11DA             _S 		EQU $38
6048   11DA             _T 		EQU $39
6049   11DA             _U 		EQU $3A
6050   11DA             _V 		EQU $3B
6051   11DA             _W 		EQU $3C
6052   11DA             _X 		EQU $3D
6053   11DA             _Y 		EQU $3E
6054   11DA             _Z 		EQU $3F
6055   11DA             
6056   11DA             BOXTOP:
6057   11DA 87 83 83 83         DEFB    $87, $83, $83, $83, $83, $83, $83, $83, $83, $83, $83, $83, $83, $86
6057   11DE 83 83 83 83 
6057   11E2 83 83 83 83 
6057   11E6 83 86 
6058   11E8             
6059   11E8             LOADING:
6060   11E8 02 31 34 26         DEFB    $02, _L, _O, _A, _D, _I, _N, _G, __, _DOT, _DOT, _DOT, _DOT, $82 
6060   11EC 29 2E 33 2C 
6060   11F0 00 1B 1B 1B 
6060   11F4 1B 82 
6061   11F6             
6062   11F6             SAVING:
6063   11F6 02 38 26 3B         DEFB    $02, _S, _A, _V, _I, _N, _G, __, __, _DOT, _DOT, _DOT, _DOT, $82 
6063   11FA 2E 33 2C 00 
6063   11FE 00 1B 1B 1B 
6063   1202 1B 82 
6064   1204             
6065   1204             BOXBOTTOM:
6066   1204 85 03 03 03         DEFB    $85, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $84
6066   1208 03 03 03 03 
6066   120C 03 03 03 03 
6066   1210 03 84 
6067   1212             
6068   1212             ;##########################################################
6069   1212             
6070   1212             BANNER_TEXT:
6071   1212                     ; "ZX80 BASIC FOR MINSTREL 4TH V1.0"
6072   1212 3F 3D 24 1C         DEFB    _Z, _X, _8, _0, __, _B, _A, _S, _I, _C, __
6072   1216 00 27 26 38 
6072   121A 2E 28 00 
6073   121D 2B 34 37 00         DEFB    _F, _O, _R, __, _M, _I, _N, _S, _T, _R, _E, _L, __
6073   1221 32 2E 33 38 
6073   1225 39 37 2A 31 
6073   1229 00 
6074   122A 20 39 2D 00         DEFB    _4, _T, _H, __, _V, _1, _DOT, _0
6074   122E 3B 1D 1B 1C 
6075   1232             BANNER_TEXT_END:
6076   1232             
6077   1232             ;##########################################################
6078   1232             
6079   1FFF             .ORG $1FFF
6080   1FFF FF                  DEFB    $FF
6081   2000             
6082   2000             .END
tasm: Number of errors = 0
